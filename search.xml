<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客地址变更通知]]></title>
    <url>%2F2020%2F03%2F06%2Fblog-move%2F</url>
    <content type="text"><![CDATA[博客地址变更新博客地址变更为: http://liuqh.icu]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes核心概念和术语]]></title>
    <url>%2F2020%2F01%2F03%2Fk8s-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Kubernetes架构图 核心概念PodKubernetes的基本调度单元称为“Pod”，一个Pod包含一个或多个容器，这样可以保证同一个Pod内的容器运行在同一个宿主机上，并且可以共享资源，这些容器使用相同的网络命名空间、IP地址和端口。Kubernetes中的每个Pod都被分配一个唯一的IP地址，这样就可以允许应用程序使用端口而不会有冲突的风险。另外，同一个Pod的容器还可共享一块存储卷空间，可以定义一个卷，如本地磁盘目录或网络磁盘。在Kubernetes中创建、调度和管理的最小单位是Pod，而不是Docker容器。用户可以通过Kubernetes API手动管理Pod，也可以委托给控制器来管理Pod ControllerKubernetes集群的设计中，Pod是有生命周期的对象。用户通过手工创建或由Controller（控制器）直接创建的Pod对象会被“调度器”（Scheduler）调度至集群中的某工作节点运行，待到容器应用进程运行结束之后正常终止，随后就会被删除。 控制器本身也是一种资源类型，它有着多种实现，其中与工作负载相关的实现如Replication Controller、Deployment、StatefulSet、DaemonSet和Jobs等，也可统称它们为Pod控制器。 1.Replication ControllerReplication Controller用于管理、控制Pod的副本数，用于解决Pod的扩容、缩容问题。通常，分布式应用为了性能或高可用性的考虑，需要复制多份资源，并且根据负载情况实现动态伸缩。通过Replication Controller，我们可以指定一个应用需要几份副本，Kubernetes将为每份副本创建一个Pod，并且保证实际运行Pod数量总是与该副本数量相等。如果少于指定数量的Pod副本，Replication Controller会重新启动新的Pod副本，反之会“杀死”多余的副本以保证数量不变 2.DeploymentDeployment的主要职责同样是为了保证Pod的数量和健康，而且绝大多数的功能与Replication Controller完全一样，因此可以被看作新一代的Replication Controller。但是，它又具备了Replication Controller不具备的新特性： 事件和状态查看：可以查看升级的详细进度和状态 回滚：当升级Pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。 版本记录：每一次对Deployment的操作都能保存下来，给予后续可能的回滚使用。 暂停和启动：对于每一次升级，都能够随时暂停和启动。 多种升级方案: Recreate——删除所有已存在的Pod，重新创建新的 RollingUpdate——滚动升级，即逐步替换的策略。滚动升级时支持更多的附加参数，例如，设置最大不可用Pod数量、最小升级间隔时间等。 3.StatefulSetStatefulSet旨在与有状态的应用及分布式系统一起使用。然而，在Kubernetes上管理有状态应用和分布式系统是一个宽泛而复杂的任务。 StatefulSet使用起来相对复杂，当应用具有以下特点时才建议使用StatefulSet： 有唯一的稳定的网络标识符需求。 有稳定性、持久化数据存储需求。 有序的部署和扩展需求。 有序的删除和终止需求。 有序的自动滚动更新需求。 Service Service是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个集合的策略。Service是一组协同工作的Pod，就像多层架构应用中的一层，是Pod的路由代理抽象，用于解决Pod之间的服务发现问题。因为Pod的运行状态可动态变化（比如，Pod迁移到其他机器或者在缩容过程中被终止等），所以访问端不能以固定IP的方式去访问该Pod提供的服务。Service的引入旨在保证Pod的动态变化对访问端透明，访问端只需要知道Service的地址，由Service来提供代理。构成服务的Pod组通过Label选择器来定义。Kubernetes通过给服务分配静态IP地址和域名来提供服务发现机制，并且以轮询调度的方式将流量负载均衡到能与选择器匹配的Pod的IP地址的网络连接上（即使是故障导致Pod从一台机器移动到另一台机器）。默认情况下，一个服务会暴露在集群中（例如，多个后端Pod可能被分组成一个服务，前端Pod的请求在它们之间负载均衡）；但是，一个服务也可以暴露在集群外部（例如，从客户端访问前端Pod）。 Label及Label Selector (标签及标签选择器)Kubernetes将称为Label的键-值对附加到系统中的任何API对象上，如Pod、Service、Replication Controller等。实际上，Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但每个Label的Key只能是唯一值。相应地，Lable Selector则是针对匹配对象的标签来进行的查询。Label和LabelSelector是Kubernetes中的主要分组机制，用于确定操作适用的组件。 Kubernetes集群组件Master组件Master是Kubernetes分布式集群的管理控制中枢，所有任务分配都来自于此。 Master节点主要由四个模块组成：API Server、scheduler、controller manager、etcd。 1. API Server提供了Kubernetes资源对象的唯一操作入口，其他组件都必须通过它提供的API来操作资源数据，通过对相关的资源数据“全量查询+变化监听”，这些组件可以很“实时”地完成相关的业务功能，比如新建Pod的请求一旦被提交到API服务器中，Controller Manager就会立即发现并开始调度。 2. scheduler负责集群的资源调度，以及Pod在集群节点中的调度分配。资源调度在整个Kubernetes管理节点中是一个独立的组件，也就意味着可以根据客户需求定制化开发自己的调度器或者替换成第三方调度器。 3.controller manager集群内部的管理控制中心，其主要目的是实现Kubernetes集群的故障检测和恢复的自动化工作。比如，根据Replication Controller（RC，复制控制器）的定义完成Pod的复制或移除，以确保Pod实例数符合RC副本的定义；根据Service与Pod的管理关系，完成服务的Endpoint对象的创建和更新：其他诸如Node的发现、管理和状态监控、已“杀死”容器所占磁盘空间及本地缓存的镜像文件的清理等工作也都由Controller Manager来完成 4.etcdEtcd是Kubernetes集群中的一个十分重要的组件，用于保存集群所有的网络配置和对象的状态信息。整个kubernetes系统中一共有两个服务需要用到etcd用来协同和存储配置，分别是: 网络插件: 用etcd存储网络的配置信息。 kubernetes本身，包括各种对象的状态和元信息配置。 Node组件Node也称为Worker或Minion节点，是主从分布式集群架构的计算单元，是分配给Pod并运行Pod的宿主机。Kubernetes集群中的每个计算节点都必须运行Docker引擎以及下面提到的组件，以便与这些容器的网络配置进行通信。每个Node节点主要由三个模块组成：kubelet、kube-proxy、runtime(容器运行时环境) 1. kubeletkubelet是运行于工作节点之上的守护进程，它从APIServer接收关于Pod对象的配置信息并确保它们处于期望的状态。kubelet会在API Server上注册当前工作节点，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点的资源占用状况。 2. runtime(容器运行时环境) :每个Node都要提供一个容器运行时（ContainerRuntime）环境，它负责下载镜像并运行容器。kubelet并未固定链接至某容器运行时环境，而是以插件的方式载入配置的容器环境。这种方式清晰地定义了各组件的边界。 3. kube-proxy :每个工作节点都需要运行一个kube-proxy守护进程，它能够按需为Service资源对象生成iptables或ipvs规则，从而捕获访问当前Service的ClusterIP的流量并将其转发至正确的后端Pod对象。 Kubernetes 运行概要图]]></content>
  </entry>
  <entry>
    <title><![CDATA[K8s-安装Kubernetes1.17]]></title>
    <url>%2F2020%2F01%2F01%2Fk8s-1-%E6%90%AD%E5%BB%BAkubernetes1-17%2F</url>
    <content type="text"><![CDATA[1.环境总览1.1 镜像环境 操作系统: Ubuntu 18.04 Docker版本: Docker 19.03.5.ce Kubernetes: v1.17.0 服务器 IP 角色 serve01 192.168.0.116 master node01 192.168.122.11 node node02 192.168.122.12 node node03 192.168.122.13 node 2.配置修改2.1 修改时区# 查看当前时区 [root@node /]# timedatectl Local time: Thu 2019-12-12 06:24:49 UTC Universal time: Thu 2019-12-12 06:24:49 UTC RTC time: Thu 2019-12-12 06:24:49 Time zone: UTC (UTC, +0000) NTP enabled: n/a NTP synchronized: no RTC in local TZ: no DST active: n/a # 修改时区 [root@node /]# timedatectl set-timezone Asia/Shanghai # 查看修改后时区 [root@node /]# timedatectl Local time: Thu 2019-12-12 14:25:16 CST Universal time: Thu 2019-12-12 06:25:16 UTC RTC time: Thu 2019-12-12 06:25:16 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: n/a NTP synchronized: no RTC in local TZ: no DST active: n/a [root@node /]# 2.2 修改主机名在同一局域网中主机名不应该相同，所以我们需要做修改，下列操作步骤为修改 18.04 版本的 Hostname 查看当前 Hostname root@node:/etc/apt# hostnamectl Static hostname: node Icon name: computer-vm Chassis: vm Machine ID: b4da8301e28e41a783ba960205e1d4d0 Boot ID: 4675071ab63c4b8aa26758456afe7a57 Virtualization: kvm Operating System: Ubuntu 18.04.3 LTS Kernel: Linux 4.15.0-72-generic Architecture: x86-64 修改 Hostname # 使用 hostnamectl 命令修改，其中 kubernetes-master 为新的主机名 hostnamectl set-hostname kubernetes-master 修改 cloud.cfg如果 cloud-init package 安装了，需要修改 cloud.cfg 文件。该软件包通常缺省安装用于处理 cloud`sh如果有该文件vi /etc/cloud/cloud.cfg 该配置默认为 false，修改为 true 即可preserve_hostname: true ## 2.3 关闭防火墙服务 各Node运行的kube-proxy组件均要借助iptables或ipvs构建Service资源对象，该资源对象是Kubernetes的核心资源之一。出于简化问题复杂度之需，这里需要事先关闭所有主机之上的iptables或firewalld服务： ```sh # 关闭防火墙 root@node:/etc/apt# ufw disable Firewall stopped and disabled on system startup # 查看防火墙状态 root@node:/etc/apt# ufw status Status: inactive 2.4 关闭并禁用SELinux 临时关闭 setenforce 0 永久关闭编辑/etc/sysconfig/selinux文件，以彻底禁用SELinux。[root@node /]# sed -i &#39;s@^\(SELINUX=\).*@\1disabled@&#39; /etc/sysconfig/selinux 2.5 禁用Swap设备kubeadm默认会预先检查当前主机是否禁用了Swap设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的Swap设备。关闭Swap设备，需要分两步完成。 第一步:关闭交换空间 # 关闭前查看 root@node:~# free -m total used free shared buff/cache available Mem: 1993 116 1126 0 750 1724 Swap: 2047 0 2047 # 关闭 root@node:~# swapoff -a # 关闭后查看 root@node:~# free -m total used free shared buff/cache available Mem: 1993 115 1127 0 750 1725 Swap: 0 0 0 第二步:避免开机启动交换空间注释 /etc/fstab 中的 swap root@node:~# cat /etc/fstab UUID=76051108-098a-49c8-be7f-6be376b069e4 / ext4 defaults 0 0 # /swap.img none swap sw 0 0 2.6 修改apt源编辑 /etc/apt/sources.list 删除原先所有内容，添加以下阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 2.7 设置固定IP 编辑 vim /etc/netplan/50-cloud-init.yaml 配置文件network: ethernets: ens3: #IP地址 addresses: [192.168.122.11/24] # 网关 gateway4: 192.168.122.1 # dns地址 nameservers: addresses: [192.168.122.1] version: 2 使配置生效[root@node /]# netplan apply 2.8 DNS如果发现，服务器不能访问外网，则需要修改DNS 方法一 停止 systemd-resolved 服务 如果不停止systemd-resolved 服务，则会重写/etc/resolv.conf，把之前的配置覆盖掉 [root@node /]# systemctl stop systemd-resolved 修改配置文件 vim /etc/resolv.conf，将 nameserver修改114.114.114.114,如下 root@node01:~# cat /etc/resolv.conf # This file is managed by man:systemd-resolved(8). Do not edit. # # This is a dynamic resolv.conf file for connecting local clients to the # internal DNS stub resolver of systemd-resolved. This file lists all # configured search domains. # # Run &quot;systemd-resolve --status&quot; to see details about the uplink DNS servers # currently in use. # # Third party programs must not access this file directly, but only through the # symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way, # replace this symlink by a static file or a different symlink. # # See man:systemd-resolved.service(8) for details about the supported modes of # operation for /etc/resolv.conf. # nameserver 127.0.0.53 # 把原来的修改为 nameserver 114.114.114.114 options edns0 方法二 修改配置文件vim /etc/systemd/resolved.conf [Resolve] # 此处修改 DNS=114.114.114.114 #FallbackDNS= #Domains= #LLMNR=no #MulticastDNS=no #DNSSEC=no #Cache=yes #DNSStubListener=yes ~ 然后重启 3 安装docker3.1 安装前操作# 安装所需依赖 root@node:~# apt-get -y install apt-transport-https ca-certificates curl software-properties-common # 安装 GPG 证书 root@node:~# curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # 新增软件源信息 root@node:~# add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; # 更新软件源 root@node:~# apt-get -y update # 安装 Docker CE 版 root@node:~# apt-get -y install docker-ce 3.2 设置开机启动# 开机启动 root@node:~# systemctl enable docker Synchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable docker 3.3 配置加速器对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） { &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ] } 重启docker root@node:~# systemctl daemon-reload root@node:~# systemctl restart docker 4. 安装kubeadmkubeadm 是 kubernetes 的集群安装工具，能够快速安装 kubernetes 集群。 4.1 配置kubernetes软件源# 安装 GPG 证书 root@node:~# curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - # 写入软件源；注意：我们用系统代号为 bionic，但目前阿里云不支持，所以沿用 16.04 的 xenial root@node:~# cat &gt; /etc/apt/sources.list.d/kubernetes.list &lt;&lt; EOF deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF # 更新软件源 root@node:~# apt-get update -y 4.2 安装 kubeadm，kubelet，kubectlroot@node:~# apt-get install -y kubelet kubeadm kubectl Reading package lists... Done Building dependency tree Reading state information... Done The following additional packages will be installed: conntrack cri-tools kubernetes-cni socat The following NEW packages will be installed: conntrack cri-tools kubeadm kubectl kubelet kubernetes-cni socat 0 upgraded, 7 newly installed, 0 to remove and 76 not upgraded. Need to get 51.6 MB of archives. After this operation, 272 MB of additional disk space will be used. Get:1 http://mirrors.aliyun.com/ubuntu bionic/main amd64 conntrack amd64 1:1.4.4+snapshot20161117-6ubuntu2 [30.6 kB] Get:2 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 cri-tools amd64 1.13.0-00 [8776 kB] Get:3 http://mirrors.aliyun.com/ubuntu bionic/main amd64 socat amd64 1.7.3.2-2ubuntu2 [342 kB] Get:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubernetes-cni amd64 0.7.5-00 [6473 kB] Get:5 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubelet amd64 1.17.0-00 [19.2 MB] Get:6 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubectl amd64 1.17.0-00 [8742 kB] Get:7 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubeadm amd64 1.17.0-00 [8059 kB] Fetched 51.6 MB in 13s (4034 kB/s) Selecting previously unselected package conntrack. (Reading database ... 67247 files and directories currently installed.) Preparing to unpack .../0-conntrack_1%3a1.4.4+snapshot20161117-6ubuntu2_amd64.deb ... Unpacking conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ... Selecting previously unselected package cri-tools. Preparing to unpack .../1-cri-tools_1.13.0-00_amd64.deb ... Unpacking cri-tools (1.13.0-00) ... Selecting previously unselected package kubernetes-cni. Preparing to unpack .../2-kubernetes-cni_0.7.5-00_amd64.deb ... Unpacking kubernetes-cni (0.7.5-00) ... Selecting previously unselected package socat. Preparing to unpack .../3-socat_1.7.3.2-2ubuntu2_amd64.deb ... Unpacking socat (1.7.3.2-2ubuntu2) ... Selecting previously unselected package kubelet. Preparing to unpack .../4-kubelet_1.17.0-00_amd64.deb ... Unpacking kubelet (1.17.0-00) ... Selecting previously unselected package kubectl. Preparing to unpack .../5-kubectl_1.17.0-00_amd64.deb ... Unpacking kubectl (1.17.0-00) ... Selecting previously unselected package kubeadm. Preparing to unpack .../6-kubeadm_1.17.0-00_amd64.deb ... Unpacking kubeadm (1.17.0-00) ... Setting up conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ... Setting up kubernetes-cni (0.7.5-00) ... Setting up cri-tools (1.13.0-00) ... Setting up socat (1.7.3.2-2ubuntu2) ... Setting up kubelet (1.17.0-00) ... Created symlink /etc/systemd/system/multi-user.target.wants/kubelet.service → /lib/systemd/system/kubelet.service. Setting up kubectl (1.17.0-00) ... Processing triggers for man-db (2.8.3-2ubuntu0.1) ... Setting up kubeadm (1.17.0-00) ... 4.3 kubeadm，kubelet，kubectl 功能介绍 kubeadm：用于初始化 Kubernetes 集群 kubectl：Kubernetes 的命令行工具，主要作用是部署和管理应用，查看各种资源，创建，删除和更新组件 kubelet：主要负责启动 Pod 和容器 5. 配置kubeadm安装 kubernetes 主要是安装它的各个镜像，而 kubeadm 已经为我们集成好了运行 kubernetes 所需的基本镜像。但由于国内的网络原因，在搭建环境时，无法拉取到这些镜像。此时我们只需要修改为阿里云提供的镜像服务即可解决该问题。 5.1 创建配置创建配置文件所在的目录: mkdir -p /usr/local/docker/kubernetes，也可以在其他地方创建，建议在此处创建。 root@node:~# cd /usr/local/docker/kubernetes/ # 获取配置 root@node:/usr/local/docker/kubernetes# kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml W0104 16:59:10.279204 24908 validation.go:28] Cannot validate kube-proxy config - no validator is available W0104 16:59:10.279269 24908 validation.go:28] Cannot validate kubelet config - no validator is available 5.2 修改配置# 修改配置为如下内容 apiVersion: kubeadm.k8s.io/v1beta1 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration localAPIEndpoint: # 修改为主节点 IP advertiseAddress: 192.168.0.116 bindPort: 6443 nodeRegistration: criSocket: /var/run/dockershim.sock name: kubernetes-master taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta1 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controlPlaneEndpoint: &quot;&quot; controllerManager: {} dns: type: CoreDNS etcd: local: dataDir: /var/lib/etcd # 国内不能访问 Google，修改为阿里云 imageRepository: registry.aliyuncs.com/google_containers kind: ClusterConfiguration # 确认版本号是否一致 kubernetesVersion: v1.17.0 networking: dnsDomain: cluster.local # flannel 网络 podSubnet: &quot;10.244.0.0/16&quot; serviceSubnet: 10.96.0.0/12 scheduler: {} 5.3 查看镜像# 查看所需镜像列表 [root@serve01 kubernetes ]$ kubeadm config images list --config kubeadm.yml W0105 17:50:34.538613 23098 validation.go:28] Cannot validate kube-proxy config - no validator is available W0105 17:50:34.538662 23098 validation.go:28] Cannot validate kubelet config - no validator is available registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.0 registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.0 registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.0 registry.aliyuncs.com/google_containers/kube-proxy:v1.17.0 registry.aliyuncs.com/google_containers/pause:3.1 registry.aliyuncs.com/google_containers/etcd:3.4.3-0 registry.aliyuncs.com/google_containers/coredns:1.6.5 5.4 拉取镜像# 拉取镜像 [root@serve01 kubernetes ]$ kubeadm config images pull --config kubeadm.yml W0105 17:50:51.746492 23130 validation.go:28] Cannot validate kube-proxy config - no validator is available W0105 17:50:51.746533 23130 validation.go:28] Cannot validate kubelet config - no validator is available [config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.0 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.0 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.0 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.17.0 [config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.1 [config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.4.3-0 [config/images] Pulled registry.aliyuncs.com/google_containers/coredns:1.6.5 6. 使用kubeadm 搭建 kubernetes 集群6.1 启动master节点执行以下命令初始化主节点，该命令指定了初始化时需要使用的配置文件，追加的 tee kubeadm-init.log 用以输出日志。 # 通过配置文件启动master节点 [root@serve01 kubernetes ]$ kubeadm init --config=kubeadm.yml | tee kubeadm-init.log W0105 17:51:53.776645 23228 validation.go:28] Cannot validate kube-proxy config - no validator is available W0105 17:51:53.776691 23228 validation.go:28] Cannot validate kubelet config - no validator is available [init] Using Kubernetes version: v1.17.0 [preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/ [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39; [kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot; [kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot; [kubelet-start] Starting the kubelet [certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot; [certs] Generating &quot;ca&quot; certificate and key [certs] Generating &quot;apiserver&quot; certificate and key [certs] apiserver serving cert is signed for DNS names [serve01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.0.116] [certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key [certs] Generating &quot;front-proxy-ca&quot; certificate and key [certs] Generating &quot;front-proxy-client&quot; certificate and key [certs] Generating &quot;etcd/ca&quot; certificate and key [certs] Generating &quot;etcd/server&quot; certificate and key [certs] etcd/server serving cert is signed for DNS names [serve01 localhost] and IPs [192.168.0.116 127.0.0.1 ::1] [certs] Generating &quot;etcd/peer&quot; certificate and key [certs] etcd/peer serving cert is signed for DNS names [serve01 localhost] and IPs [192.168.0.116 127.0.0.1 ::1] [certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key [certs] Generating &quot;apiserver-etcd-client&quot; certificate and key [certs] Generating &quot;sa&quot; key and public key [kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot; [kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file [kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file [kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file [kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file [control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot; [control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot; [control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot; W0105 17:52:04.990074 23228 manifests.go:214] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot; [control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot; W0105 17:52:04.991170 23228 manifests.go:214] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot; [etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot; [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s [kubelet-check] Initial timeout of 40s passed. [apiclient] All control plane components are healthy after 43.539082 seconds [upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace [kubelet] Creating a ConfigMap &quot;kubelet-config-1.17&quot; in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Skipping phase. Please see --upload-certs [mark-control-plane] Marking the node serve01 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#39;&#39;&quot; [mark-control-plane] Marking the node serve01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule] [bootstrap-token] Using token: abcdef.0123456789abcdef [bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles [bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials [bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token [bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster [bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace [kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key [addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.0.116:6443 --token abcdef.0123456789abcdef \ --discovery-token-ca-cert-hash sha256:dc009a8555c2fabf009d18c190b213d69068e81f438a4c77dbd6f59c5bf3e693 6.1.1 kubeadm init 的执行过程 init：指定版本进行初始化操作 preflight：初始化前的检查和下载所需要的 Docker 镜像文件 kubelet-start：生成 kubelet 的配置文件 var/lib/kubelet/config.yaml，没有这个文件 kubelet 无法启动，所以初始化之前的 kubelet 实际上启动不会成功 certificates：生成 Kubernetes 使用的证书，存放在 /etc/kubernetes/pki 目录中 kubeconfig：生成 KubeConfig 文件，存放在 /etc/kubernetes 目录中，组件之间通信需要使用对应文件 control-plane：使用 /etc/kubernetes/manifest 目录下的 YAML 文件，安装 Master 组件 etcd：使用 /etc/kubernetes/manifest/etcd.yaml 安装 Etcd 服务 wait-control-plane：等待 control-plan 部署的 Master 组件启动 apiclient：检查 Master 组件服务状态。 uploadconfig：更新配置 kubelet：使用 configMap 配置 kubelet patchnode：更新 CNI 信息到 Node 上，通过注释的方式记录 mark-control-plane：为当前节点打标签，打了角色 Master，和不可调度标签，这样默认就不会使用 Master 节点来运行 Pod bootstrap-token：生成 token 记录下来，后边使用 kubeadm join 往集群中添加节点时会用到 addons：安装附加组件 CoreDNS 和 kube-proxy 6.1.2 创建所需文件成功后会有以下提示，挨个执行。 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 6.1.3 查看节点状态[root@serve01 kubernetes ]$ kubectl get node NAME STATUS ROLES AGE VERSION serve01 NotReady master 3m4s v1.17.0 6.2 节点加入集群root@node01:~# kubeadm join 192.168.0.116:6443 --token abcdef.0123456789abcdef \ &gt; --discovery-token-ca-cert-hash sha256:dc009a8555c2fabf009d18c190b213d69068e81f438a4c77dbd6f59c5bf3e693 W0105 18:03:00.479801 6753 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set. [preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/ [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39; [kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.17&quot; ConfigMap in the kube-system namespace [kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot; [kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot; [kubelet-start] Starting the kubelet [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run &#39;kubectl get nodes&#39; on the control-plane to see this node join the cluster. 6.3 查看节点状态我加入了3台node节点，在master 通过 kubectl get node 进行查看 [root@serve01 kubernetes ]$ kubectl get node NAME STATUS ROLES AGE VERSION node01 NotReady &lt;none&gt; 3h59m v1.17.0 node02 NotReady &lt;none&gt; 8s v1.17.0 node03 NotReady &lt;none&gt; 3h54m v1.17.0 serve01 NotReady master 4h9m v1.17.0 7.安装网络插件如果没有安装网络，插件节点状态都是NotReady 7.1 安装flannel网络插件[root@serve01 kubernetes ]$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 上述操作会在各个节点下载flannel网络插件相关容器，需要等待.. 查看节点状态 [root@serve01 kubernetes ]$ kubectl get nodes NAME STATUS ROLES AGE VERSION node01 Ready &lt;none&gt; 2d1h v1.17.0 node02 Ready &lt;none&gt; 2d1h v1.17.0 node03 Ready &lt;none&gt; 2d1h v1.17.0 serve01 Ready master 2d1h v1.17.0 查看所有命名空间pod状态 [root@serve01 kubernetes ]$ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-9d85f5447-n8kqg 1/1 Running 0 2d1h kube-system coredns-9d85f5447-q4gwf 1/1 Running 0 2d1h kube-system etcd-serve01 1/1 Running 0 2d1h kube-system kube-apiserver-serve01 1/1 Running 0 2d1h kube-system kube-controller-manager-serve01 1/1 Running 2 2d1h kube-system kube-flannel-ds-amd64-fx4zg 1/1 Running 0 24h kube-system kube-flannel-ds-amd64-h8kvg 1/1 Running 0 24h kube-system kube-flannel-ds-amd64-pbjrl 1/1 Running 0 24h kube-system kube-flannel-ds-amd64-tw8mx 1/1 Running 0 24h kube-system kube-proxy-2pjlk 1/1 Running 0 2d1h kube-system kube-proxy-gkvt5 1/1 Running 0 2d1h kube-system kube-proxy-l8fh9 1/1 Running 0 2d1h kube-system kube-proxy-vvwzj 1/1 Running 0 2d1h kube-system kube-scheduler-serve01 1/1 Running 2 2d1h 到此集群搭建完毕!]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-进阶篇-FutureTask初使用]]></title>
    <url>%2F2019%2F12%2F20%2Fjava-17-FutureTask%E5%88%9D%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. FutureTask简介FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。 根据FutureTask.run()方法被执行的时机，FutureTask可以处于下面3种状态。 未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。 已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。 已完成。FutureTask.run()方法执行完后正常结束，或被取消（FutureTask.cancel（…）），或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。 2. FutureTask状态迁移 2.1 get和cancel使用介绍 当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞； 当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。 当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行； 当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务； 当FutureTask处于已启动状态时，执行FutureTask. cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）； 当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。 以上内容摘自《Java并发的艺术》第十章第四节 FutureTask详情 片段。 3. FutureTask使用3.1 计算1~10阶乘的和10! + 9! + ...+1! = ? 阶乘的概念: 3.2 futureTask实现package com.hui.javalearn.thread.futureTask; import java.util.ArrayList; import java.util.concurrent.*; /** * description : * * @author : Mr.Liuqh * @date : 2019-12-30 11:55 */ public class FutureTaskTest { /** * 并行计算 */ public void testTask() { long beginTime = System.currentTimeMillis(); // 实例化本类，用于后续使用内部类实例化 FutureTaskTest futureTaskTest = new FutureTaskTest(); // 创建任务列表 ArrayList&lt;FutureTask&lt;Integer&gt;&gt; futureTaskList = new ArrayList&lt;&gt;(); // 创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); for (int i = 1; i &lt;= 10; i++) { // 传入Callable对象创建FutureTask对象 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(futureTaskTest.new ComputerTask(i)); // 添加到任务列表 futureTaskList.add(futureTask); // 提交给线程池执行任务，也可以通过exec.invokeAll(taskList)一次性提交所有任务 executorService.submit(futureTask); } // 任务已经提交完 System.out.println(&quot;任务已经提交完,主线程继续执行....&quot;); // 获取任务结果 ArrayList&lt;Integer&gt; taskResultList = new ArrayList&lt;&gt;(); for (FutureTask&lt;Integer&gt; futureTaskItem : futureTaskList) { try { // 获取任务执行结果，会造成主线程阻塞 Integer total = futureTaskItem.get(); taskResultList.add(total); } catch (ExecutionException | InterruptedException e) { e.printStackTrace(); } } // 求和 Integer integer = taskResultList.stream().reduce(Integer::sum).get(); long useTime = (System.currentTimeMillis() - beginTime) / 1000L; System.out.println(&quot;10! + 9! + ...+1! = &quot; + integer ); System.out.println(&quot; 一共耗时:&quot; + useTime + &quot;秒&quot;); // 关闭线程池 executorService.shutdown(); System.out.println(&quot;任务执行完毕。&quot;); } /** * desc : 定义内部类 **/ private class ComputerTask implements Callable&lt;Integer&gt; { private Integer num; private Integer total; ComputerTask(Integer i) { this.num = i; } @Override public Integer call() throws Exception { total = 1; String s =&quot;&quot;; for (int i = 1; i &lt;= this.num; i++) { total *= i; s = s.concat(String.valueOf(i)).concat(&quot; * &quot;); } // 字符串截取 String substring = s.substring(0,s.length()-2); // 休眠1秒钟，逾期主线程会继续执行，在主线程调用futureTask.get()，会阻塞，等待结果返回 Thread.sleep(1000); System.out.println(substring + &quot; = &quot; + total); return total; } } } ... // 运行 new FutureTaskTest().testTask(); /* 输出: 任务已经提交完,主线程继续执行.... 1 * 2 = 2 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 = 362880 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320 1 * 2 * 3 = 6 1 * 2 * 3 * 4 * 5 * 6 = 720 1 * 2 * 3 * 4 = 24 1 = 1 1 * 2 * 3 * 4 * 5 = 120 10! + 9! + ...+1! = 4037913 一共耗时:1秒 任务执行完毕。 3.2 串行实现package com.hui.javalearn.thread.futureTask; import java.util.ArrayList; import java.util.concurrent.*; /** * description : * * @author : Mr.Liuqh * @date : 2019-12-30 11:55 */ public class FutureTaskTest { /** * desc : 定义内部类 **/ private class ComputerTask implements Callable&lt;Integer&gt; { private Integer num; private Integer total; ComputerTask(Integer i) { this.num = i; } @Override public Integer call() throws Exception { total = 1; String s =&quot;&quot;; for (int i = 1; i &lt;= this.num; i++) { total *= i; s = s.concat(String.valueOf(i)).concat(&quot; * &quot;); } // 字符串截取 String substring = s.substring(0,s.length()-2); // 休眠1秒钟，逾期主线程会继续执行，在主线程调用futureTask.get()，会阻塞，等待结果返回 Thread.sleep(1000); System.out.println(substring + &quot; = &quot; + total); return total; } } /** * 串行计算 */ public void testSerialTask() throws Exception { long beginTime = System.currentTimeMillis(); FutureTaskTest futureTaskTest = new FutureTaskTest(); ArrayList&lt;Integer&gt; taskResultList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) { Integer call = futureTaskTest.new ComputerTask(i).call(); taskResultList.add(call); } // 求和 Integer integer = taskResultList.stream().reduce(Integer::sum).get(); long useTime = (System.currentTimeMillis() - beginTime) / 1000L; System.out.println(&quot;10! + 9! + ...+1! = &quot; + integer ); System.out.println(&quot;一共耗时:&quot; + useTime + &quot;秒&quot;); } } ... // 运行 /* 输出: 1 = 1 1 * 2 = 2 1 * 2 * 3 = 6 1 * 2 * 3 * 4 = 24 1 * 2 * 3 * 4 * 5 = 120 1 * 2 * 3 * 4 * 5 * 6 = 720 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 = 362880 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800 10! + 9! + ...+1! = 4037913 一共耗时:10秒 查看源码 4.参考链接 FutureTask的用法及两种常用的使用场景 可取消的异步任务——FutureTask用法及解析]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-Collect方法详解]]></title>
    <url>%2F2019%2F12%2F16%2Fjava-16-Stream-collect%2F</url>
    <content type="text"><![CDATA[1 collect是什么collect是对流(Stream)进行mutable reduction(可变缩减操作)操作的接口函数，已经有很多文章介绍collect多么牛逼，多么强大。对于初学Java的我这里只总结怎么用；想了解更多的，可以查看以下链接。 终极武器collect() 签名 有如下两个签名 // 第一种 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); // 第二种 &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 2. Collector收集器收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西： 目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。 新元素如何添加到容器中？是List.add()还是Map.put()。 如果并行的进行规约，还需要告诉collect(),多个部分结果如何合并成一个。 结合以上分析，collect()方法定义为 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)， 三个参数依次对应上述三条分析。不过每次调用collect()都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以collect()的另一定义为&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)。Collectors工具类可通过静态方法生成各种常用的Collector。 3. 具体使用3.1 toList/toSet : 转成集合List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); // toList操作 List&lt;Integer&gt; collectList = integerList.stream().filter(integer -&gt; integer % 3 == 0).collect(Collectors.toList()); System.out.println(&quot;toList结果 -&gt; &quot; + collectList + &quot;&quot;); // 输出: toList结果 -&gt; [3, 6, 9] // toSet操作 Set&lt;Integer&gt; collectSet = integerList.stream().filter(integer -&gt; integer % 2 == 0).collect(Collectors.toSet()); System.out.println(&quot;toSet结果 -&gt; &quot; + collectSet + &quot;&quot;); // 输出: toSet结果 -&gt; [2, 4, 6, 8] 3.2 toCollection : 转换成特定的集合List&lt;Integer&gt; integers = Arrays.asList(11, 22, 14, 6, 9); ArrayList&lt;Integer&gt; arrayList = integers.stream().collect(Collectors.toCollection(ArrayList::new)); System.out.println(&quot;toCollection 转ArrayList -&gt; &quot; + arrayList + &quot;&quot;); // 输出: toCollection 转ArrayList -&gt; [11, 22, 14, 6, 9] HashSet&lt;Integer&gt; hashSet = integers.stream().collect(Collectors.toCollection(HashSet::new)); System.out.println(&quot;toCollection 转HashSet -&gt; &quot; + hashSet + &quot;&quot;); // 输出: toCollection 转HashSet -&gt; [22, 6, 9, 11, 14] TreeSet&lt;Integer&gt; treeSet = integers.stream().collect(Collectors.toCollection(TreeSet::new)); System.out.println(&quot;toCollection 转TreeSet -&gt; &quot; + treeSet + &quot;&quot;); // 输出: toCollection 转TreeSet -&gt; [6, 9, 11, 14, 22] 3.3 toMap : 转成map1.结合实体类public class Main { public static void main(String[] args) { List&lt;Employee&gt; employees = Arrays.asList( new Employee(&quot;张三&quot;, 18), new Employee(&quot;李四&quot;, 23), new Employee(&quot;王麻子&quot;, 30) ); Map&lt;String, Integer&gt; collect = employees.stream().collect(Collectors.toMap(Employee::getName, Employee::getAge)); System.out.println(&quot;toMap -&gt; &quot; + collect + &quot;&quot;); // 输出: toMap -&gt; {李四=23, 张三=18, 王麻子=30} } static class Employee { private String name; private int age; public Employee(String name, int age) { setName(name); setAge(age); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { StringBuilder str = null; str = new StringBuilder(); str.append(&quot; Name:- &quot; + getName() + &quot; Age:- &quot; + getAge()); return str.toString(); } } } 2.集合直接转List&lt;Integer&gt; integers = Arrays.asList(1, 2, 4, 6, 9); Map&lt;Integer, String&gt; collect = integers.stream().collect(Collectors.toMap(x -&gt; x, x -&gt; String.valueOf(x))); System.out.println(&quot;集合转toMap -&gt; &quot; + collect + &quot;&quot;); // 输出: 集合转toMap -&gt; {1=1, 2=2, 4=4, 6=6, 9=9} 3.4 averagingInt: 求平均值List&lt;Integer&gt; integers = Arrays.asList(11, 22, 14, 6, 9); Double collect = integers.stream().collect(Collectors.averagingInt(x -&gt; x)); System.out.println(&quot;平均值 -&gt; &quot; + collect + &quot;&quot;); // 输出: 平均值 -&gt; 12.4 3.5 joining : 拼接三种签名: //第一种:直接拼接 public static Collector&lt;CharSequence,?,String&gt; joining() // 第二种:以delimiter作为分隔符拼接 public static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter) // 第三种:带有分隔符(delimiter)、前缀(prefix)、后缀(suffix)、拼接 public static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 代码 // 声明一个字符串list List&lt;String&gt; strings = Arrays.asList(&quot;php&quot;, &quot;is&quot;, &quot;the&quot;, &quot;best&quot;,&quot;language&quot;, &quot;!&quot;); // 第一种签名 直接拼接 String joining1 = strings.stream().collect(Collectors.joining()); System.out.println(&quot;第一种签名， 直接拼接 --&gt; &quot; + joining1 + &quot; &quot;); // 第二种签名拼接(以 | 作为分隔符) String joining2 = strings.stream().collect(Collectors.joining(&quot;|&quot;)); System.out.println(&quot;第二种签名，带有分隔符拼接 --&gt; &quot; + joining2 + &quot; &quot;); // 第三种签名，带有分隔符(|)、前缀(preFix_)、后缀(_suffix)、拼接 String joining3 = strings.stream().collect(Collectors.joining(&quot;|&quot;, &quot;preFix_&quot;, &quot;_suffix&quot;)); System.out.println(&quot;第三种签名，带有分隔符、前缀(preFix_)、后缀(_suffix)、拼接 --&gt; &quot; + joining3 + &quot; &quot;); /** 输出: 第一种签名， 直接拼接 --&gt; phpisthebestlanguage! 第二种签名，带有分隔符拼接 --&gt; php|is|the|best|language|! 第三种签名，带有分隔符、前缀(preFix_)、后缀(_suffix)、拼接 --&gt; preFix_php|is|the|best|language|!_suffix */ 3.6 groupingBy : 分组三种签名: // 第一种: public static &lt;T,K&gt; Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier) // 第二种:提供后续收集器(Collector)参数 public static &lt;T,K,A,D&gt; Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier, Collector&lt;? super T,A,D&gt; downstream) // 第三种:指定特定Map类型作为返回值 public static &lt;T,K,D,A,M extends Map&lt;K,D&gt;&gt; Collector&lt;T,?,M&gt; groupingBy(Function&lt;? super T,? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T,A,D&gt; downstream) 代码 employees 类 class Employee { private String name; private int age; private String sex; public Employee(String name, int age,String sex) { setName(name); setAge(age); setSex(sex); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String age) { this.sex = age; } @Override public String toString() { StringBuilder str = null; str = new StringBuilder(); str.append(&quot; Name:- &quot; + getName() + &quot; Age:- &quot; + getAge()); return str.toString(); } } 第一种签名 // 声明一个成员list List&lt;Employee&gt; employees = Arrays.asList( new Employee(&quot;张颖&quot;, 16,&quot;女&quot;), new Employee(&quot;小英&quot;, 25,&quot;女&quot;), new Employee(&quot;王慧&quot;, 22,&quot;女&quot;), new Employee(&quot;李四&quot;, 23,&quot;男&quot;), new Employee(&quot;王麻子&quot;, 27,&quot;男&quot;) ); // 根据性别分组 Map&lt;String, List&lt;Employee&gt;&gt; collect = employees.stream().collect(Collectors.groupingBy(Employee::getSex)); System.out.println(&quot;根据性别分组 : \n &quot; + collect + &quot;\n&quot;); // 根据年龄分组 Map&lt;Integer, List&lt;Employee&gt;&gt; collect11 = employees.stream().collect(Collectors.groupingBy(Employee::getAge)); System.out.println(&quot;根据年龄分组 : \n &quot; + collect11 + &quot;\n&quot;); /** 输出: 根据性别分组 : {女=[ Name:- 张颖 Age:- 16, Name:- 小英 Age:- 25, Name:- 王慧 Age:- 22], 男=[ Name:- 李四 Age:- 23, Name:- 王麻子 Age:- 27]} 根据年龄分组 : {16=[ Name:- 张颖 Age:- 16], 22=[ Name:- 王慧 Age:- 22], 23=[ Name:- 李四 Age:- 23], 25=[ Name:- 小英 Age:- 25], 27=[ Name:- 王麻子 Age:- 27]} 第二种签名 // 声明一个成员list List&lt;Employee&gt; employees = Arrays.asList( new Employee(&quot;张颖&quot;, 16,&quot;女&quot;), new Employee(&quot;小英&quot;, 25,&quot;女&quot;), new Employee(&quot;王慧&quot;, 22,&quot;女&quot;), new Employee(&quot;李四&quot;, 23,&quot;男&quot;), new Employee(&quot;王麻子&quot;, 27,&quot;男&quot;) ); // 根据性别分组后，统计每组的count Map&lt;String, Long&gt; collect1 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, Collectors.counting())); System.out.println(&quot;根据性别分组后，统计每组的count : \n &quot; + collect1 + &quot;\n&quot;); // 根据性别分组后，计算每组的平均年龄 Map&lt;String, Double&gt; collect2 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, Collectors.averagingInt(Employee::getAge))); System.out.println(&quot;根据性别分组后，计算每组的平均年龄: \n &quot; + collect2 + &quot;\n&quot;); // 根据性别分组后，找出每组最大年龄 Map&lt;String, Optional&lt;Employee&gt;&gt; collect5 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, Collectors.maxBy(Comparator.comparingInt(Employee::getAge)))); System.out.println(&quot;根据性别分组后，找出每组最大年龄 : \n &quot; + collect5 + &quot;\n&quot;); // 根据性别、年龄分组(多个字段分组) Map&lt;String, Map&lt;Integer, List&lt;Employee&gt;&gt;&gt; collect3 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, Collectors.groupingBy(Employee::getAge))); System.out.println(&quot;根据性别、年龄分组: \n &quot; + collect3 + &quot;\n&quot;); // 根据性别、年龄分组(多个字段分组)后，统计每个年龄组的人数 Map&lt;String, Map&lt;Integer, Long&gt;&gt; collect4 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, Collectors.groupingBy(Employee::getAge, Collectors.counting()))); System.out.println(&quot;根据性别、年龄分组后，统计每组数量 : \n &quot; + collect4 + &quot;\n&quot;); /** 输出: 根据性别分组后，计算每组的平均年龄: {女=21.0, 男=25.0} 根据性别分组后，找出每组最大年龄 : {女=Optional[ Name:- 小英 Age:- 25], 男=Optional[ Name:- 王麻子 Age:- 27]} 根据性别、年龄分组: {女={16=[ Name:- 张颖 Age:- 16], 22=[ Name:- 王慧 Age:- 22], 25=[ Name:- 小英 Age:- 25]}, 男={23=[ Name:- 李四 Age:- 23], 27=[ Name:- 王麻子 Age:- 27]}} 根据性别、年龄分组后，统计每组数量 : {女={16=1, 22=1, 25=1}, 男={23=1, 27=1}} 第三种签名 // 声明一个成员list List&lt;Employee&gt; employees = Arrays.asList( new Employee(&quot;张颖&quot;, 16,&quot;女&quot;), new Employee(&quot;小英&quot;, 25,&quot;女&quot;), new Employee(&quot;王慧&quot;, 22,&quot;女&quot;), new Employee(&quot;李四&quot;, 23,&quot;男&quot;), new Employee(&quot;王麻子&quot;, 27,&quot;男&quot;) ); // 根据性别分组并指定返回类型为HashMap HashMap&lt;String, List&lt;Employee&gt;&gt; collect6 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, HashMap::new, Collectors.toList())); System.out.println(&quot;根据性别分组并指定返回类型为HashMap : \n &quot; + collect6 + &quot;\n&quot;); // 根据性别分组并、指定返回类型为HashMap,且分组中只显示成员姓名 HashMap&lt;String, List&lt;String&gt;&gt; collect7 = employees.stream().collect(Collectors.groupingBy(Employee::getSex, HashMap::new, Collectors.mapping(Employee::getName, Collectors.toList()))); System.out.println(&quot;根据性别分组并、指定返回类型为HashMap,且分组中只显示成员姓名 : \n&quot; + collect7 + &quot;\n&quot;); /** 输出: 根据性别分组并指定返回类型为HashMap : {女=[ Name:- 张颖 Age:- 16, Name:- 小英 Age:- 25, Name:- 王慧 Age:- 22], 男=[ Name:- 李四 Age:- 23, Name:- 王麻子 Age:- 27]} 根据性别分组并、指定返回类型为HashMap,且分组中只显示成员姓名 : {女=[张颖, 小英, 王慧], 男=[李四, 王麻子]} 3.7 partitioningBy : 分组作用: 把数据分成两部分,key为ture/false。共有两种签名 签名 // 第一种 public static &lt;T&gt; Collector&lt;T,?,Map&lt;Boolean,List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate) // 第二种 public static &lt;T,D,A&gt; Collector&lt;T,?,Map&lt;Boolean,D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,D&gt; downstream) 代码 // 声明一个List List&lt;Integer&gt; integers = Arrays.asList(1, 21, 81, 23, 42, 90, 62, 37); // 第一种签名 // 把数据根据能否被2整除，进行分组 Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(x -&gt; x % 2 ==0)); System.out.println(&quot;能否被2整除，进行分组 -&gt; &quot; + collect + &quot;&quot;); // 第二种签名 // 能否被2整除，进行分组，并统计每组数量 Map&lt;Boolean, Long&gt; collect1 = integers.stream().collect(Collectors.partitioningBy(x -&gt; x % 2 == 0, Collectors.counting())); System.out.println(&quot;能否被2整除，进行分组，并统计每组数量 -&gt; &quot; + collect1 + &quot;&quot;); /** 输出: 能否被2整除，进行分组 -&gt; {false=[1, 21, 81, 23, 37], true=[42, 90, 62]} 能否被2整除，进行分组，并统计每组数量 -&gt; {false=5, true=3} 4.更多方法 查看文档，更多方法]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-Stream使用]]></title>
    <url>%2F2019%2F12%2F15%2Fjava-15-StreamAPI%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。 2. 常见的stream接口继承关系图 图中4种stream接口继承自BaseStream，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图。为不同数据类型设置不同stream接口，可以1.提高性能，2.增加特定接口函数。 需要注意的是，IntStream, LongStream, DoubleStream 并不是Stream的子接口 疑问:为什么不把IntStream, LongStream, DoubleStream 设计成Stream的子接口呢? 原因:这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。 3. 如何得到一个stream？stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因为如此要得到一个stream通常不会手动创建，而是调用对应的工具方法。 3.1 获取stream方法 调用Collection.stream()方法 调用Collection.parallelStream()方法 调用Arrays.stream(T[] array)方法 直接使用Stream.of()方法就能从一组对象创建一个stream对象 4. stream和collections区别虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同： 无存储。 stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。 对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。 stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。 stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 5.操作stream类型对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)， 二者特点是： 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。 区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。 6.操作stream接口方法 操作类型 接口方法 中间操作 concat()、distinct()、filter()、flatMap()、limit()、map()、peek()、skip()、sorted()、parallel()、sequential()、unordered() 结束操作 allMatch()、anyMatch()、collect()、count()、findAny()、findFirst()、forEach()、forEachOrdered()、max()、min()、noneMatch()、reduce()、toArray() 7.stream方法使用stream跟函数接口关系非常紧密，没有函数接口stream就无法工作。【函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。】 7.1 中间操作方法1. concat() : 合并两个stream签名: static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a,tream&lt;? extends T&gt; b) 作用: 创建一个延迟连接的流，其元素是a的所有元素和b的所有元素。 如果两个输入流都是有序的，则对所得到的流进行排序。 如果任一输入流是并行的，则得到的流是平行的。 关闭结果流时，将调用两个输入流的关闭处理程序。 代码: public static void main(String[] args) { // 创建两个stream对象 Stream&lt;String&gt; language1 = Stream.of(&quot;PHP&quot;, &quot;JAVA&quot;); Stream&lt;String&gt; language2 = Stream.of(&quot;GO&quot;, &quot;PYTHON&quot;); // 使用中间操作concat，合并两个stream对象 Stream&lt;String&gt; concat = Stream.concat(language1, language2); // 使用结束操作collect,转成list List&lt;String&gt; collect = concat.collect(Collectors.toList()); System.out.println(collect); // 输出: [PHP, JAVA, GO, PYTHON] } 更多concat用例 2. distinct() : 去重说明:返回:返回由该流的不同元素（根据 Object.equals(Object) ）组成的Stream。 代码: List&lt;String&gt; strings = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;BB&quot;); List&lt;String&gt; collect = strings.stream().distinct().collect(Collectors.toList()); System.out.println(collect);//[AA, BB, CC] 3. filter() : 过滤签名: Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) 返回:作用是返回一个只包含满足predicate条件元素的Stream 代码: List&lt;Integer&gt; integers = Arrays.asList(10, 12, 71, 63, 921, 68, 121); List&lt;Integer&gt; collect = integers.stream().filter(integer -&gt; integer &gt; 100).collect(Collectors.toList()); System.out.println(collect);//[921, 121] 4. flatMap() : 合并签名: &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 作用:把几个小的list转换到一个大的list 效果示意图: 代码: // 初始化一个嵌套集合 [[1, 2], [3, 4, 5]] ArrayList&lt;List&lt;Integer&gt;&gt; arrayLists = new ArrayList(){{ add(Arrays.asList(1, 2)); add(Arrays.asList(3, 4, 5)); }}; // 使用flatMap 把多个小集合合并成大集合 List&lt;Integer&gt; collect = arrayLists.stream().flatMap(pList -&gt; pList.stream()).collect(Collectors.toList()); System.out.println(collect); // 输出 [1, 2, 3, 4, 5] 5. limit() : 截取(返回前N个元素)签名: Stream&lt;T&gt; limit(long maxSize) 作用:对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素； 代码: // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); // 取出前三个元素 List&lt;Integer&gt; collect1 = integers.stream().limit(3).collect(Collectors.toList()); System.out.println(collect1);// 输出 [1, 2, 3] // 取出前6个元素 List&lt;Integer&gt; collect2 = integers.stream().limit(6).collect(Collectors.toList()); System.out.println(collect2);// 输出 [1, 2, 3, 4, 5] 6. skip() : 截取(返回不包含前N个元素)签名: Stream&lt;T&gt; skip(long n) 作用:返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream； 代码: // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); // 取出前三个元素 List&lt;Integer&gt; collect1 = integers.stream().skip(3).collect(Collectors.toList()); System.out.println(collect1);// 输出 [4, 5] // 取出前6个元素 List&lt;Integer&gt; collect2 = integers.stream().skip(6).collect(Collectors.toList()); System.out.println(collect2);// 输出 [] 7. sorted(): 排序签名: Stream&lt;T&gt; sorted()和Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)。 作用:返回排序后的Stream； 代码:对整型集合排序 // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(11, 42, 23, 74, 5); // 默认自然序排序 List&lt;Integer&gt; collect = integers.stream().sorted().collect(Collectors.toList()); System.out.println(&quot;自然序排序后结果: &quot; + collect + &quot;&quot;); List&lt;Integer&gt; collect2 = integers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); System.out.println(&quot;逆序排序后结果: &quot; + collect2 + &quot;&quot;); 代码:对字符串集合排序 // 声明一个list List&lt;String&gt; strings = Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;GO&quot;, &quot;C&quot;, &quot;PYTHON&quot;,&quot;LUA&quot;,&quot;ABC&quot;); List&lt;String&gt; collect = strings.stream().sorted().collect(Collectors.toList()); System.out.println(&quot;自然序排序后结果 =&gt; &quot; + collect + &quot;&quot;); //自然序排序后结果 =&gt; [ABC, C, GO, JAVA, LUA, PHP, PYTHON] List&lt;String&gt; collect1 = strings.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); System.out.println(&quot;自然序逆排序后结果 =&gt; &quot; + collect1 + &quot;&quot;); //自然序逆排序后结果 =&gt; [PYTHON, PHP, LUA, JAVA, GO, C, ABC] List&lt;String&gt; collect2 = strings.stream().sorted((str1,str2)-&gt; str1.length()- str2.length()).collect(Collectors.toList()); System.out.println(&quot;根据长度正序排序 =&gt; &quot; + collect2 + &quot;&quot;); // 根据长度正序排序 =&gt; [C, GO, PHP, LUA, ABC, JAVA, PYTHON] List&lt;String&gt; collect3 = strings.stream().sorted((str1,str2)-&gt; str2.length()- str1.length()).collect(Collectors.toList()); System.out.println(&quot;根据长度逆序排序 =&gt; &quot; + collect3 + &quot;&quot;); //根据长度逆序排序 =&gt; [PYTHON, JAVA, PHP, LUA, ABC, GO, C] 由上面例子，可以看出对字符串集合排序时，会发现简单使用sorted会有问题！！ 8. map(): 递归处理签名: &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)。 作用:返回一个对当前所有元素执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型； 代码 // 声明一个list List&lt;String&gt; strings = Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;GO&quot;, &quot;C&quot;, &quot;PYTHON&quot;,&quot;LUA&quot;); List&lt;String&gt; collect = strings.stream().map(s -&gt; s.toLowerCase()).collect(Collectors.toList()); System.out.println(&quot;转小写 ==&gt; &quot; + collect + &quot;&quot;); // 转小写 ==&gt; [php, java, go, c, python, lua] // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; collect1 = integers.stream().map(integer -&gt; integer * 2).collect(Collectors.toList()); System.out.println(&quot;元素都乘以2 ==&gt; &quot; + collect1 + &quot;&quot;); // 元素都乘以2 ==&gt; [2, 4, 6, 8, 10] 7.2 结束操作方法1. allMatch(): 判断(都是)签名: boolean allMatch(Predicate&lt;? super T&gt; predicate) 作用:判断条件里的元素都满足，则返回true 代码 // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5); boolean a = integers.stream().allMatch(integer -&gt; integer &gt; 10); System.out.println(&quot;所有元素都大于10 ==&gt; &quot; + a + &quot;&quot;); // 所有元素都大于10 ==&gt; false boolean b = integers.stream().allMatch(integer -&gt; integer &lt; 10); System.out.println(&quot;所有元素都小于10 ==&gt; &quot; + b + &quot;&quot;); // 所有元素都小于10 ==&gt; true 2. anyMatch(): 判断(有一个是)签名: boolean anyMatch(Predicate&lt;? super T&gt; predicate) 作用:判断条件里的元素有一个满足，则返回true 代码 // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 11); boolean a = integers.stream().anyMatch(integer -&gt; integer &gt; 10); System.out.println(&quot;所有元素都大于10 ==&gt; &quot; + a + &quot;&quot;); // 所有元素都大于10 ==&gt; true boolean b = integers.stream().anyMatch(integer -&gt; integer &lt; 10); System.out.println(&quot;所有元素都小于10 ==&gt; &quot; + b + &quot;&quot;); // 所有元素都小于10 ==&gt; true 3. noneMatch(): 判断(都不是)签名: boolean noneMatch(Predicate&lt;? super T&gt; predicate) 作用:跟allMatch相反，判断条件里的元素都不满足，则返回true 代码 // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 11); boolean a = integers.stream().noneMatch(integer -&gt; integer &gt; 10); System.out.println(&quot;所有元素都大于10 ==&gt; &quot; + a + &quot;&quot;); // 所有元素都大于10 ==&gt; true boolean b = integers.stream().noneMatch(integer -&gt; integer &lt; 10); System.out.println(&quot;所有元素都小于10 ==&gt; &quot; + b + &quot;&quot;); // 所有元素都小于10 ==&gt; false 4. count(): 统计签名: long count() 作用:统计个数 代码 // 声明一个list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10); long count = integers.stream().count(); System.out.println(&quot;总个数 ==&gt; &quot; + count + &quot;&quot;); // 总个数 ==&gt; 12 long count1 = integers.stream().filter(integer -&gt; integer &gt; 5).count(); System.out.println(&quot;大于5的总个数 ==&gt; &quot; + count1 + &quot;&quot;); // 大于5的总个数 ==&gt; 7 long count2 = integers.stream().filter(integer -&gt; integer &gt; 5).distinct().count(); System.out.println(&quot;大于5的去重后的总个数 ==&gt; &quot; + count2 + &quot;&quot;); // 大于5的去重后的总个数 ==&gt; 5 5. max()、mix(): 最大和最小签名: Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator) Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) 作用:返回最大和最小 代码 // 声明一个整型list List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer max = integers.stream().max(Comparator.comparing(Integer::valueOf)).get(); System.out.println(&quot; 最大整数值 ==&gt; &quot; + max + &quot;&quot;); Integer min = integers.stream().min(Comparator.comparing(Integer::valueOf)).get(); System.out.println(&quot; 最小整数值 ==&gt; &quot; + min + &quot;&quot;); // 声明一个字符串list List&lt;String&gt; strings = Arrays.asList(&quot;B&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;,&quot;Z&quot;,&quot;A&quot;); String maxs = strings.stream().max(Comparator.comparing(String::valueOf)).get(); System.out.println(&quot; 最大字符串 ==&gt; &quot; + maxs + &quot;&quot;); String mins = strings.stream().min(Comparator.comparing(String::valueOf)).get(); System.out.println(&quot; 最小字符串 ==&gt; &quot; + mins + &quot;&quot;); /** 输出: 最大整数值 ==&gt; 10 最小整数值 ==&gt; 1 最大字符串 ==&gt; Z 最小字符串 ==&gt; A */ 获取最大和最小对象 public class Main { public static void main(String[] args) { List&lt;Employee&gt; emps = new ArrayList&lt;Employee&gt;(); emps.add(new Employee(&quot;小明&quot;, 16)); emps.add(new Employee(&quot;张三&quot;, 28)); emps.add(new Employee(&quot;李四&quot;, 32)); // 设置比较器，以年龄大小来比较 Comparator&lt;Employee&gt; comparator = Comparator.comparing(Employee::getAge); Employee minObject = emps.stream().min(comparator).get(); Employee maxObject = emps.stream().max(comparator).get(); System.out.println(&quot;最小对象 = &quot; + minObject); System.out.println(&quot;最大对象 = &quot; + maxObject); /** 输出: 最小对象 ==&gt; Name:- 小明 Age:- 16 最大对象 ==&gt; Name:- 李四 Age:- 32 */ } static class Employee { private String name; private int age; public Employee(String name, int age) { setName(name); setAge(age); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { StringBuilder str = null; str = new StringBuilder(); str.append(&quot; Name:- &quot; + getName() + &quot; Age:- &quot; + getAge()); return str.toString(); } } } 6. findAny() findFirst() 查找签名: Optional&lt;T&gt; findFirst() Optional&lt;T&gt; findAny() 作用: findFirst: 返回集合的第一个对象 findAny: 返回这个集合中，取到的任何一个对象 @注意: 1. 在串行的流中，findAny和findFirst返回的，都是第一个对象2. 在并行的流中，findAny返回的是最快处理完的那个线程的数据3. 在并行操作中，对数据没有顺序上的要求，那么findAny的效率会比findFirst要快的 代码 // 声明一个整型list List&lt;Integer&gt; integers = Arrays.asList(10, 32, 23, 14, 51, 64, 72, 81, 59, 110); Object[] objects = integers.stream().sorted().toArray(); Integer findFirst = integers.stream().filter(integer -&gt; integer &gt; 15).sorted().findFirst().get(); Integer findAny = integers.stream().filter(integer -&gt; integer &gt; 15).sorted().findAny().get(); System.out.println(&quot;排序后 =&gt; &quot; + Arrays.toString(objects) + &quot;&quot;); System.out.println(&quot;findFirst =&gt; &quot; + findFirst + &quot;&quot;); System.out.println(&quot;findAny =&gt; &quot; + findAny + &quot;&quot;); /** 输出: 排序后 =&gt; [10, 14, 23, 32, 51, 59, 64, 72, 81, 110] findFirst =&gt; 23 findAny =&gt; 23 */ 7. reduce() 生成一个符合的值签名: 三种重写形式: // 第一种 Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) // 第二种 T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) // 第三种 &lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner) 说明: reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用 代码 // 声明一个整型list List&lt;Integer&gt; integers = Arrays.asList(1,2,3,4,5); // 集合元素求和, Integer sum = integers.stream().reduce(Integer::sum).get(); System.out.println(&quot;求和 =&gt; &quot; + sum + &quot;&quot;); // 集合元素求和后，加上初始值 100 Integer sum1 = integers.stream().reduce(100, (total, item) -&gt; total + item); System.out.println(&quot;求和后再加100-A =&gt; &quot; + sum1 + &quot;&quot;); Integer sum2 = integers.stream().reduce(100,Integer::sum); System.out.println(&quot;求和后再加100-B =&gt; &quot; + sum2 + &quot;&quot;); // 最小值 Integer min = integers.stream().reduce(Integer::min).get(); System.out.println(&quot;最小值 =&gt; &quot; + min + &quot;&quot;); // 最大值 Integer max = integers.stream().reduce(Integer::max).get(); System.out.println(&quot;最大值 =&gt; &quot; + max + &quot;&quot;); // 集合中的元素乘积 Integer product = integers.stream().reduce((a, b) -&gt; a * b).get(); System.out.println(&quot;相乘结果: =&gt; &quot; + product + &quot;&quot;); // 找出最长的单词 Stream&lt;String&gt; stream = Stream.of(&quot;go&quot;, &quot;php&quot;, &quot;Java&quot;); String lengthStr = stream.reduce((s1, s2) -&gt; s1.length() &gt;= s2.length() ? s1 : s2).get(); System.out.println(&quot;最长的单词: =&gt; &quot; + lengthStr + &quot;&quot;); /** 输出: 求和 =&gt; 15 求和后再加100-A =&gt; 115 求和后再加100-B =&gt; 115 最小值 =&gt; 1 最大值 =&gt; 5 相乘结果: =&gt; 120 最长的单词: =&gt; Java */ 8. forEach() 遍历签名: void forEach(Consumer&lt;? super E&gt; action) 作用:是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历 代码 // 声明一个Map HashMap&lt;String,Integer&gt; gradeMap = new HashMap(4) {{ put("张三", 82); put("李四", 70); put("小明", 91); put("老王", 59); }}; // 遍历map gradeMap.entrySet().stream().forEach(item-&gt; { System.out.println(&quot;name = &quot; + item.getKey() + &quot;, fraction = [ &quot; + item.getValue() + &quot; ]&quot;); }); // 遍历集合 List&lt;String&gt; strings = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;小明&quot;, &quot;老王&quot;); strings.stream().forEach(s -&gt; System.out.println(&quot;name = [ &quot; + s + &quot; ]&quot;)); 9. forEachOrdered() 遍历签名: void forEachOrdered(Consumer&lt;? super T&gt; action) 作用:是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历 @注意: 1. 在串行的流中，forEach和forEachOrdered遍历输出的结果一样。2. 在并行的流中，forEach每次输出的结果不一致。3. 在并行的流中，forEachOrdered每次输出的结果一致。 代码 // 在串行流中: 遍历集合 List&lt;Integer&gt; strings = Arrays.asList(1, 2, 3, 4, 5); strings.stream().forEach(s -&gt; System.out.println(&quot;串行流-forEach =&gt; &quot; + s + &quot; &quot;)); strings.stream().forEachOrdered(s -&gt; System.out.println(&quot;串行流-forEachOrdered =&gt; &quot; + s + &quot; &quot;)); // 在并行流中: 遍历集合 strings.parallelStream().forEach(s -&gt; System.out.println(&quot;并行流-forEach =&gt; &quot; + s + &quot; &quot;)); strings.parallelStream().forEachOrdered(s -&gt; System.out.println(&quot;并行流-forEachOrdered =&gt; &quot; + s + &quot; &quot;)); /** 第一次遍历 输出: 串行流-forEach =&gt; 1 串行流-forEach =&gt; 2 串行流-forEach =&gt; 3 串行流-forEach =&gt; 4 串行流-forEach =&gt; 5 串行流-forEachOrdered =&gt; 1 串行流-forEachOrdered =&gt; 2 串行流-forEachOrdered =&gt; 3 串行流-forEachOrdered =&gt; 4 串行流-forEachOrdered =&gt; 5 并行流-forEach =&gt; 3 并行流-forEach =&gt; 5 并行流-forEach =&gt; 4 并行流-forEach =&gt; 2 并行流-forEach =&gt; 1 并行流-forEachOrdered =&gt; 1 并行流-forEachOrdered =&gt; 2 并行流-forEachOrdered =&gt; 3 并行流-forEachOrdered =&gt; 4 并行流-forEachOrdered =&gt; 5 第二次遍历 输出: 串行流-forEach =&gt; 1 串行流-forEach =&gt; 2 串行流-forEach =&gt; 3 串行流-forEach =&gt; 4 串行流-forEach =&gt; 5 串行流-forEachOrdered =&gt; 1 串行流-forEachOrdered =&gt; 2 串行流-forEachOrdered =&gt; 3 串行流-forEachOrdered =&gt; 4 串行流-forEachOrdered =&gt; 5 并行流-forEach =&gt; 2 并行流-forEach =&gt; 1 并行流-forEach =&gt; 3 并行流-forEach =&gt; 4 并行流-forEach =&gt; 5 并行流-forEachOrdered =&gt; 1 并行流-forEachOrdered =&gt; 2 并行流-forEachOrdered =&gt; 3 并行流-forEachOrdered =&gt; 4 并行流-forEachOrdered =&gt; 5 */ Java8 parallelStream浅析-知乎 10. toArray() 转成数组签名: &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 作用: 将流转成数组 代码 List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3,4,5,6,7,8,9); Integer[] integers = integerList.stream().filter(integer -&gt; integer % 3 == 0).toArray(Integer[]::new); System.out.println(&quot;整型集合过滤后的结果，toArray -&gt; &quot; + Arrays.toString(integers) + &quot;&quot;); // 整型集合过滤后的结果，toArray -&gt; [3, 6, 9] List&lt;String&gt; stringsList = Arrays.asList(&quot;PHP&quot;, &quot;GO&quot;, &quot;JAVA&quot;, &quot;PYTHON&quot;, &quot;LUA&quot;); String[] strings = stringsList.stream().filter(s -&gt; s.length() &gt; 3).toArray(String[]::new); System.out.println(&quot;字符串集合过滤后的结果，toArray -&gt; &quot; + Arrays.toString(strings) + &quot;&quot;); // 字符串集合过滤后的结果，toArray -&gt; [JAVA, PYTHON] 11. collect()由于collect过于特殊和强大，拉出去单讲【collect() 和 Collectors(收集器) 】。 Java-基础篇-Collect方法详解]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-Lambda操作Map]]></title>
    <url>%2F2019%2F12%2F14%2Fjava-14-Lambda%E6%93%8D%E4%BD%9CMap%2F</url>
    <content type="text"><![CDATA[1. Java8新加入的lambda方法 接口类型 新加入的方法 Map forEach()、replaceAll()、merge()、compute()、computeIfAbsent()、computeIfPresent() 由于继承关系，他们相应的子类也都会继承这些新方法。 2. forEach()该方法签名为void forEach(BiConsumer&lt;? super K,? super V&gt; action)，作用是对Map中的每个映射执行action指定的操作，其中BiConsumer是一个函数接口，里面有一个待实现方法void accept(T t, U u)。BinConsumer接口名字和accept()方法名字都不重要。 2.1 示例:遍历输出Map需求:假设有一个成绩单Map，遍历输出Map中的所有映射关系． 2.2 Java8以前的代码HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;张三&quot;, 62); map.put(&quot;李四&quot;, 66); map.put(&quot;王麻子&quot;, 89); for(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()){ System.out.println(entry.getKey() + &quot; =&gt; &quot; + entry.getValue()); } /** 输出: 李四 =&gt; 66 张三 =&gt; 62 王麻子 =&gt; 89 */ 2.3 匿名内部类代码HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;张三&quot;, 62); map.put(&quot;李四&quot;, 66); map.put(&quot;王麻子&quot;, 89); map.forEach(new BiConsumer&lt;String, Integer&gt;() { @Override public void accept(String s, Integer integer) { System.out.println(s + &quot; =&gt; &quot; + integer); } }); /** 输出: 李四 =&gt; 66 张三 =&gt; 62 王麻子 =&gt; 89 */ 2.4 使用lambdaHashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;张三&quot;, 62); map.put(&quot;李四&quot;, 66); map.put(&quot;王麻子&quot;, 89); map.forEach((k,v)-&gt; { System.out.println(k + &quot; =&gt; &quot; + v); }); /** 输出: 李四 =&gt; 66 张三 =&gt; 62 王麻子 =&gt; 89 */ 3.replaceAll()该方法签名为replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)，作用是对Map中的每个映射执行function指定的操作，并用function的执行结果替换原来的value，其中BiFunction是一个函数接口，里面有一个待实现方法R apply(T t, U u) 3.1 示例:将单词都转换成大写需求:有一个数字到对应英文单词的Map，将单词都转换成大写． 3.2 Java8以前的代码HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;c&quot;); map.put(2, &quot;go&quot;); map.put(3, &quot;java&quot;); map.put(4, &quot;php&quot;); for (Map.Entry&lt;Integer,String&gt; entry : map.entrySet()){ entry.setValue(entry.getValue().toUpperCase()); } System.out.println(map); //输出:{1=C, 2=GO, 3=JAVA, 4=PHP} 3.3 匿名内部类代码HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;c&quot;); map.put(2, &quot;go&quot;); map.put(3, &quot;java&quot;); map.put(4, &quot;php&quot;); map.replaceAll(new BiFunction&lt;Integer, String, String&gt;() { @Override public String apply(Integer integer, String s) { return s.toUpperCase(); } }); System.out.println(map); // 输出:{1=C, 2=GO, 3=JAVA, 4=PHP} 3.4 使用lambdaHashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;c&quot;); map.put(2, &quot;go&quot;); map.put(3, &quot;java&quot;); map.put(4, &quot;php&quot;); map.replaceAll((k,v)-&gt;v.toUpperCase()); System.out.println(map); // 输出:{1=C, 2=GO, 3=JAVA, 4=PHP} 4. merge()该方法签名为merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)。作用是:它将新的值赋值到 key （如果不存在）或更新给定的key 值对应的 value。即key存在则更新，不存在则赋值。 4.1 错误信息拼接一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如： HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;(1); stringStringHashMap.put(&quot;error&quot;, &quot;执行错误,&quot;); System.out.println(stringStringHashMap); // {error=执行错误} // 使用merge stringStringHashMap.merge(&quot;error&quot;, &quot;其他错误信息.....&quot;, (v1, v2) -&gt; v1 + v2); System.out.println(stringStringHashMap); // {error=执行错误,其他错误信息.....} 4.2 其他示例 Java 8 中 Map 骚操作之 merge() 的用法 5.compute()该方法签名为compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用是把remappingFunction的计算结果关联到key上，如果计算结果为null，则在Map中删除key的映射． 5.1 统计一个List 中每个元素出现的次数List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 compute 计算元素出现的次数:&quot;); Map&lt;String, Integer&gt; countsMap = new HashMap&lt;&gt;(6); // 此时：新值 = 旧值 + 1 list.forEach(str -&gt; countsMap.compute(str, (k, v) -&gt; v == null ? 1 : v + 1)); System.out.println(countsMap); /** 使用 compute 计算元素出现的次数: {a=1, b=2, c=3, d=3, f=2, g=1} */ 6.computeIfAbsent()该方法签名为V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)， 作用:只有在当前Map中不存在key值的映射或映射值为null时，才调用mappingFunction，并在mappingFunction执行结果非null时，将结果跟key关联． 6.1 示例:条件判断和添加操作合二为一computeIfAbsent()常用来对Map的某个key值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是Map&lt;K,Set&gt;，要向Map中放入新值，可通过如下代码实现 6.2 Java8以前的代码Map&lt;Integer, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(map.containsKey(1)){ map.get(1).add(&quot;PHP&quot;); }else{ Set&lt;String&gt; valueSet = new HashSet&lt;String&gt;(); valueSet.add(&quot;PHP&quot;); map.put(1, valueSet); } 6.3 使用lambdaMap&lt;Integer, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); map.computeIfAbsent(1, v -&gt; new HashSet&lt;String&gt;()).add(&quot;Java&quot;); 7.computeIfPresent()该方法签名为V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用跟computeIfAbsent()相反，即，只有在当前Map中存在key值的映射且非null时，才调用remappingFunction，如果remappingFunction执行结果为null，则删除key的映射，否则使用该结果替换key原来的映射． 7.1 使用示例HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;1&quot;, 1); map.put(&quot;2&quot;, 2); map.put(&quot;3&quot;, 3); map.put(&quot;4&quot;, 3); //只对map中存在的key对应的value进行操作 Integer integer = map.computeIfPresent(&quot;3&quot;, (k, v) -&gt; v + 1); System.out.printf(&quot;修改key=3得值为: %d\n&quot;, integer); System.out.printf(&quot;修改后的map为: %s\n&quot;, map.toString()); // 触发remappingFunction，并返回执行结果为null，从而删除key=4 map.computeIfPresent(&quot;4&quot;, (k, v) -&gt; { System.out.println(&quot;调用remappingFunction = [k=&quot; + k + &quot;; v=&quot; + v + &quot;]&quot;); return null; }); System.out.printf(&quot;触发remappingFunction后的，map为: %s\n&quot;, map.toString()); /** 输出: 修改key=3得值为: 4 修改后的map为: {1=1, 2=2, 3=4, 4=3} 调用remappingFunction = [k=4; v=3] 触发remappingFunction后的，map为: {1=1, 2=2, 3=4} */]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-Lambda操作集合]]></title>
    <url>%2F2019%2F12%2F13%2Fjava-13-Lambda%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1. Lambda操作Collections为引入Lambda表达式，Java8新增了java.util.funcion包，里面包含常用的函数接口，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。由于继承关系，他们相应的子类也都会继承这些新方法 框架的接口继承结构 1.1 Java8新加入的方法 接口类型 新加入的方法 Collection removeIf() forEach() spliterator() stream() parallelStream() List replaceAll() sort() Map getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge() 由于继承关系，他们相应的子类也都会继承这些新方法。 2. 在Collection中使用Lambda2.1 removeIf()该方法签名为boolean removeIf(Predicate&lt;? super E&gt; filter),作用是删除容器中所有满足filter指定条件的元素。 使用示例:删除集合中小于100的元素 java8以前的代码 ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(Arrays.asList(20, 420, 170, 100, 140)); Iterator&lt;Integer&gt; iterator = integers.iterator(); while (iterator.hasNext()){ if (iterator.next() &lt; 100){ iterator.remove(); } } System.out.println(integers); /** * 输出:[420, 170, 100, 140] */ 匿名内部类过度代码 ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(Arrays.asList(20, 420, 170, 100, 140)); integers.removeIf(new Predicate&lt;Integer&gt;(){ @Override public boolean test(Integer number){ return number &lt; 100; } }); Lambda代码 ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(Arrays.asList(20, 420, 170, 100, 140)); integers.removeIf(number -&gt; number &lt; 100); 改写依据removeIf要传入一个Predicate函数接口的实现类，Predicate是一个函数接口，里面只有一个待实现方法boolean test(T t)。根据Lambda的改写依据，可以省略函数接口实现类的类名和方法名，有参时，直接使用: 参数-&gt;{…},由于是单行代码块，{} 也可以省略 2.2 forEach()签名为void forEach(Consumer&lt;? super E&gt; action)，作用是对容器中的每个元素执行action指定的动作，其中Consumer是个函数接口。 使用示例:假设有一个字符串列表，需要打印出其中所有长度小于3的字符串. java8以前的代码 // 使用曾强for循环迭代 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;,&quot;JAVA&quot;,&quot;PYTHON&quot;,&quot;GO&quot;)); for(String str : list){ if(str.length() &lt; 3){ System.out.println(str); } } //输出:GO 匿名内部类过度代码 // 使用forEach()结合匿名内部类迭代 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;,&quot;JAVA&quot;,&quot;PYTHON&quot;,&quot;GO&quot;)); list.forEach(new Consumer&lt;String&gt;(){ @Override public void accept(String str){ if(str.length() &lt; 3) System.out.println(str); } }); Lambda代码 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;PYTHON&quot;, &quot;GO&quot;)); arrayList.forEach(str -&gt;{ if (str.length() &lt; 3){ System.out.println(str); } }); //输出:GO 2.3 replaceAll()该方法签名为void replaceAll(UnaryOperator operator)，作用是对每个元素执行operator指定的操作，并用操作结果来替换原来的元素。其中UnaryOperator是一个函数接口，里面只有一个待实现函数T apply(T t)。 使用示例:假设有一个字符串列表，将其中所有长度小于3的字符串 转为大写. java8以前的代码 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;PYTHON&quot;, &quot;GO&quot;)); for (int i = 0; i &lt; list.size(); i++) { String str = list.get(i); if (str.length() &lt; 3) { list.set(i, str.toLowerCase()); } } System.out.println(list); //输出: [PHP, JAVA, PYTHON, go] 匿名内部类过度代码 // 使用forEach()结合匿名内部类迭代 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;,&quot;JAVA&quot;,&quot;PYTHON&quot;,&quot;GO&quot;)); list.replaceAll(new UnaryOperator&lt;String&gt;(){ @Override public String apply(String str){ if(str.length() &lt; 3){ return str.toLowerCase(); } return str; } }); System.out.println(list); //输出: [PHP, JAVA, PYTHON, go] Lambda代码 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;PYTHON&quot;, &quot;GO&quot;)); list.replaceAll(str -&gt; { if (str.length() &lt; 3 ) { return str.toLowerCase(); } return str; }); System.out.println(list); //输出: [PHP, JAVA, PYTHON, go] 2.4 sort()该方法定义在List接口中，方法签名为void sort(Comparator&lt;? super E&gt; c)，该方法根据c指定的比较规则对容器元素进行排序。Comparator接口我们并不陌生，其中有一个方法int compare(T o1, T o2)需要实现，显然该接口是个函数接口。 使用示例:假设有一个字符串列表，按照字符串长度对元素降序排序。 java8以前的代码 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;PYTHON&quot;, &quot;GO&quot;)); Collections.sort(list, new Comparator&lt;String&gt;(){ @Override public int compare(String str1, String str2){ return str2.length()-str1.length(); } }); System.out.println(list); //输出: [PYTHON, JAVA, PHP, GO] Lambda代码 list.sort((str1,str2)-&gt;str2.length() - str1.length()); //输出: [PHP, JAVA, PYTHON, go] 2.5 spliterator()方法签名为Spliterator spliterator()，该方法返回容器的可拆分迭代器。从名字来看该方法跟iterator()方法有点像，我们知道Iterator是用来迭代容器的，Spliterator也有类似作用，但二者有如下不同： Spliterator既可以像Iterator那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。 Spliterator是可拆分的，一个Spliterator可以通过调用Spliterator trySplit()方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。 可通过（多次）调用Spliterator.trySplit()方法来分解负载，以便多线程处理。 2.6 stream()和parallelStream()stream()和parallelStream()分别返回该容器的Stream视图表示，不同之处在于parallelStream()返回并行的Stream。Stream是Java函数式编程的核心类，我们会在后面章节中学习。 以上内容摘自关于Java Lambda表达式看这一篇就够了]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-初识Lambda]]></title>
    <url>%2F2019%2F12%2F11%2Fjava-12-%E5%88%9D%E8%AF%86Lambda%2F</url>
    <content type="text"><![CDATA[1. 介绍Lambda表达式是Java8的新特性，一个最为重要用法是简化某些匿名内部类的写法。在加上结合新增的的流相关的 API使用，让我这个java小白觉得相当牛x，至于多牛x，上代码体验。一起学习吧.. 2. Lambda表达式使用2.1 无参函数的简写需求: 新建一个线程 Java8以前的代码 new Thread(new Runnable(){ // 接口名 @Override public void run(){ // 方法名 System.out.println(&quot;Thread1 run()&quot;); } } ).start(); 采用Lambda简写 // 单行代码 new Thread( () -&gt; System.out.println(&quot;Thread1 run()&quot;) ).start(); // 多行代码块时的写法 new Thread( () -&gt; { System.out.println(&quot;Hello Thread1 &quot;)； System.out.println(&quot;Thread1 run()&quot;) } ).start(); 对比: 省略接口名函数名 不用再定义接口Runnable的匿名对象 2.2 有参函数的简写需求: 给一个字符串列表通过自定义比较器，按照字符串长度进行排序 Java8以前的代码 List&lt;String&gt; list = Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;GO&quot;, &quot;PYTHON&quot;); // 定义一个实现Comparator接口的，匿名类 Collections.sort(list, new Comparator&lt;String&gt;(){ // 重载接口中的方法 @Override public int compare(String s1, String s2){ if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); } }); 采用Lambda简写 // JDK8 Lambda表达式写法 List&lt;String&gt; list = Arrays.asList(&quot;PHP&quot;, &quot;JAVA&quot;, &quot;GO&quot;, &quot;PYTHON&quot;); // 省略Comparator接口实现类、compare方法、参数的类型 Collections.sort(list, (s1, s2) -&gt;{ if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); }); 2.3 更多合法的书写形式// Lambda表达式的书写形式 Runnable run = () -&gt; System.out.println(&quot;Hello World&quot;);// 1 ActionListener listener = event -&gt; System.out.println(&quot;button clicked&quot;);// 2 Runnable multiLine = () -&gt; {// 3 代码块 System.out.print(&quot;Hello&quot;); System.out.println(&quot; Hoolee&quot;); }; BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;// 4 BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;// 5 类型推断 1处展示了无参函数的简写 2处展示了有参函数的简写，以及类型推断机制 3处是代码块的写法 4处和5处再次展示了类型推断机制 3.简写依据3.1 依据一:函数接口 能够使用Lambda的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。这意味着你并不能在代码的任何地方任性的写Lambda表达式 3.2 依据二:类型推断机制Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-了解多线程]]></title>
    <url>%2F2019%2F11%2F27%2Fjava-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 多线程介绍多线程执行是Java平台的一个本质特性。每一个应用程序有至少一个线程（或者如果计算系统线程的话，如内存管理和信号处理，则是多个）。但是从应用程序程序员的角度，启动的只有一个线程，称为主线程（main thread）。这个线程有能力创建另外的线程。 什么是进程、线程、协程 2. 体验多线程2.1 单线程代码代码示例: public class ThreadDemo { public static void main(String args[]){ new TestThread().run(); //循环输出 for (int i=0;i&lt;5;++i){ System.out.println(&quot;main线程在运行&quot;); } } } class TestThread { public void run(){ for (int i=0;i&lt;5;++i){ System.out.println(&quot;TestThread在运行&quot;); } } } /**输出: TestThread在运行 TestThread在运行 TestThread在运行 TestThread在运行 TestThread在运行 main线程在运行 main线程在运行 main线程在运行 main线程在运行 main线程在运行 */ 代码分析: 从上述代码中可以看出,如果要想运行main方法中的for循环,则必须要等TestThread类中的run()方法执行完后才可以运行，虽然mainain方法中for循环不依赖前面的代码块的计算结果，但是它也必须等待。这便是单一线程的缺陷。 2.2 多线程代码通过继承Thread类实现多线程,Thread类存放于java.lang类库里。在Thread类中定义了run()方法，要想实现多线程，必须覆写Thread类的run方法。 代码示例: public class ThreadDemo { public static void main(String[] args) { //激活一个线程 new TestThread().start(); //循环输出 for (int i = 0; i &lt; 5; ++i) { System.out.println(&quot;main线程在运行&quot;); try { //为了看出并发执行，睡眠1秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } class TestThread extends Thread { public void run() { for (int i = 0; i &lt; 5; ++i) { System.out.println(&quot;TestThread在运行&quot;); try { //为了看出并发执行，睡眠1秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } /**输出: TestThread在运行 main线程在运行 TestThread在运行 main线程在运行 TestThread在运行 main线程在运行 TestThread在运行 main线程在运行 TestThread在运行 main线程在运行 */ 3. 使用多线程在java中，启动一个新线程有两种途径: 提供一个Runnable接口的对象 使用Thread的子类 3.1 通过Runnable接口实现使用格式:Runnable接口定义了一个单一的方法run()，在run()方法中包含要在线程中执行的代码。Runnable对象被传递给Thread的构造器中，如下面的代码所示。 public class RunnableDemo implements Runnable { public void run() { // todo 线程执行方法体... } public static void main(String[] args) { // 启动多线程 (new Thread(new RunnableDemo())).start(); } } 代码示例: // TestThread类实现了Runnable接口， // 同时覆写了Runnable接口之中的run()方法，也就是说此类为一个多线程实现类 class TestThread implements Runnable { public void run() { for (int i = 0; i &lt; 5; i++) { System.out.println(&quot;TestThread在运行&quot;); try { Thread.sleep(1000); //睡眠1秒 } catch (InterruptedException e) { e.printStackTrace(); } } } } // 测试多线程 public class RunnableThread { public static void main(String[] args) { // 实例化了一个TestThread类的对象 TestThread t = new TestThread(); //使用Thread类的start方法启动线程 new Thread(t).start(); for (int i = 0; i &lt; 5; i++) { System.out.println(&quot;main线程在运行&quot;); try { Thread.sleep(1000); //睡眠1秒 } catch (InterruptedException e) { e.printStackTrace(); } } } } 问题1: Runnable对象,为什么要调用Thread类中的start方法？为什么实现了Runnable接口还需要调用Thread类中的start方法才能启动多线程？查找JDK文档就可以发现，在Runnable接口中只有一个run方法，并没有start方法。 所以一个类即使实现了Runnable接口，也需用Thread类中的start方法来启动多线程。对这一点，通过查找JDK文档中的Thread类可以看到，在Thread类之中有这样一个构造方法。 public Thread( Runnable target ) 由此构造方法可以看到，可以将一个Runnable接口（或其子类）的实例化对象作为参数去实例化Thread类对象。 3.2 通过Thread的子类实现使用格式: public class ThreadDemo extends Thread { //重写从Thread继承过来的run方法 public void run() { // todo 线程执行方法体.. } public static void main(String[] args) { // 启动多线程 (new Thread(new ThreadDemo())).start(); } } 代码示例见:多线程代码 Runnable接口和Thread类的关系:Thread类是Runnable接口的一个子类 4. 深入案例-卖火车票下面是模拟一个铁路售票系统的范例，某日列车的车票剩余5张 ，通过4个售票点来售卖，一个售票点用一个线程来表示 4.1 Thread子类实现Thread子类实现-代码示例: public class ThreadDemo { public static void main(String[] args) { TestThread t = new TestThread(); //一个线程对象只能启动一次 t.start(); t.start(); t.start(); t.start(); } } public class TestThread extends Thread { private int tickets = 5; public void run() { while (tickets &gt; 0) { // 获取当前运行线程的名称 Sting ThreadName = Thread.currentThread().getName(); System.out.println(ThreadName + &quot;出售票&quot; + tickets); tickets -= 1; } } } /*** * 输出: Thread-0出售票5 Thread-0出售票4 Thread-0出售票3 Thread-0出售票2 Thread-0出售票1 Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:708) at Main.main(Main.java:15) */ @注意: 一个类继承Thread类之后，这个类的实例化对象，无论调用多少次start方法，结果都只有一个线程在运行 Thread子类实现-代码修改: public class TestThreadDemo { public static void main(String[] args) { TestThread t = new TestThread(); //启动4个线程 new TreadDemo().start(); new TreadDemo().start(); new TreadDemo().start(); new TreadDemo().start(); } } public class TestThread extends Thread { // 一共剩余5张票 private int tickets = 5; public void run() { while (tickets &gt; 0) { // 获取当前运行线程的名称 Sting ThreadName = Thread.currentThread().getName(); System.out.println(ThreadName + &quot;出售票&quot; + tickets); tickets -= 1; } } } /*** *输出: Thread-0出售票5 Thread-1出售票5 Thread-0出售票4 Thread-1出售票4 Thread-1出售票3 Thread-1出售票2 Thread-1出售票1 Thread-2出售票5 Thread-0出售票3 Thread-2出售票4 Thread-2出售票3 Thread-2出售票2 Thread-2出售票1 Thread-0出售票2 Thread-0出售票1 Thread-3出售票5 Thread-3出售票4 Thread-3出售票3 Thread-3出售票2 Thread-3出售票1 */ 问题1:剩余票一共5张，却卖出了4*5 = 20张 我们的本意是一共有5张票，每个线程模拟一个售票窗口，一起把这5张票卖完，但从运行的结果可以看出，每个线程都卖了5张票，这样就卖出了4×5=20张票，这不是我们所需要的。因此，用Thread实际上很难达到资源共享的目的，但是可以通过静态变量达到资源共享，例如，可将tickets设置为static类型的。 修改方法:改成静态变量 // 一共剩余5张票 private static int tickets = 5; 即便改成静态变量也会出现一票多卖的情况,原因下稍后说明。 4.2 Runnabe接口实现Runnabe接口实现(共享资源)-代码示例: public class RunnableDemo implements Runnable { /** * description: 剩余总票数 */ private static int tickets = 5; @Override public void run() { while (tickets &gt; 0) { // 获取当前运行线程的名称 String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;出售票&quot; + tickets); tickets -= 1; } } } public class TestThreadDemo { public static void main(String[] args) { RunnableDemo r = new RunnableDemo(); //启动4个线程 new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); new Thread(r).start(); } } /*** *输出: Thread-0出售票5 Thread-3出售票5 Thread-2出售票5 Thread-1出售票4 Thread-0出售票3 Thread-1出售票2 Thread-1出售票0 */ 实现Runnable接口相对于继承Thread类来说，有如下几个显著的优势。1. 避免由于Java的单继承特性带来的局限。2. 可以使多个线程共享相同的资源，以达到资源共享的目的。 4.3 一票多卖不管是Thread子类实现，还是Runnabe接口实现的程序，多运行几次本程序，就会发现一票多卖的情况。比如在上面的运行结果中,第5张票就被线程0、线程2和线程3卖了3次，出现“一票多卖”的现象。 这是因为:当tickets=1时，线程0、线程2和线程3都同时看见了，满足条件tickets &gt; 0，当第一个线程就把票卖出去了，tickets理应减1，当它还没有来得及更新，当前的线程的运行时间片就到了，必须推出CPU，让其他线程执行，而其他线程看到的tickets依然是旧状态（tickets=1），所以，依次也把那张已经卖出去的票再次“卖”出去了。 事实上，在多线程运行环境中，tickets属于典型的临界资源（Critical resource），而run方法体就属于临界区（Critical Section）。多个进程中涉及到同一个临界资源的临界区称为相关临界区。 5. 线程状态每个Java程序都有一个默认的主线程，对于Java应用程序，主线程是main方法执行的线程；要想实现多线程，必须在主线程中创建新的线程对象。而一个线程具有5种状态，即创建、就绪、运行、阻塞、终止。 线程状态的转移与转移原因之间的关系如下图所示: 在给定时间点上，一个线程只能处于一种状态（详见JDK文档 Thread.State） New(创建态): 至今尚未启动的线程处于这种状态。 Runnable(运行态):正在Java虚拟机中执行的线程处于这种状态。 Blocked(阻塞态):受阻塞并等待某个监视器锁的线程处于这种状态。 Waiting(无限等待态):无限期的等待另一个线程来执行某一个特定操作的线程处于这种状态。 Timed_Waiting(限时等待态):具有指定等待时间的某一等待线程的线程状态。 Terminated(死亡态):已退出的线程处于这种状态。 5.1 代码演示线程生命周期package com.training.thread; import java.util.Scanner; /** * description :演示线程生命周期 * @author : Mr.Liuqh * @date : 2019-11-27 13:12 */ public class ThreadLife implements Runnable { @Override public void run() { System.out.println(&quot;处于运行状态!&quot;); Scanner scanner = new Scanner(System.in); System.out.println(&quot;等待I/O,处于阻塞状态!&quot;); System.out.println(&quot;请输入字符串：&quot;); //next()方法扫描scanner输入的字符串 scanner.next(); //扫描器结束，系统不再等待I/O，线程重新进入就绪状态 scanner.close(); System.out.println(&quot;结束阻塞状态,重新进入就绪状态,然后运行状态!&quot;); try { //线程暂停1000毫秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;线程进入死亡状态!&quot;); } public static void main(String[] args) { Thread thread = new Thread(new ThreadLife()); System.out.println(&quot;处于创建状态!&quot;); thread.start(); System.out.println(&quot;处于就绪状态!&quot;); } } 输出: 处于创建状态! 处于就绪状态! 处于运行状态! 等待I/O,处于阻塞状态! 请输入字符串： hello 结束阻塞状态,重新进入就绪状态,然后运行状态! 线程进入死亡状态! 6. 操作线程的方法操作线程的主要方法在Thread类中，下表列出了Thread类中的主要方法，查阅SDK文档获得更多线程方法。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-异常处理]]></title>
    <url>%2F2019%2F11%2F11%2Fjava-10-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 异常概述Java的异常处理机制也秉承着面向对象的基本思想。在Java中，所有的异常都是以类的类型存在。除了内置的异常类之外，Java也可以自定义异常类。此外，Java的异常处理机制也允许自定义抛出异常。 2. 处理错误特点 不需要打乱程序的结构，如果没有任何错误产生，那么程序的运行不受任何影响。 不依靠方法的返回值来报告错误是否产生。 采用集中的方式处理错误，能够根据错误种类的不同来进行对应的错误处理操作。 3. 常见的异常 4. 抛出异常4.1 thorws关键字在方法中使用thorws关键字抛出错误 语法 [权限修饰符] 返回类型 方法名 throws 具体错误类{ .... } 示例 public class Main { public static void main(String[] args) { System.out.println(divsion(10,0)); } /** * description: 测试除法异常 **/ public static int divsion(int a, int b ) throws ArithmeticException{ return a / b ; } } /** * 输出: Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at Main.divsion(Main.java:27) at Main.main(Main.java:17) **/ 4.2 thorw关键字使用示例 public class Main { public static void main(String[] args) { System.out.println(divsion(10,0)); } /** * description: 测试除法异常 **/ public static int divsion(int a, int b ) throws ArithmeticException{ if (b == 0){ throw new ArithmeticException(&quot;除数不能为0！&quot;); } return a / b ; } } /** * 输出: Exception in thread &quot;main&quot; java.lang.ArithmeticException: 除数不能为0！ at Main.divsion(Main.java:47) at Main.main(Main.java:39) **/ 5. 捕捉异常异常捕获处理是由try、catch与finally等3个关键字所组成的程序块，其语法如下所示 5.1 try-catchtry { // todo ... } catch (ArithmeticException e) { // 捕获到对应的异常 } 5.2 try-catch-catchtry { // todo ... } catch (ArithmeticException e) { // 捕获到对应的异常 } catch (ArithmeticException e) { // 捕获到对应的异常 } 5.3 try-finallytry { // todo ... } finally (ArithmeticException e) { // 总会处理的逻辑 } 5.4 try-catch-finallytry { // todo ... } catch (ArithmeticException e) { // 捕获到对应的异常 } finally (ArithmeticException e) { // 总会处理的逻辑 } 6. 异常类关系图 6.1 异常类型的继承关系异常类型的最大父类是Throwable类，其分为两个子类，分别为Exception、Error。Exception表示程序可处理的异常，而Error表示JVM错误，一般无需程序开发人员自己处理。 6.2 RuntimeException和Exception的区别 RuntimeException类是Exception类的子类。 Exception定义的类，强制性要求用户必须处理 RuntimeException定义的异常可以选择性地进行处理。 7.自定义异常类自定义类的语法: class 异常类名 extends Exception { .... } 使用示例: public class userDefinedException { public static void main(String[]args) { try { throw new MyException(&quot;自定义异常--仅为测试演示！&quot;); } catch(MyException e){ System.out.println(e); } } } class MyException extends Exception { public MyException(String msg) { super(msg); //调用Exception类的构造方法，存入异常信息 } }]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-抽象类和接口]]></title>
    <url>%2F2019%2F11%2F05%2Fjava-9-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1.抽象类1.1 抽象类概念抽象方法是只声明而未实现的方法，所有的抽象方法必须使用abstract关键字声明，包含抽象方法的类也必须使用abstract class声明。 1.1.1 抽象类定义规则 抽象类和抽象方法都必须用abstract关键字来修饰； 抽象类不能直接实例化，即不能使用new关键字去产生对象； 抽象类定义时抽象方法只需声明，而不需实现； 含有抽象方法的类必须被声明为抽象类，抽象类的子类必须覆写所有的抽象方法后才能被实例化，否则这个子类还是个抽象类。 1.2 抽象类声明访问权限 abstract class 类名 { // 声明成员变量 访问权限 变量类型 成员变量名; // 声明一般方法 访问权限 返回类型 方法名(){ // ... } // 声明抽象方法 abstract 返回类型 方法名(); } 实例 /** * description: * * @author : Mr.Liuqh * @since : 2019-10-31 18:51 */ public abstract class People { // 声明成员变量 private String name; // 声明一般方法 public String getName(){ return this.name; } // 声明抽象方法 abstract String like(); } 由上可知:抽象类的定义就是比普通类多了一些抽象方法的定义而已。虽然定义了抽象类，但是抽象类却不能直接使用。 People girl = new People(); // 这种调用会报错,People 是抽象的，无法实例化 1.2.1 抽象类的使用原则如果说一个类的对象可以被实例化，那么就表示这个对象可以调用类中的属性或者是方法，但是抽象类中存在抽象方法，而抽象方法没有方法体，没有方法体的方法无法使用。 对于抽象类的使用原则如下: 抽象类必须有子类，子类使用extends继承抽象类，一个子类只能够继承一个抽象类； 子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法； 若想实例化抽象类的对象，则可以使用子类进行对象的向上转型来完成。 1.3 抽象类特征1.3.1 抽象类中可以有构造方法与一般类相同，在抽象类中也可以拥有构造方法，但是这些构造方法必须在子类中被调用，并且子类实例化对象的时候依然满足类继承的关系，先默认调用父类的构造方法，而后再调用子类的构造方法，毕竟抽象类之中还是存在属性的，只不过这个抽象方法无法直接被外部实例化对象的时候所使用。 代码示例: //定义一抽象类Person abstract class Person { String name; int age; String occupation; public Person(String name,int age,String occupation) //定义构造函数 { this.name=name; this.age=age; this.occupation=occupation; } public abstract String talk(); //声明一个抽象方法 } //声明抽象类的子类 class Student extends Person { public Student(String name,int age,String occupation){ //在这里必须明确调用抽象类中的构造方法 super(name,age,occupation); } //覆写talk()方法 public String talk() { return &quot;学生——&gt;姓名：&quot;+this.name+&quot;，年龄：&quot;+this.age+&quot;，职业：&quot;+this.occupation+&quot;！&quot;; } } // 测试 class AbstractConstructor { public static void main(String[] args){ //创建对象s Student s=new Student(&quot;张三&quot;,18,&quot;学生&quot;); //调用被覆写过的方法 System.out.println(s.talk()); // 输出:学生——&gt;姓名：张三，年龄：18，职业：学生！ } } 从程序中可以看到，抽象类也可以像普通类一样，有构造方法、一般方法和属性，更重要的是还可以有一些抽象方法，需要子类去实现，而且在抽象类中声明构造方法后，在子类中必须明确调用。 1.3.2 抽象类不能够使用final定义。使用final定义的类不能有子类，而抽象类使用的时候必须有子类，这是一个矛盾的问题，所以抽象类上不能出现final定义。 1.3.3 在外部抽象类上无法使用static声明在外部抽象类上无法使用static声明，但是内部抽象类却可以使用static定义，使用static定义的内部抽象类就表示一个外部类。 代码 abstract class Book{ //抽象方法 public abstract void print(); //静态内部抽象类 static abstract class CD{ //抽象方法 public abstract void get(); } } //继承抽象类 class JavaCD extends Book.CD { public void get(){ System.out.println(&quot;java学习&quot;); } } public class StaticInnerAbstractClass{ public static void main(String[] args){ //实例化对象 Book.CD cd=new JavaCD(); cd.get(); // 输出:java学习 } } 2. 接口接口（interface）是Java所提供的另一种重要技术，是一种特殊的类，它的结构和抽象类非常相似，也具有数据成员与抽象方法，但它与抽象类又有不同，并且Java 8中又添加了新特性。 2.1 接口的基本概念 接口里的数据成员必须初始化，且数据成员均为常量，常见的是全局变量。 接口里的方法为abstract，接口不能像抽象类一样定义一般的方法，需定义“抽象方法”。 Java8中为避免在接口中添加新方法后要修改所有实现类，允许定义默认方法，即default方法，也可以称为Defender方法，或者虚拟扩展方法（Virtual extension methods)。Default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。 2.2 接口定义声明格式: public interface 接口名称 { //数据成员必须赋初值 final 数据类型 成员名称=常量； //抽象方法，注意没有定义方法主体 abstract 返回数据类型 方法名称（参数…）； //默认方法，包含方法体 default 返回值的数据类型方法名称（参数…）{ // 方法体... } } 示例: 无默认方法的接口 interface MyInterface{ // 数据成员必须赋初值 static final String NAME=&quot;Mr.Liu&quot; // 抽象方法 abstract String getName(); } 有默认方法的接口 public interface MyInterface{ // 数据成员必须赋初值 static final String NAME=&quot;Mr.Liu&quot; // 抽象方法 abstract String getName(); // 默认方法 default String say(){ System.out.println(&quot;Hello!&quot;) } } 2.3 接口使用原则 接口必须有子类，子类依靠implements关键字可以同时实现多个接口； 接口的子类（如果不是抽象类）则必须覆写接口之中的全部抽象方法； 接口可以利用对象多态性，利用子类实现对象的实例化。 接口与一般类一样，本身也具有数据成员与方法，但数据成员一定要赋初值，且此值不能再更改 接口中除default方法外必须都是抽象方法，所以接口定义格式中，抽象方法声明的关键字abstract是可以省略的。 一个类实现多个接口时，若接口有默认方法，不能出现同名的默认方法 接口可以继承多个接口 3.抽象类和接口的区别 3.1 共同点 都是抽象类型 都可以有实现方法（以前接口不行） 都可以不需要实现类或者继承者去实现所有方法。（以前不行，现在接口中默认方法不需要实现者实现） 3.2 不同点 抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承） 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值 如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类) 总体来说，抽象类和接口在很大程度上都是可以互相替换使用的，但就是由于抽象类本身具备单继承局限，所以当抽象类和接口全部都可以使用的时候优先考虑接口，因为接口没有单继承局限，并且在Java8中接口可以设定默认方法，在一定程度上避免代码重复，利于后期的维护。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-整理篇-map操作]]></title>
    <url>%2F2019%2F10%2F28%2Fjava-8-map%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.声明及初始化Map1.1 先定义,后赋值Map&lt;String , Object&gt; map = new HashMap&lt;String , Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;keyN&quot;, &quot;valueN&quot;); 1.2 双括号初始化法Map&lt;String , String&gt; map = new HashMap&lt;String , Object&gt;(){{ put("key1", "value1"); put("key2", "value2"); put("keyN", "valueN"); }}; 1.3 使用初始块public class MyMap { Map&lt;String,String&gt; maps; // 使用初始块定义 { maps = new HashMap&lt;&gt;(); maps.put(&quot;key1&quot;,&quot;value1&quot;); maps.put(&quot;key2&quot;,&quot;value2&quot;); maps.put(&quot;key3&quot;,&quot;value3&quot;); } public void printMap(){ System.out.println(maps); // 输出:{key1=value1, key2=value2, key3=value3} } } 2.遍历Map2.1 key=&gt;valueMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); } 2.2 遍历keys或valuesMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历map中的键 for (Integer key : map.keySet()) { System.out.println(&quot;Key = &quot; + key); } //遍历map中的值 for (Integer value : map.values()) { System.out.println(&quot;Value = &quot; + value); } 2.3 使用Iterator遍历2.3.1 使用泛型 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); } // 在keySet上 Iterator&lt;String&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { String key = iterator.next(); System.out.println(&quot;MyClass.testMap key=&quot; + key); } //在values上 Iterator&lt;Integer&gt; iterator2 = map.values().iterator(); while (iterator2.hasNext()){ Integer values = iterator2.next(); System.out.println(&quot;MyClass.testMap values=&quot;+values); } 2.3.2 不使用泛型Map map = new HashMap(); Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println(&quot;Key = &quot; + key + &quot;, Value = &quot; + value); } 2.4 通过键找值遍历（效率低）Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Integer key : map.keySet()) { Integer value = map.get(key); System.out.println(&quot;Key = &quot; + key + &quot;, Value = &quot; + value); } 3.map接口方法使用3.1 void clear():删除该Map对象中的所有key-value对clear():删除该Map对象中的所有key-value对 Map&lt;String,String&gt; maps = new HashMap&lt;&gt;(); maps.put(&quot;key1&quot;,&quot;value1&quot;); maps.put(&quot;key2&quot;,&quot;value2&quot;); System.out.println(&quot;clear前:&quot; + maps); maps.clear(); System.out.println(&quot;clear后:&quot; + maps); /** * 输出: clear前:{key1=value1, key2=value2} clear后:{} */ 3.2 boolean containsKey(Object key)containsKey(Object key):查询Map中是否包含指定的key，如果包含则返回true Map&lt;String,String&gt; maps = new HashMap&lt;&gt;(); maps.put(&quot;key1&quot;,&quot;value1&quot;); maps.put(&quot;key2&quot;,&quot;value2&quot;); System.out.println(&quot;判断key1是否存在:&quot; + maps.containsKey(&quot;key1&quot;)); System.out.println(&quot;判断key8是否存在:&quot; + maps.containsKey(&quot;key8&quot;)); /** * 输出: 判断key1是否存在:true 判断key8是否存在:false */ 3.3 boolean containsValue(Object value)查询Map中是否包含一个或多个value，如果包含则返回true。 Map&lt;String,String&gt; maps = new HashMap&lt;&gt;(); maps.put(&quot;key1&quot;,&quot;value1&quot;); maps.put(&quot;key2&quot;,&quot;value2&quot;); System.out.println(&quot;判断value1是否存在:&quot; + maps.containsValue(&quot;value1&quot;)); System.out.println(&quot;判断value8是否存在:&quot; + maps.containsValue(&quot;value8&quot;)); /** * 输出: 判断value1是否存在:true 判断value8是否存在:false */ 3.4 Set entrySet()Set entrySet():返回Map中包含的key-value对所组成的Set集合，每个集合元素都是Map.Entry （Entry是Map的内部类）对象。 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); } 3.5 Object get(Object key)返回指定key所对应的value；如果此Map中不包含该key，则返回null。 Map&lt;String,String&gt; maps = new HashMap&lt;&gt;(); maps.put(&quot;key1&quot;,&quot;value1&quot;); maps.put(&quot;key2&quot;,&quot;value2&quot;); System.out.println(&quot;key1的值:&quot; + maps.get(&quot;key1&quot;)); System.out.println(&quot;key2的值:&quot; + maps.get(&quot;key2&quot;)); /** * 输出: key1的值:value1 key2的值:value2 */ 3.6 boolean isEmpty()查询该Map是否为空（即不包含任何key-value对），如果为空则返回true。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); Map&lt;String,String&gt; map2 = new HashMap&lt;&gt;(); System.out.println(&quot;map1是否为空:&quot; + map1.isEmpty()); System.out.println(&quot;map2是否为空:&quot; + map2.isEmpty()); /** * 输出: map1是否为空:false map2是否为空:true */ 3.7 Set keySet()返回该Map中所有key组成的Set集合。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); System.out.println(&quot;keySet结果:&quot; + map1.keySet()); // 输出:keySet结果:[key1, key2] 3.8 Object put(Object key, Object value):添加一个key-value对，如果当前Map中已有一个与该key相等的key-value对，则新的key-value对会覆盖原来的key-value对。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key1&quot;,&quot;value11&quot;); System.out.println(&quot;keySet结果:&quot; + map1.keySet()); //输出:map1结果:{key1=value11, key2=value2} 3.9 void putAll(Map m)将指定Map中的key-value对复制到本Map中。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); Map&lt;String,String&gt; map2 = new HashMap&lt;&gt;(); map2.put(&quot;a&quot;,&quot;php&quot;); map2.put(&quot;key2&quot;,&quot;java&quot;); map1.putAll(map2); System.out.println(&quot;map1结果:&quot; + map1); //输出:{key1=value1, key2=java, a=php} 3.10 Object remove(Object key)删除指定key所对应的key-value对，返回被删除key所关联的value，如果该key不存在，则返回null。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); map1.put(&quot;key3&quot;,&quot;value3&quot;); map1.remove(&quot;key2&quot;); System.out.println(&quot;map1结果:&quot; + map1); //输出:map1结果:{key1=value1, key3=value3} 3.11 int size()返回该Map里的key-value对的个数。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); map1.put(&quot;key3&quot;,&quot;value3&quot;); System.out.println(&quot;map1的key-value对的个数:&quot; + map1.size()); //输出:map1的key-value对的个数:3 3.12 Collection values()返回该Map里所有value组成的Collection。 Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;key1&quot;,&quot;value1&quot;); map1.put(&quot;key2&quot;,&quot;value2&quot;); map1.put(&quot;key3&quot;,&quot;value3&quot;); System.out.println(&quot;map1的value集合:&quot; + map1.values()); //输出:map1的value集合:[value1, value2, value3]]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-集合]]></title>
    <url>%2F2019%2F10%2F18%2Fjava-7-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.集合的作用为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组），Java提供了集合类。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，Java 5还在java.util.concurrent包下提供了一些多线程支持的集合类。 2.集合分类Java集合大致可分为Set、List和Map三种体系， Set: 代表无序、不可重复的集合； List: 代表有序、重复的集合；而 Map: 代表具有映射关系的集合。 Queue: 从Java 5以后，Java又增加了Queue体系集合，代表一种队列集合实现 3.集合和数组的区别集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量）；而集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象）。 3.1 存储元素角度: 数组: 可以保存基本类型的值和是对象。 集合: 只能保存对象。 数组和集合中保存对象，实际上只是保存对象的引用变量 3.2. 长度角度:数组的长度是固定的，集合的长度是可变的。 4.集合分类的关系Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 4.1 Collection接口、子接口及其实现类的继承树 粗线圈出的Set和List接口是Collection接口派生的两个子接口，它们分别代表了无序集合和有序集合；Queue是Java提供的队列实现，有点类似于List 4.2 Map接口、子接口及其实现类的继承树 5.集合读存5.1 存储我们可以把Java的所有集合分成三大类， Set集合类似于一个罐子，把一个对象添加到Set集合时，Set集合无法记住添加这个元素的顺序，所以Set里的元素不能重复（否则系统无法准确识别这个元素）； List集合非常像一个数组，它可以记住每次添加元素的顺序，只是List的长度可变。 Map集合也像一个罐子，只是它里面的每项数据都由两个值组成。 三种集合示意图: 5.2 读取 List集合中的元素，可以直接根据元素的索引来访问； Map集合中的元素，可以根据每项元素的key来访问其value； Set集合中的元素，可以根据元素本身来访问（这也是Set集合里元素不允许重复的原因） 6.常用集合类及继承关系 7.collection接口Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。Collection接口里定义了如下操作集合元素的方法 7.1 操作集合方法列表Collection接口操作集合元素的方法 boolean add(Object o)：该方法用于向集合里添加一个元素。如果集合对象被添加操作改变了，则返回true。 public static void TestAdd(){ // 定义一个list集合 ArrayList&lt;String&gt; myList = new ArrayList&lt;&gt;(); boolean a1 = myList.add(&quot;第1个元素&quot;); boolean a2 = myList.add(&quot;第2个元素&quot;); System.out.println(myList); System.out.println(a1); System.out.println(a2); } /* 输出: [第1个元素, 第2个元素] true true */ boolean addAll(Collection c)：该方法把集合c里的所有元素添加到指定集合里。如果集合对象被添加操作改变了，则返回true。 public static void TestAddAll(){ ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;A&quot;); strList.add(&quot;B&quot;); Collection&lt;String&gt; subStrList = new ArrayList&lt;&gt;(); subStrList.add(&quot;C&quot;); subStrList.add(&quot;D&quot;); System.out.println(&quot;合并前的strList:&quot; + strList); strList.addAll(subStrList); System.out.println(&quot;合并后的strList:&quot; + strList); } /* 输出: 合并前的strList:[A, B] 合并后的strList:[A, B, C, D] */ void clear()：清除集合里的所有元素，将集合长度变为0。 public static void TestClear(){ ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;A&quot;); strList.add(&quot;B&quot;); strList.add(&quot;C&quot;); strList.add(&quot;D&quot;); System.out.println(&quot;Clear前的strList:&quot; + strList); strList.clear(); System.out.println(&quot;Clear后的strList:&quot; + strList); } /* 输出: Clear前的strList:[A, B, C, D] Clear后的strList:[] */ boolean contains(Object o)：返回集合里是否包含指定元素。 boolean containsAll(Collection c)：返回集合里是否包含集合c里的所有元素。 boolean isEmpty()：返回集合是否为空。当集合长度为0时返回true，否则返回false。 Iterator iterator()：返回一个Iterator对象，用于遍历集合里的元素。 boolean remove(Object o)：删除集合中的指定元素o，当集合中包含了一个或多个元素o时，这些元素将被删除，该方法将返回true。 boolean removeAll(Collection c)：从集合中删除集合c里包含的所有元素（相当于用调用该方法的集合减集合c），如果删除了一个或一个以上的元素，则该方法返回true。 boolean retainAll(Collection c)：从集合中删除集合c里不包含的元素（相当于把调用该方法的集合变成该集合和集合c的交集），如果该操作改变了调用该方法的集合，则该方法返回true。 int size()：该方法返回集合里元素的个数。 Object[] toArray()：该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。 7.2 foreach 遍历集合元素public static void TestForeach(){ ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;A&quot;); strList.add(&quot;B&quot;); strList.add(&quot;C&quot;); strList.add(&quot;D&quot;); for (String str: strList){ System.out.println(str); } } /** 输出: A B C D **/ foreach循环中的迭代变量不是集合元素本身，系统只是依次把集合元素的值赋给迭代变量，因此在foreach循环中修改迭代变量的值没有任何实际意义。同样，当使用foreach循环迭代访问集合元素时，该集合不能被改变，否则将引发Concurrent ModificationException异常。 下面示例会报错: public static void TestForeach() { Collection&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;A&quot;); strList.add(&quot;B&quot;); strList.add(&quot;C&quot;); strList.add(&quot;D&quot;); for (String str : strList) { if (str.equals(&quot;A&quot;)) { // 这一行代码会报错 strList.remove(str); } } System.out.println(strList); } /**报错:** Exception in thread &quot;main&quot; java.util.ConcurrentModificationException.. */ 上面程序如果改为删除“C”字符串，则不会引发异常，这样可能有些读者会“心存侥幸”地想：在迭代时好像也可以删除集合元素啊。实际上这是一种危险的行为：对于HashSet以及后面的ArrayList等，迭代时删除元素都会导致异常——只有在删除集合中的某个特定元素时才不会抛出异常，这是由集合类的实现代码决定的，程序员不应该这么做。 8. Set集合Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add方法返回false，且新元素不会被加入。 Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象；反之，只要两个对象用equals方法比较返回false，Set就会接受这两个对象（甚至这两个对象是同一个对象，Set也可把它们当成两个对象处理。 8.1 HashSet类HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。 8.1.1 HashSet特点 不能保证元素的排列顺序，顺序有可能发生变化。 HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或者两个以上线程同时修改了HashSet集合时，则必须通过代码来保证其同步。 集合元素值可以是null。 当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。 简单地说，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。 8.1.2 重写hasCode的规则HashSet中每个能存储元素的“槽位”（slot）通常称为“桶”（bucket），如果有多个元素的hashCode值相同，但它们通过equals()方法比较返回false，就需要在一个“桶”里放多个元素，这样会导致性能下降。 重写hashCode()方法的基本规则。 在程序运行过程中，同一个对象多次调用hashCode()方法应该返回相同的值。 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法应返回相等的值。 对象中用作equals()方法比较标准的Field，都应该用来计算hashCode值。 下面给出重写hashCode()方法的一般规则。 第一步:把对象内每个有意义的Field（即每个用做equals()方法比较标准的Field）计算出一个int类型的hashCode值。计算方式如下表: 例如代码: return f1.hashCode() + (int)f2; 第二步:为了避免直接相加产生偶然相等（两个对象的f1、f2 Field并不相等，但它们的和恰好相等），可以通过为各Field乘以任意一个质数后再相加。例如如下代码： 例如代码: return f1.hashCode() * 17 + (int)f2 * 13; 8.2 LinkedHashSet类HashSet还有一个子类LinkedHashSet，LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 public class LinkedHashSetTest { public static void main(String[] args) { LinkedHashSet books=new LinkedHashSet(); books.add(&quot;Java&quot;); books.add(&quot;PHP&quot;); System.out.println(books); //删除 Java books.remove(&quot;Java&quot;); //重新添加 Java books.add(&quot;Java&quot;); System.out.println(books); } } /*输出: [Java,PHP] [PHP,Java] */ 输出LinkedHashSet集合的元素时，元素的顺序总是与添加顺序一致。 虽然LinkedHashSet使用了链表记录集合元素的添加顺序，但LinkedHashSet依然是HashSet，因此它依然不允许集合元素重复。 8.3 TreeSet类TreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。与HashSet集合相比，TreeSet还提供了如下几个额外的方法。 8.3.1 TreeSet专有的方法 Comparator comparator()：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator；如果TreeSet采用了自然排序，则返回null。 Object first()：返回集合中的第一个元素。 Object last()：返回集合中的最后一个元素。 Object lower(Object e)：返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参考元素不需要是TreeSet集合里的元素）。 Object higher (Object e)：返回集合中位于指定元素之后的元素（即大于指定元素的最小元素，参考元素不需要是TreeSet集合里的元素）。 SortedSet subSet(fromElement, toElement)：返回此Set的子集合，范围从fromElement（包含）到toElement（不包含）。 SortedSet headSet(toElement)：返回此Set的子集，由小于toElement的元素组成。 SortedSet tailSet(fromElement)：返回此Set的子集，由大于或等于fromElement的元素组成。 使用 TreeSet treeSet = new TreeSet(); treeSet.add(1); treeSet.add(2); @注意: TreeSet并不是根据元素的插入顺序进行排序的，而是根据元素的实际值的大小进行排序的。 TreeSet是采用红黑树的数据结构来存储集合元素。 TreeSet支持两种排序方法:自然排序和定制排序，默认采用自然排序 TreeSet的集合，只能存放实现Comparable接口的类的对象（java一些常用的类已经实现了Comparable接口）。 8.4 EnumSet类EnumSet是一个专为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。 @注意: EnumSet的集合元素也是有序。 EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效，因此EnumSet对象占用内存很小，而且运行效率很好。 批量操作（如调用containsAll和retainAll方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。 EnumSet集合不允许加入null元素，否则抛出NullPointerException异常 EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的static方法来创建EnumSet对象。 8.4.1 创建EnumSet对象的静态方法 static EnumSet allOf(Class elementType)：创建一个包含指定枚举类里所有枚举值的EnumSet集合。 static EnumSet complementOf(EnumSet s)：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来就是该枚举类的所有枚举值）。 static EnumSet copyOf(Collection c)：使用一个普通集合来创建EnumSet集合。 static EnumSet copyOf(EnumSet s)：创建一个与指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。 static EnumSet noneOf(Class elementType)：创建一个元素类型为指定枚举类型的空EnumSet。 static EnumSet of(E first, E… rest)：创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。 static EnumSet range(E from, E to)：创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。 下面程序示范了如何使用EnumSet来保存枚举类的多个枚举值 enum Season { SPRING,SUMMER,FALL,WINTER } public class EnumSetTest { public static void main(String[] args) { //创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值 EnumSet es1=EnumSet.allOf(Season.class); //输出[SPRING,SUMMER,FALL,WINTER] System.out.println(es1); //创建一个EnumSet空集合，指定其集合元素是Season类的枚举值 EnumSet es2=EnumSet.noneOf(Season.class); //输出[] System.out.println(es2); //手动添加两个元素 es2.add(Season.WINTER); es2.add(Season.SPRING); //输出[SPRING,WINTER] System.out.println(es2); //以指定枚举值创建EnumSet集合 EnumSet es3=EnumSet.of(Season.SUMMER , Season.WINTER); //输出[SUMMER,WINTER] System.out.println(es3); EnumSet es4=EnumSet.range(Season.SUMMER , Season.WINTER); //输出[SUMMER,FALL,WINTER] System.out.println(es4); //新创建的EnumSet集合元素和es4集合元素有相同的类型 /es5集合元素 + es4集合元素=Season枚举类的全部枚举值 EnumSet es5=EnumSet.complementOf(es4); //输出[SPRING] System.out.println(es5); } } 8.5 各Set实现类的性能分析HashSet和TreeSet是Set的两个典型实现，到底如何选择HashSet和TreeSet呢？HashSet的性能总是比TreeSet好（特别是最常用的添加、查询元素等操作），因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。 HashSet还有一个子类：LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet比HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的；不过，因为有了链表，遍历LinkedHashSet会更快。 EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素。 必须指出的是，Set的三个实现类HashSet、TreeSet和EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合，并且有超过一个线程修改了该Set集合，则必须手动保证该Set集合的同步性。通常可以通过Collections工具类的synchronizedSortedSet方法来“包装”该Set集合。此操作最好在创建时进行，以防止对Set集合的意外非同步访问。例如： SortedSet s=Collections.synchronizedSortedSet(new TreeSet(...)); 9.List集合List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引， 9.1 List接口和ListIterator接口List作为Collection接口的子接口，当然可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 void add(int index, Object element): 将元素element插入到List集合的index处。 boolean addAll(int index, Collection c): 将集合c所包含的所有元素都插入到List集合的index处。 Object get(int index): 返回集合index索引处的元素。 int indexOf(Object o): 返回对象o在List集合中第一次出现的位置索引。 int lastIndexOf(Object o): 返回对象o在List集合中最后一次出现的位置索引。 Object remove(int index): 删除并返回index索引处的元素。 Object set(int index, Object element): 将index索引处的元素替换成element对象，返回新元素。 List subList(int fromIndex, int toIndex): 返回从索引fromIndex（包含）到索引toIndex（不包含）处所有集合元素组成的子集合。 所有的List实现类都可以调用这些方法来操作集合元素。与Set集合相比，List增加了根据索引来插入、替换和删除集合元素的方法。 9.2 ArrayList和Vector实现类ArrayList和Vector作为List类的两个典型实现，完全支持前面介绍的List接口的全部功能。 ArrayList或Vector对象使用initialCapacity参数来设置该数组的长度，当向ArrayList或Vector中添加元素超出了该数组的长度时，它们的initialCapacity会自动增加。对于通常的编程场景，程序员无须关心ArrayList或Vector的initialCapacity。但如果向ArrayList或Vector集合中添加大量元素时，可使用ensureCapacity(int minCapacity)方法一次性地增加initialCapacity。这可以减少重分配的次数，从而提高性能。 创建空的ArrayList或Vector集合时不指定initialCapacity参数，则Object[]数组的长度默认为10。 9.2.1 重新分配ArrayList和Vector长度方法 void ensureCapacity(int minCapacity)：将ArrayList或Vector集合的Object[]数组长度增加minCapacity。 void trimToSize()：调整ArrayList或Vector集合的Object[]数组长度为当前元素的个数。程序可调用该方法来减少ArrayList或Vector集合对象占用的存储空间。 9.2.2 ArrayList和Vector的区别 ArrayList是线程不安全的: 当多个线程访问同一个ArrayList集合时，如果有超过一个线程修改了ArrayList集合，则程序必须手动保证该集合的同步性 Vector集合则是线程安全的:因为Vector是线程安全的，所以Vector的性能比ArrayList的性能要低 实际上，即使需要保证List集合线程安全，也同样不推荐使用Vector实现类。Collections工具类可以将一个ArrayList变成线程安全的。 9.2.3 固定长度的List操作数组的工具类：Arrays，供了asList(Object… a)方法，该方法可以把一个数组或指定个数的对象转换成一个List集合，这个List集合既不是ArrayList实现类的实例，也不是Vector实现类的实例，而是Arrays的内部类ArrayList的实例。 Arrays.ArrayList是一个固定长度的List集合，程序只能遍历访问该集合里的元素，不可增加、删除该集合里的元素。 如下程序所示: public class FixedSizeList { public static void main(String[] args) { List fixedList=Arrays.asList(&quot;Java&quot; , &quot;PHP&quot;); //获取fixedList的实现类，将输出Arrays$ArrayList System.out.println(fixedList.getClass()); //遍历fixedList的集合元素 for (int i=0; i &lt; fixedList.size() ; i++) { System.out.println(fixedList.get(i)); } //试图增加、删除元素都会引发UnsupportedOperationException异常 fixedList.add(&quot;Go&quot;); // &lt;1&gt; fixedList.remove(&quot;Python&quot;); // &lt;2&gt; } } /*输出: Java PHP Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException... */ 上面程序中 两行代码对于普通的List集合完全正常，但如果试图通过这两个方法来增加、删除Arrays$ArrayList集合里的元素，将会引发异常。所以上面程序在编译时完全正常，但会在运行第一行粗体字标识的代码行处引发UnsupportedOperationException异常。 10.Queue集合Queue用于模拟队列这种数据结构，队列通常是指“先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素，队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 10.1 Queue接口方法 void add(Object e)：将指定元素加入此队列的尾部。 Object element()：获取队列头部的元素，但是不删除该元素。 boolean offer(Object e)：将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比add(Object e)方法更好。 Object peek()：获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回null。 Object poll()：获取队列头部的元素，并删除该元素。如果此队列为空，则返回null。 Object remove()：获取队列头部的元素，并删除该元素。 Queue接口有一个PriorityQueue实现类。除此之外，Queue还有一个Deque接口，Deque代表一个“双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可当成队列使用，也可当成栈使用。Java为Deque提供了ArrayDeque和LinkedList两个实现类。 10.2 PriorityQueue实现类10.2.1 特点: 存元素顺序:PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排序 取元素顺序:当调用peek()方法或者poll()方法取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。 PriorityQueue不允许插入null元素 PriorityQueue不遵守队列的最基本规则:先进先出（FIFO） 10.2.2 元素排序方式 自然排序：采用自然顺序的PriorityQueue集合中的元素必须实现了Comparable接口，而且应该是同一个类的多个实例，否则可能导致ClassCastException异常。 定制排序：创建PriorityQueue队列时，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现Comparable接口。 PriorityQueue队列对元素的要求与TreeSet对元素的要求基本一致，因此关于使用自然排序和定制排序和TreeSet一样。 10.3 Deque接口与ArrayDeque实现类Deque接口是Queue接口的子接口，它代表一个双端队列，Deque接口里定义了一些双端队列的方法，这些方法允许从两端来操作队列的元素。 void addFirst(Object e):将指定元素插入该双端队列的开头。 void addLast(Object e):将指定元素插入该双端队列的末尾。 Iterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。 Object getFirst():获取但不删除双端队列的第一个元素。 Object getLast():获取但不删除双端队列的最后一个元素。 boolean offerFirst(Object e):将指定元素插入该双端队列的开头。 boolean offerLast(Object e):将指定元素插入该双端队列的末尾。 Object peekFirst():获取但不删除该双端队列的第一个元素；如果此双端队列为空，则返回null。 Object peekLast():获取但不删除该双端队列的最后一个元素；如果此双端队列为空，则返回null。 Object pollFirst():获取并删除该双端队列的第一个元素；如果此双端队列为空，则返回null。 Object pollLast():获取并删除该双端队列的最后一个元素；如果此双端队列为空，则返回null。 Object pop()（栈方法）:pop出该双端队列所表示的栈的栈顶元素。相当于removeFirst()。 void push(Object e)（栈方法）:将一个元素push进该双端队列所表示的栈的栈顶。相当于addFirst(e)。 Object removeFirst():获取并删除该双端队列的第一个元素。 Object removeFirstOccurrence(Object o):删除该双端队列的第一次出现的元素o。 removeLast():获取并删除该双端队列的最后一个元素。 removeLastOccurrence(Object o):删除该双端队列的最后一次出现的元素o。 Deque不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了pop（出栈）、push（入栈）两个方法。 Deque接口提供了一个典型的实现类：ArrayDeque，它是一个基于数组实现的双端队列，创建Deque时可指定一个numElements参数，该参数用于指定Object[]数组的长度；如果不指定numElements参数，Deque底层数组的长度为16。 @提示: ArrayList和ArrayDeque两个集合类的实现机制基本相似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出了该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素。 10.4 LinkedList实现类LinkedList类是List接口的实现类——这意味着它是一个List集合，可以根据索引来随机访问集合中的元素。除此之外，LinkedList还实现了Deque接口，因此它可以被当成双端队列来使用，自然也可以被当成“栈”来使用了。 10.4.1 LinkedList与ArrayList、ArrayDeque的实现机制区别 ArrayList、ArrayDeque内部以数组的形式来保存集合中的元素，因此随机访问集合元素时有较好的性能； LinkedList内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能非常出色（只需改变指针所指的地址即可）。 11. 各种线性表性能分析Java提供的List就是一个线性表接口，而ArrayList、LinkedList又是线性表的两种典型实现：基于数组的线性表和基于链的线性表。Queue代表了队列，Deque代表了双端队列（既可作为队列使用，也可作为栈使用），接下来对各种实现类的性能进行分析。 LinkedList集合不仅提供了List的功能，还提供了双端队列、栈的功能。关于性能方面可看下图： 以数组作为底层实现的集合在随机访问时性能较好； 以链表作为底层实现的集合在执行插入、删除操作时有很好的性能； 进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-泛型]]></title>
    <url>%2F2019%2F10%2F17%2Fjava-6-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 为什么使用泛型程序设计？使用泛型机制编写的程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。 泛型对于集合类尤其有用。 泛型程序设计(Generic programming) 意味着编写的代码可以被很多不同类型的对象所 重用。 2. 泛型定义声明类的泛型版本与声明类的一般版本的语法格式很类似，只有稍微的不同。 声明一般类的语法格式为： [修饰符] class类名 [extends父类名] [implements接口1名,接口2名,…]{ //类体 } 而声明泛型类型时，只需要在类名后面跟上一个类型参数即可，其语法格式为： 单类型参数泛型类型声明 [修饰符] class类名&lt;类型参数&gt; [extends父类名] [implements接口1名,接口2名,。。。]{ //类体 } 多类型参数泛型类型声明 [修饰符] class类名&lt;类型参数1,类型参数2,类型参数3&gt; [extends父类名] [implements接口1名,接口2名,。。。]{ //类体 } 每个类型参数必须唯一。 代码示例: box类 public class Box { private Object object; public void add(Object object){ this.object = object; } public Object get(){ return object; } } box 泛型类 // Box类的泛型版本. public class Box&lt;T&gt; { private T t; // T代表&quot;类型&quot; public void add(T t) { this.t = t; } public T get() { return t; } } T:”代表类型变量” 3. 泛型使用一个泛型类型调用通常被看做是“参数化类型”。要实例化这个类，照常使用new关键字，但是将&lt;Integer&gt;放在类名和圆括号之间： Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); integerBox.add(new Integer(10)); // 不需要类型转换 Integer someInteger = integerBox.get(); System.out.println(someInteger) 4.泛型方法4.1 定义泛型方法类型参数还可以在方法和构造器签名中声明，用来创建“泛型方法”和“泛型构造器”。这与声明一个泛型类型相似，但是类型参数的作用域被限制在它被声明的方法或构造器中。 声明格式: [修饰符] &lt;类型变量&gt; [返回类型] 方法名(参数列表){ // 方法体 } 代码示例: class ArrayAlg{ public static &lt;T&gt; T getMiddle(T... a){ return a[a.length / 2]; } } 这个方法是在普通类中定义的， 而不是在泛型类中定义的。 然而， 这是一个泛型方法， 可以从尖括号和类型变量看出这一点。注意:类型变量放在修饰符(这里是 public static) 的后面，返回类型的前面。 4.2 调用泛型方法当调用一个泛型方法时’ 在方法名前的尖括号中放入具体的类型 调用ArrayAlg类中的泛型方法: String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;]ohnM, &quot;Q.n, &quot;Public&quot;); 在大多数情况下,方法调用中可以省略类型参数。编译器有足够的信息能够推断出所调用的方法。它用 names 的类型(即 String[]) 与泛型类型 T[ ] 进行匹配并推断出 T 一定是 String。也就是说上述代码也可以修改为: String middle = ArrayAlg.getHiddle(&quot;]ohn&quot;, &quot;Q.&quot;, &quot;Public&quot;); 5.类型变量5.1 类型参数命名惯例按惯例，类型参数命名为单个的大写字母。这与已经知道的变量命名规则不太相同。这样命名的原因是：如果不这样命名，将很难区分在一个类型变量和一个变通类或接口名称之间的不同。最普遍使用的类型参数名称如下： E——元素（被Java集合框架所广泛地使用）。 K——键。 N——数字。 T——类型。 V——值。 S，U，V等——第二、第三、第四个类型。 5.2 类型变量的限定5.2.1 类型参数边界默认可以使用任何类型来实例化一个泛型类对象，但Java中也对泛型类实例的类型作了限制。 语法如下: &lt;T exteds anyClass&gt; anyClass指某个接口或类 anyClass指的是上限 限定上限的类型中，最多只能有1个类(或0个类)，其余的必须均为接口。 限定上限的类型中，接口可以有多个，中间用&amp;字符分割。 使用泛型限制后，泛型类的类型必须实现或者继承了anyClass 这个接口或类。无论anyClass是接口还是类，在进行泛型限制时都必须使用extends关键字。 泛型类限制使用 import java.util.List; public class LimitClass&lt;T extends List&gt;{ // .... } 泛型方法限制使用 import java.util.List; public class LimitClass{ public static &lt;T extends List&gt; void testMedthod(T t){ // .... } } 对类型参数的限定，也可以包括指定额外的必须被实现的接口，使用&amp;字符，例如指定类型变量U可接收的值为实现了MyInterface接口的Number类或其之类。语法如下: // 上限类型中有一个接口 &lt;U extends Number &amp; MyInterface&gt; // 上限类型中有n个接口 &lt;U extends Number &amp; MyInterface1 &amp; MyInterface2 &amp; ... &amp;MyInterface...&gt; 5.2.2 使用通配符: ?固定的泛型类型使用起来不灵活，java提供一种巧妙的方案:通配符类型。 定义格式 //不设置上限:表示任何类型 AnyGeneric&lt;?&gt; AnyGeneric&lt;?,？&gt; // 设置上限 AnyGeneric&lt;? extends MyClass&gt; 表示任何泛型AnyGeneric类型，它的类型参数是MyClass的子类 代码1: public class Demo { public static void main(String[] args){ Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;(); p1.setX(10); p1.setY(20); printPoint(p1); Point&lt;String, String&gt; p2 = new Point&lt;String, String&gt;(); p2.setX(&quot;东经180度&quot;); p2.setY(&quot;北纬210度&quot;); printPoint(p2); } // 使用通配符 public static void printPoint(Point&lt;?, ?&gt; p){ System.out.println(&quot;This point is: &quot; + p.getX() + &quot;, &quot; + p.getY()); } } class Point&lt;T1, T2&gt;{ T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; } } /* 运行结果： This point is: 10, 20 This point is: 东经180度, 北纬210度 */ 代码2: public class Demo { public static void main(String[] args){ Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;(); p1.setX(10); p1.setY(20); printNumPoint(p1); Point&lt;String, String&gt; p2 = new Point&lt;String, String&gt;(); p2.setX(&quot;东经180度&quot;); p2.setY(&quot;北纬210度&quot;); printStrPoint(p2); } // 借助通配符限制泛型的范围 public static void printNumPoint(Point&lt;? extends Number, ? extends Number&gt; p){ System.out.println(&quot;x: &quot; + p.getX() + &quot;, y: &quot; + p.getY()); } public static void printStrPoint(Point&lt;? extends String, ? extends String&gt; p){ System.out.println(&quot;GPS: &quot; + p.getX() + &quot;，&quot; + p.getY()); } } class Point&lt;T1, T2&gt;{ T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; } } /* 运行结果： x: 10, y: 20 GPS: 东经180度，北纬210度 */ 6.类型擦除当一个泛型被实例化时，编译器通过称为“类型擦除”的技术来编译这些类型。所谓类型擦除，指的是编译器移除一个类或方法中所有与类型参数相关的信息。类型擦除能够使使用泛型的Java应用程序与Java类库和在泛型出现之前创建的应用程序保持二进制上的兼容性。 例如:将泛型类Pair 进行类型擦除擦除前: public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } 擦除后: public class Pair { private Object first; private Object last; public Pair(Object first, Object last) { this.first = first; this.last = last; } public Object getFirst() { return first; } public Object getLast() { return last; } } 因此，Java使用擦拭法实现泛型，导致了： 编译器把类型视为Object； 编译器根据实现安全的强制转型。 7.泛型的局限Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限： 7.1 不能用类型参数代替基本类型不能用类型参数代替基本类型，因此没有 Pair、Pair… Pair&lt;int&gt; p = new Pair&lt;int&gt;(1, 2); // compile error! 7.2 无法判断带泛型的ClassPair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456); // Compile error: if (p instanceof Pair&lt;String&gt;.class) { } 原因和前面一样，并不存在Pair.class，而是只有唯一的Pair.class。 7.3 无法实例化T类型public class Pair&lt;T&gt; { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); } } 上述代码无法通过编译，因为构造方法的两行语句： first = new T(); last = new T(); //擦拭后实际上变成了： first = new Object(); last = new Object(); 7.4 无法创建参数化类型的数组Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; //error 需要说明的是，只是不允许创建这些数组，而声明类型为Pair[]的变量仍是合法的，不过不能用new Pair[10]初始化这个变量。 7.5 总结Java的泛型是采用擦拭法实现的；擦拭法决定了泛型&lt;T&gt;： 不能是基本类型，例如：int； 不能获取带泛型类型的Class，例如：Pair.class； 不能判断带泛型类型的类型，例如：x instanceof Pair； 不能实例化T类型，例如：new T()。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-初始化块]]></title>
    <url>%2F2019%2F10%2F15%2Fjava-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1.什么是初始化块Java使用构造器来对单个对象进行初始化操作，使用构造器先完成整个Java对象的状态初始化，然后将Java对象返回给程序，从而让该Java对象的信息更加完整。与构造器作用非常类似的是初始化块，它也可以对Java对象进行初始化操作 2. 使用初始化块初始化块是Java类里可出现的第4种成员（前面依次有Field、方法和构造器）。 2.1 语法 [修饰符] { // todo 可执行性代码 } @注意: 一个类里可以有多个初始化块，相同类型的初始化块之间有顺序:前面定义的初始化块先执行，后面定义的初始化块后执行。 初始化块的修饰符只能是static，使用static修饰的初始化块被称为静态初始化块。 初始化块里的代码可以包含任何可执行性语句，包括定义局部变量、调用其他对象的方法，以及使用分支、循环语句等。 初始化块虽然也是Java类的一种成员，但它没有名字，也就没有标识，因此无法通过类、对象来调用初始化块。 初始化块只在创建Java对象时隐式执行，而且在执行构造器之前执行 2.2 示例定义一个类,然后实例化该类 package com.hui.javalearn.classes; /** * description : 初始化块使用 * * @author : Mr.Liuqh * @date : 2019-12-31 11:57 */ public class StaticUseOne { /** * 定义一个静态成员 */ private int num; /* * 定义第一个初始化块 */ { // 对成员变量赋值 num = 11; System.out.println(&quot;第一个初始化块，输出: &quot; + num); } /* * 定义第二个初始化块 */ { System.out.println(&quot;第二个初始化块，输出: &quot; + num); } /** * 无参构造方法 */ public StaticUseOne(){ System.out.println(&quot;无参构造方法输出: &quot; + num); } } ... // 测试 new StaticUseOne(); /* 输出: 第一个初始化块，输出: 11 第二个初始化块，输出: 11 无参构造方法输出: 11 查看源码 虽然Java允许一个类里定义2个普通初始化块，但这没有任何意义。因为初始化块是在创建Java对象时隐式执行的，而且它们总是全部执行，因此我们完全可以把多个普通初始化块合并成一个初始化块，从而可以让程序更加简洁，可读性更强 3.静态初始化块如果定义初始化块时使用了static修饰符，则这个初始化块就变成了静态初始化块，也被称为类初始化块。 静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是在创建对象时才执行。因此静态初始化块总是比普通初始化块先执行。 3.1 示例package com.hui.javalearn.classes; /** * description : 静态初始化块使用 * * @author : Mr.Liuqh * @date : 2019-12-31 11:57 */ public class StaticUseTwo { /** * 定义一个静态成员 */ private static int num; /** * 定义一个非静态成员 */ private int total; /* * 定义一个初始化块， * * 注意: 虽然它是第一个被定义的初始化块，但不会第一个执行。 */ { // 给非静态成员赋值 total = 100; System.out.println(&quot;这是一个非静态初始化块，输出: num = &quot; + num); System.out.println(&quot;这是一个非静态初始化块，输出: total = &quot; + total); } /* * 定义第一个静态初始化块 * * 注意: 会第一个执行！！ */ static { // 对静态成员变量赋值 num = 11; System.out.println(&quot;这是一个静态初始化块，输出: &quot; + num); } /** * 无参构造方法 */ public StaticUseTwo(){ System.out.println(&quot;无参构造方法输出: &quot; + num); } } // 测试 new StaticUseTwo(); /* 输出: 这是一个静态初始化块，输出: 11 这是一个非静态初始化块，输出: num = 11 这是一个非静态初始化块，输出: total = 100 无参构造方法输出: 11 查看源码 3.2 总结 静态初始化块总是比普通初始化块先执行。 静态初始化不能访问非静态成员，也不能访问实例Field和实例方法。 4. 使用场景从某种程度上来看，初始化块是构造器的补充，初始化块总是在构造器执行之前执行。 与构造器不同的是，初始化块是一段固定执行的代码，它不能接收任何参数。因此初始化块对同一个类的所有对象所进行的初始化处理完全相同。基于这个原因，不难发现初始化块的基本用法，如果有一段初始化处理代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到初始化块中. 4.1 示例如果两个构造器中有相同的初始化代码，这些初始化代码无须接收参数，就可以把它们放在初始化块中定义，如下图所示:]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-枚举]]></title>
    <url>%2F2019%2F10%2F15%2Fjava-4-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[1.枚举类型在java语言中，使用关键字enum定义一个枚举类型 注意事项 所有的枚举都隐含地继承自 java.lang.Enum,因为Java不支持多重继承，所以枚举类型不能再继承其他类 枚举类型的构造器必须为包级私有或私有的 枚举之间是逗号，与其他语法的间隔是分号。 1.1 无参构造器的枚举声明 public enum 类名 { ... } 实例 public enum EnumStudy { A, B, C, D; // .... } 1.2 有参构造器的枚举声明 public enum 类名 { ... } 实例 public enum EnumStudy { A(&quot;优秀&quot;,&quot;90分以上&quot;), B(&quot;优良&quot;,&quot;80~90分&quot;), C(&quot;良&quot;,&quot;70~80分&quot;), D(&quot;及格&quot;,&quot;60 ~70分&quot;), E(&quot;不及格&quot;,&quot;60分以下&quot;); //自定义成员变量 public String value; //自定义成员变量 public String desc; EnumStudy(String value, String desc){ this.value = value; this.desc = desc; } } 1.3 枚举遍历1.3.1 无参构造器遍历// 无参构造器枚举遍历 for (EnumStudy item:EnumStudy.values()){ System.out.println(item); } /**输出: A B C D */ 1.3.2 有参构造器遍历// 有参构造器枚举遍历 for (EnumStudy item:EnumStudy.values()){ System.out.println(&quot;获得:&quot;+item.value + &quot;, 分值:&quot;+item.desc); } /**输出: 获得:优秀, 分值:90分以上 获得:优良, 分值:80~90分 获得:良, 分值:70~80分 获得:及格, 分值:60 ~70分 获得:不及格, 分值:60分以下 */]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-类]]></title>
    <url>%2F2019%2F10%2F15%2Fjava-3-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 类类的定义 [修饰符] class 类名 { // 零或多个构造器定义... // 零或多个Field... // 零或多个方法... } 修饰符: 如public，private及许多其他修饰符 类名，并且按惯例首字母要大写。 父类（超类）的名称，都要在前面加上关键字extends。一个类只能继承自一个父类。 被该类实现的接口列表（用逗号进行分隔），在接口前面加上关键字implements。一个类可以实现多个接口。 类体，用花括号{}包围。 1.1 定义MyClass类public class MyClass { /** * @Description: 静态常量 */ public final static Double PI = 3.1415; /** * @Description: 名称（成员变量） */ private String name; /** * @Description: 设置名称（成员方法） */ public void setName(String name) { this.name = name; } /** * @description: 获取名称（成员方法） **/ public String getName() { return this.name; } /** * @Description: 无参构造方法 */ public MyClass() { System.out.println(&quot;无参构造方法....&quot;); } public static void staticMethod(){ System.out.println(&quot;这是个静态方法&quot;); } /** * @description:有参构造方法 **/ public MyClass(String name) { this.name = name; System.out.println(&quot;有参构造方法....&quot;); } } 1.2 调用MyClass类1.2.1 实例化调用MyClass classTest = new MyClass(); classTest.setName(&quot;小明&quot;); String name = classTest.getName(); System.out.println(name); /*输出: 无参构造方法.... 小明 */ 1.2.2 静态调用//调用静态成员 System.out.println(MyClass.PI); //调用静态方法 MyClass.staticMethod(); /*输出: 无参构造方法.... 小明 */ 虽然静态成员也可以使用”对象.静态成员”的形式进行调用，但通常不建议用这样的形式，因为这样容易混淆静态成员和非静态成员。 测试有参构造方法 MyClass classTest2 = new MyClass(&quot;张三&quot;); System.out.println(classTest2.getName()); /*输出: 有参构造方法.... 张三 */ 1.3 类方法分析[修饰符] 返回类型 方法名称(方法参数列表){ // 方法体 } 返回类型: 方法所返回的数据值的数据类型，若方法不返回值，用void 1.3.1 方法重载Java语言支持“重载”方法，并且Java能够根据不同的“方法签名”来区分重载的方法。这意味着在一个类中，可以有相同名称但具有不同参数列表的方法（当然会有一些限定条件，这将在“接口和继承”中讨论）。 代码示例 public class DrawDate{ //声明绘制字符串的方法 public void draw(String s){ // ... } //声明绘制整数的方法 public void draw(int i){ // ... } //声明绘制双精度小数的方法 public void draw(double f){ // ... } //声明绘制一个整数和一个小数的方法 public void draw(int i , double f){ // ... } } 1.3.2 传递任意数量的参数可以使用“可变参数”来传递任意数量的值到一个方法。当程序员不知道有多少个特定类型的参数要被传递给方法时，使用可变参数。可变参数是手工创建一个数组的简洁方法。要使用可变参数，在最后一个参数的类型后面跟上省略号“…”，然后是一个空格，再接着是参数名。具有这种可变参数的方法可以接收任意数量的该类型的参数，包括空参数。例如下面代码： public Polygon polygonFrom(Point... corners) { //corners参数被当作数组处理，可以调用数组属性length获得长度 int numberOfSides = corners.length; //声明两个变量 double squareOfSide1, lengthOfSide1; squareOfSide1 = (corners[1].x - corners[0].x)*(corners[1].x - corners[0].x) + (corners[1].y - corners[0].y)*(corners[1].y - corners[0].y) ; lengthOfSide1 = Math.sqrt(squareOfSide1); //调用Math类的静态方法求平方根 … } 可以看出来，在上面这个方法中，corners被当做数组使用。调用这个方法时，既可以使用一个数组，也可以使用一系列的参数。不管使用哪种形式，方法中的代码都会将参数作为一个数组对待。 1.4 构造器语法 public 类名称(方法参数列表){ // 方法体 } 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有 0 个、1 个或多个参数 构造器没有返回值 构造器总是伴随着 new 操作一起调用 1.4.1 无参构造器 /** * @description:无参构造器 **/ public MyClass() { System.out.println(&quot;无参构造器....&quot;); } 1.4.2 有参构造器 /** * @description:有参构造器 **/ public MyClass(String name) { this.name = name; System.out.println(&quot;有参构造器....&quot;); } 2. Object类Object类是Java一个比较特殊的类，Java中所有的类从根本上都继承自Object类。Object是Java中唯一没有父类的类。 如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类就默认继承Object类 Object类中常用的方法 3. 内部类所谓的内部类就是指在一个类的内部又定义了其他类的情况。如果在类Outer的内部再定义一个类Inner，此时类Inner就称为内部类，而类Outer则称为外部类。内部类可声明为public或private。当内部类声明为public或private时，对其访问的限制与成员变量和成员方法完全相同。 3.1 定义权限标示符 class 外部类名称{ ... 权限标示符 class 内部类名称 { ... } } 示例: // 外部类 public class Outer{ // 外部类属性 int score=95; // 外部类方法，调用内部类方法 void inst(){ Inner in=new Inner(); in.display(); } // 内部类 public class Inner{ //在内部类中声明name属性 String name=&quot;张三&quot;; // 内部类方法 void display(){ //内部类访问外部类中的属性 System.out.println(&quot;成绩:score=&quot;+score); } } } // 测试使用 public class ObjectInnerDemo{ public static void main(String[]args){ Outer outer=new Outer(); outer.inst(); //输出:成绩:score=95 } } 3.2 内部类主要作用 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以相互访问。但外部类不能访问内部类的实现细节，例如内部类的成员变量。 匿名内部类适合用于创建那些仅需要一次的类 3.3 使用static定义的内部类就是外部类如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。 static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。 静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。 静态内部类是外部类的一个静态成员，因此外部类的静态方法、静态初始化也可以使用静态内部类来定义变量、创建对象等。 外部类依然不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。 使用示例: class StaticInnerClassTest { // 外部类实例成员 private int propl=5; // 外部类静态成员 private static int prop2=9; void display() { StaticInnerClass in=new StaticInnerClass(); in.display(); } // 静态内部类 static class StaticInnerClass { //内部类里的静态成员 private static int age; public void display() { //下面代码出现错误-静态内部类无法访问外部类的实例成员 // System.out.println(propl); //下面代码正常 System.out.println(prop2); } } } public class ObjectStaticDemo { public static void main(String[]args) { StaticInnerClassTest outer=new StaticInnerClassTest(); outer.display(); // 输出:9 } } 3.4 匿名内部类匿名内部类由于没有名字，所以它的创建方式也比较特别。创建格式如下。 new 父类构造器（参数列表）|实现接口（）{ //匿名内部类的类体部分 } 匿名内部类我们必须要继承一个父类或者实现一个接口。同时它没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。 使用示例 abstract class Bird { private String name; public String getName() { return name; } public void setName(String name) { this.name=name; } public abstract int fly(); } public class AnonymousInnerClass { public void test(Bird bird) { System.out.println(bird.getName()+&quot;最高能飞&quot;+bird.fly()+&quot;米&quot;); } public static void main(String[]args) { // 声明一个名为 animal 的AnonymousInnerClass对象 AnonymousInnerClass animal=new AnonymousInnerClass(); // 调用实例方法,并传入一个匿名对象 animal.test( new Bird() { public int fly() { return 1000; } public String getName() { return&quot;小鸟&quot;; } } } } 代码详解 在AnonymousInnerClass类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在main方法中直接使用匿名内部类来创建一个Bird实例。 匿名内部类不能是抽象类，所以必须要实现它的抽象父类或者接口里面所有的抽象方法。 匿名内部类存在一个缺陷，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类不能够被重复使用。 4. 匿名对象匿名对象，顾名思义就是没有明确的声明的对象。读者也可以简单地理解为只使用一次的对象，即没有任何一个具体的对象名称引用它 使用示例: class Person{ private String name=&quot;张三&quot;; private int age=25; public String talk(){ return&quot;我是：&quot;+name+&quot;，今年：&quot;+age+&quot;岁&quot;; } } public class AnonymousObject { public static void main(String[]args) { // 使用匿名对象 System.out.println(new Person().talk()); } }]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-注解]]></title>
    <url>%2F2019%2F10%2F15%2Fjava-5-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.什么是注解？标注（Annotations）就是代码里的标记，它提供与程序有关的数据，但是标注本身不是程序一部分。标注不对其所注解的代码的操作有直接的影响。在有的书中，将标注也称为注解。通过使用标注，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或进行部署。 2.注解的作用简单地说，标注就是代码里的标记，这些标记在类加载、运行时或编译的时候可以被解释，但是不对程序的运行产生直接的影响。标注有很多作用，包括： 为编译器提供信息。编译器可以使用标注来检测错误或禁止警告。 在编译和部署时处理。软件开发工具可以处理标注信息以生成代码、XML文件等。 在运行时处理。有些标注在运行时可以被检查并使用。 从某些方面看，标注就像修饰符一样被使用，并应用于包、类型、构造方法、方法、成员变量、参数、本地变量的声明中。标注可以应用到程序的类的声明、字段的声明、方法的声明及其他程序元素的声明中。按惯例标注要出现在它自己所在行的第一行，并且可以包括带有名称或未命名值的元素， 3.注解的分类Java的注解可以分为三类： 第一类是由编译器使用的注解， 例如： @Override：让编译器检查该方法是否正确地实现了重写； @SuppressWarnings：告诉编译器忽略此处代码产生的警告。 @Deprecated: 被此注解标记的类或者方法表示不再推荐使用此类或者方法 这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解 比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。 4.内置注解4.1 @Override@Override 是一个标记注解，表示重写父类方法。使用实例: // UserDao 接口 public interface IUserDao { User loadUserByUsername(String username); // ... } // UserDao 实现类 public class UserDao implement IUserDao { @Override public User loadUserByUsername(String username) { // TODO: } // ... } 4.2 @SuppressWarnnings@SuppressWarnnings 抑制编译器警告，取值为: deprecation ：使用了不赞成使用的类或方法时的警告； unchecked ：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; fallthrough ：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告; path ：在类路径、源文件路径等中有不存在的路径时的警告; serial ：当在可序列化的类上缺少 serialVersionUID 定义时的警告; finally ：任何 finally 子句不能正常完成时的警告; all ：关于以上所有情况的警告。 实例 public class UserDao { @SuppressWarnings(value = {&quot;rawtypes&quot;, &quot;unchecked&quot;}) public List&lt;User&gt; getUserList() { List&lt;User&gt; list = new ArrayList(); return list; } // ... } 4.3 @Deprecated被此注解标记的类或者方法表示不再推荐使用此类或者方法。 此外对应的 java doc 中有一个 @deprecated tag。 实例 public class UserDao { /** * 根据用户的登录昵称拉取用户信息 * * @param username 登录昵称 * @return 用户信息 */ public User loadUserByUsername(String username) { // ... } /** * 根据用户的真实姓名拉取用户信息 * * @param realname 真实姓名 * @return 用户信息 * @deprecated 该方法已过期，不推荐使用 */ @Deprecated public User loadUserByRealname(String realname) { // ... } // ... } 5.元注解元注解的作用就是负责注解其他注解. Java5.0定义的元注解： 5.1 @Target:指定注解所修饰对象的范围。 ElementType.CONSTRUCTOR :用于描述构造器 ElementType.FIELD :用于描述域 ElementType.LOCAL_VARIABLE :用于描述局部变量 ElementType.METHOD :用于描述方法 ElementType.PACKAGE :用于描述包 ElementType.PARAMETER :用于描述参数 ElementType.TYPE :用于描述类、接口(包括注解类型) 或enum声明 5.2 @Retention定义Annotation保留的时间长短。 RetentionPoicy.SOURCE :在源文件中有效（即源文件保留） RetentionPoicy.CLASS :在class文件中有效（即class保留） RetentionPoicy.RUNTIME :在运行时有效（即运行时保留），在运行时保留可以通过反射获取到该值的属性值同时相应做一些逻辑处理 5.3 @Documented标记注解，含有该注解类型的元素(带有注释的)会通过javadoc或类似工具进行文档化。 5.4 @Inherited表示注解类型能被自动继承。 如果一个类使用了 @Inherited 类型的注解，则此类的子类也将含有该注解，当 Retention 为 RUNTIME 时通过反射API可以查询到此类以及其父类直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 6.自定义注解注解类型的定义有点类似接口的定义，使用@interface关键字用来声明一个注解，实际上标注类型是接口的一种。里面的每一个方法表示声明了一个可配置的参数，方法名即为参数名。 访问修饰符只能使用 public 或者 default（默认的、友好的） 返回值类型就是参数的类型且只能为 八种基本数据类型 、 Class 、 String 、 Enum 、Annotations类型以及上述类型所组成的 数组 通过 default 关键字声明参数的默认值。 如果只有一个参数成员最好命名为 value() 注解元素必须有确定的值，要么在定义注解元素时默认值指定，要么使用此注解时指定。非基本类型注解元素的值不可为 null 6.1 第1步:用@interface定义注解public @interface Report { } 6.2 第2步:添加参数、默认值public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; ...; } 6.3 用元注解配置注解：@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;; ...; } 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 7. 解析注解Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置： SOURCE类型的注解在编译期就被丢掉了； CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM； RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 7.1 读取注解因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。Java提供的使用反射API读取Annotation的方法包括： 7.1.1 判断某个注解是否存在于Class、Field、Method或Constructor：方法列表: Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 实例 // 判断@Report是否存在于Person类: Person.class.isAnnotationPresent(Report.class); 7.1.2 直接读取注解的方法列表 Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 实例 // 获取Person定义的@Report注解: Report report = Person.class.getAnnotation(Report.class); int type = report.type(); String level = report.level(); 7.1.3 射API读取注解的两种方法 是先判断Annotation是否存在，如果存在，就直接读取 Class cls = Person.class; if (cls.isAnnotationPresent(Report.class)) { Report report = cls.getAnnotation(Report.class); ... } 直接读取Annotation，如果Annotation不存在，将返回null Class cls = Person.class; Report report = cls.getAnnotation(Report.class); if (report != null) { ... } 8.第三方注解8.1 springmvc校验注解 @NotNull: 注解元素必须是非空 @Null: 注解元素必须是空 @Digits: 验证数字构成是否合法 @Future: 验证是否在当前系统时间之后 @Past: 验证是否在当前系统时间之前 @Max: 验证值是否小于等于最大指定整数值 @Min: 验证值是否大于等于最小指定整数值 @Pattern: 验证字符串是否匹配指定的正则表达式 @Size: 验证元素大小是否在指定范围内 @DecimalMax: 验证值是否小于等于最大指定小数值 @DecimalMin: 验证值是否大于等于最小指定小数值 @AssertTrue: 被注释的元素必须为true @AssertFalse: 被注释的元素必须为false @Email: 被注释的元素必须是电子邮箱地址 @Length: 被注释的字符串的大小必须在指定的范围内 @NotEmpty: 被注释的字符串的必须非空 @Range: 被注释的元素必须在合适的范围内]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-数组]]></title>
    <url>%2F2019%2F10%2F14%2Fjava-2-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1. 数组1.1 数组的特点 Java中的数组，既能存储原始数据类型，又能存储对象类型。 数组元素的个数称为数组的长度。数组长度一旦确定，就不能改变。 数组元素的下标是从0开始的，即第一个元素的下标是0。 Java不支持多维数组，但是可以创建数组的数组。 Java中将数组作为对象处理。数组对象含有成员变量length，用来表示数组的长度。 1.2 一维数组在Java里创建并使用一维数组，需要以下步骤: 声明一个数组变量来存放该数组。 创建一个新的数组对象并将其赋值给上一步所创建的数组变量。 在该数组中存储数据。 访问或修改此数组中存储的数据（元素）。 1.2.1 声明一维数组语法: // 方式1 数组类型[] 数组名字; // 方式2 数组类型 数组名字[]; 这两种数组变量声明的方式在作用上是相同的，但通常建议采用第一种方式 实例 int[] weeks; //声明一个整型数组 boolean[] flag; //声明一个布尔类型的数组 float[] score; //声明一个浮点类型的数组 1.2.2 创建一维数组声明了数组变量之后，下一步就需要创建一个数组对象，并将其赋给所声明的数组变量。而创建数组对象，实际上就是在内存中分配相应大小的存储空间给数组。有两种方式可以用来创建数组对象。 使用new运算符 在Java中，数组是引用对象，所以可以使用new运算符来直接创建一个数组对象，如以下代码所示: //创建一个整型数组对象，数组大小为7 int[] weeks = new int[7] ; //创建一个字符串数组，数组大小为10 String[] studentNames = new String[10]; 使用new运算符来创建数组对象时，必须指定这个数组的大小。创建数组对象时，仅仅是在内存中为数组变量分配指定大小的空间，并没有实际存储数据，这时数组的所有元素会被自动地赋予初值 - 数字数组，初值是0。 - 布尔数组，初值是false。 - 字符数组，初值是‘\0’。 - 对象数组，初值是null。 直接初始化数组元素 也可以通过把数组元素值直接放在大括号中的办法来同时完成创建和初始化数组，这时将在内存中分配与元素数量相适应的空间大小，并赋予指定的元素值，如以下代码所示。 //创建一个整型数组对象，数组大小为7，并同时赋初值 int[] weeks = {1,2,3,4,5,6,7}; //创建一个String数组对象，并初始化 String[] studentNames = {&quot;张小明&quot;,&quot;黄芳&quot;,&quot;赵秀丽&quot;}; 使用这种方法创建数组对象时，大括号里的元素类型必须与指定的数据类型一致，并且数组的大小与大括号中包含的元素个数相同。 1.3 多维数组数组元素除了可以是原始数据类型、对象类型之外，还可以是数组，即数组的元素是数组。所以虽然Java不支持多维数组，但是可以通过声明数组的数组来实现同样的功能。元素数组还可以包含数组，依此类推，最后创建出达到需要的任意维数。 1.3.1 声明二维数组语法: 数组类型[][] 数组名字; 数组类型 数组名字[][]; 实例 int[][] year; boolean[][] flag; float[][] score; 1.3.2 创建二维数组声明了数组变量之后，下一步就需要创建一个数组对象，并将其赋给所声明的数组变量。而创建数组对象实际上就是在内存中分配相应大小的存储空间给数组。有两种方式可以用来创建二维数组对象。 使用new运算符 //创建了一个二维数组对象，用来保存一年中的52个星期及每个星期的7天 int[][] year = new int[52][7] ; 直接初始化数组元素 //在这里，定义了一个二维数组arrays2，它有3行5列。 int[][] arrays2={{11,12,13,14,15},{21,22,23,24,25},{31,32,33,34,35}}； //数组中每一行的长度也可以不同： int[][] arrays2 = {{11,12 },{21,22,23,24,25},{31, 34,35}}； boolean flags = {{true,false},{true,true,false,false},{false,false,true}}; 1.4 数组操作1.4.1 遍历数组遍历一维数组 String[] studentNames = {&quot;张三&quot;,&quot;李四&quot;,&quot;王伟&quot;,&quot;刘想&quot;}; //第一种遍历数组 for (int i = 0; i &lt; studentNames.length; i++){ System.out.println(&quot;第一种遍历打印&gt;&gt;&gt;&gt;&gt; &quot; + studentNames[i]); } /** 输出: 第一种遍历打印&gt;&gt;&gt;&gt;&gt; 张三 第一种遍历打印&gt;&gt;&gt;&gt;&gt; 李四 第一种遍历打印&gt;&gt;&gt;&gt;&gt; 王伟 第一种遍历打印&gt;&gt;&gt;&gt;&gt; 刘想 **/ //第二种遍历数组 for (String item:studentNames) { System.out.println(&quot;第二种遍历打印 ---&gt;&quot; + item); } /** 输出: 第二种遍历打印 ---&gt;张三 第二种遍历打印 ---&gt;李四 第二种遍历打印 ---&gt;王伟 第二种遍历打印 ---&gt;刘想 **/ 遍历二维数组 String[][] args = {{"张三","李四","王伟","刘想"},{"100","200","300","300"}}; //第一种遍历数组 for (int i = 0; i &lt; args.length; i++){ for (int j = 0; j &lt; args[i].length; j++){ System.out.println(&quot;第一种遍历: &quot;+i+&quot;-&quot;+j+&quot; &gt;&quot;+ args[i][j]); } } /** 输出: 第一种遍历: 0-0 &gt;张三 第一种遍历: 0-1 &gt;李四 第一种遍历: 0-2 &gt;王伟 第一种遍历: 0-3 &gt;刘想 第一种遍历: 1-0 &gt;900 第一种遍历: 1-1 &gt;200 第一种遍历: 1-2 &gt;300 第一种遍历: 1-3 &gt;300 **/ //第二种遍历数组 for (String[] item:args) { for (String value: item){ System.out.println(&quot;第二种遍历打印 ---&gt;&quot; + value); } } /** 输出: 第二种遍历打印 ---&gt;张三 第二种遍历打印 ---&gt;李四 第二种遍历打印 ---&gt;王伟 第二种遍历打印 ---&gt;刘想 第二种遍历打印 ---&gt;900 第二种遍历打印 ---&gt;200 第二种遍历打印 ---&gt;300 第二种遍历打印 ---&gt;300 **/ 1.4.2 数组填充(fill)语法 // 把数组所有元素初始化为:value Arrays.fill(数据类型[] 数组变量名, value) // 把数组从索引startIndex(包括)开始到endIndex(不包括)内的所有元素初始化为:value Arrays.fill(数据类型[] 数组变量名, startIndex,endIndex,value) 实例 public static void testFill(){ // 填充数据 Arrays.fill(数据类型[] 数组变量名, value) int[] number = new int[5]; Arrays.fill(number,10); System.out.println(Arrays.toString(number)); // 输出: [10, 10, 10, 10, 10] int[] number2 = new int[5]; Arrays.fill(number2,0,3,6); System.out.println(Arrays.toString(number2)); // 输出: [6, 6, 6, 0, 0] } 1.4.3 数组排序(sort)int[] arr = {23,90,72,37,662,12}; System.out.println(Arrays.toString(arr)); Arrays.sort(arr); System.out.println(&quot;排序后:&quot;+ Arrays.toString(arr)); //输出: 排序后:[12, 23, 37, 72, 90, 662] 1.4.4 数组复制(copyOf、copyOfRange)int[] number = {23, 90, 72, 37, 662, 12, 239, 234}; int[] number1 = Arrays.copyOf(number, 5); System.out.println(Arrays.toString(number1)); //输出:[23, 90, 72, 37, 662] int[] number2 = Arrays.copyOfRange(number,3,6); System.out.println(Arrays.toString(number2)); //输出:[37, 662, 12]]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基础篇-原始数据类型及运算]]></title>
    <url>%2F2019%2F10%2F12%2Fjava-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.变量和常量1.1 关键字关键字不能作为变量名使用,以下表格中是java中的关键字列表 true、false、null不是关键字，是保留字，但是仍然不能用于命名标识符。保留字是为Java预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 1.2 变量1.2.1 变量声明单一变量声明① 先声明后赋值: 变量类型 变量名 实例 String studentName; studentName = &quot;小明&quot;; ② 声明及赋值: String studentName = &quot;小明&quot;; 多个变量声明// 只声明 String studentName, className; // 声明及赋值 String studentName = &quot;小明&quot;, className =&quot;三年级&quot;; 1.3 常量常量分为字面常量和字符常量两种。 字面常量：指的是如123、12.34、‘m’、true这样字面上本身就是一个固定值的数据。 字符常量：指的是代表一个固定值的标识符。使用字符常量需要在程序中先声明后使用。 1.3.1 常量声明声明字符常量的语法如下。 final 常量类型 常量标识符=常量值； ① 声明及赋值: //声明一个float类型常量，并初始化为3.14 final float PI = 3.14F; //声明一个整型常量，并初始化为24 final int STUENT_NUMBER = 24; ② 先声明后赋值: final float PI; //声明一个float类型常量 final int STUENT_NUMBER; //声明一个整型常量 PI = 3.14F; //初始化为3.14 STUENT_NUMBER = 24; //初始化为24 初始化以后，就不允许再在程序中对这些常量进行重新赋值，即不允许改变常量的值。 1.3.2 批量声明如果需要声明多个同一类型的常量，可以使用下面的语法： final常量类型 常量标识符1,常量标识符2,常量标识符3，…; final常量类型 常量标识符1=常量值1,常量标识符2=常量值2,常量标识符3=常量值3; 实例 //声明三个float类型的变量 final float PI，PRICE，WEIGHT; //声明三个float类型的变量，同时进行初始化 final float PI=3.14F,price=13.86F,WEIGHT=86.32F; 1.4 命名规则 一个标识符可以由几个单词连接而成，以表明它所代表的含义，如applePrice。 如果是类名，每个单词的首字母都要大写，其他字母则小写，如StudentInfo。 如果是方法名或者变量名，第一个单词的首字母小写，其他单词的首字母都要大写，如getStudentInfo()、studentName。 如果是常量，所有单词的所有字母全部大写，如果由多个单词组成，通常情况下单词之间用下画线“_”分隔，如PI、MAX_VALUE。 如果是包名，所有单词的所有字母全部小写，如examples.chapter02。 2.数据类型 2.1 整数类型整数类型取值范围 byte age = 18; short number = 2300; long account = 8172651756L; 在为long型常量或变量赋值时，需要在所赋值的后面加上一个字母”L”（或小写”l”），说明所赋的值为long型。如果所赋的值未超出int型的取值范围，也可以省略字母”L”（或小写”l”) //所赋的值超出了int型的取值范围，必须在后面加上字母“L” long account = 3124567893L; //所赋的值未超出int型的取值范围，可以在后面加上字母“L” long account = 31245678L; //所赋的值未超出int型的取值范围，可以省略字母“L” long account = 31245678; // !但是下面的这种赋值方式是错误的。 long account = 3124567893; //所赋的值超出了int型的取值范围，但是没有在后面加上字母“L” 2.2 浮点类型浮点类型取值范围 如果要声明一个用来保存小数的变量，必须使用浮点类型; //声明一个float类型的变量，并赋值 float price = 326.85F; //声明一个double类型的变量，并赋值 double height = 3836.8; double height = 3836.8D; 在默认情况下，小数都被看作double型。若使用float型小数，则需要在其值后面添加F或f,否则编译时，会提示错误。因为不加上字母“F”或小写“f”时，默认的数值为double类型，把double类型的数值赋给float类型的变量，是不正确的。而在为double类型变量赋值时，后面的字母“D”或者“d”,可加可不加。 2.3 字符类型字符类型（char）用于存储单个字符，占用16位（两个字节）的内存空间,在定义字符型变量时，要以单引号表示,如’a’、’#’、’3’。而双引号则表示一个字符串; //声明一个char类型的变量，用来存储性别信息 char gender = &#39;男&#39;; //声明一个char类型的变量，用来存储符号&#39;*&#39; char star = &#39;*&#39;; //声明一个char类型的常量，用来存储圆周率符号&#39;π&#39; final char PI = &#39;π&#39;; 2.4 逻辑类型（布尔类型）声明逻辑类型常量或者变量，需要使用关键字 boolean, boolean falg = false; 3.数据类型转换数据类型级别与取值范围 3.1 自动（隐式）类型转换在对变量进行赋值时，如果是将低级数据类型（相对取值范围较小的数据类型）的数据，赋给高级数据类型（相对取值范围较大的数据类型）的变量，这时Java会自动完成从低级类型向高级类型的转换。在原始数据类型中，除了boolean类型外，其他数据均可参与算术运算。 实例 //定义float类型的变量，并赋值 float price = 36; //输出price变量的值：price=36.0 System.out.println(&quot;price=&quot;+price); 可以看出，因为相对于float类型来说，整数36为int型，属于低级数据类型，所以Java自动将其转换为float类型的36.0 将低类型的数据赋给高类型的变量时，Java会自动将低类型的数据转换为高类型的数据，然后赋值。 3.2 混合数据类型运算在不同类型的数据进行混合运算时，分为两种情况： 只有byte、short或char类型的数据。这种情况下，Java首先将byte或short或char类型转换为int类型，然后再参与运算，并且运算结果也是int型的 例如： public class Test3{ public static void main(String[] args){ byte byteVar = 68; //声明一个byte类型的字节变量 short shortVar = 873; //声明一个short类型的整型变量 char charVar = ‘a’; //声明一个char类型的字符变量 int value = byteVar + shortVar + charVar; System.out.println(“value = ” + value);//输出value的值：value=1038 } } 含有int、long、float或double型的数据。这种情况下，Java首先将所有低数据类型转换为表达式中数据类型最高的数据类型，然后再参与运算，并且运算结果也是表达式中最高的数据类型。 例如： public class Test4{ public static void main(String[] args){ //声明一个字节类型的变量 byte byteVar = 68; //声明一个int类型的变量 int intVar = 873; //声明一个float类型的变量 float floatVar = 128.5F; // 不同类型进行混合运算 double value = byteVar + intVar + floatVar; System.out.println(&quot;value = &quot; + value) // 输出:1069.5 } } 3.2 强制（显式）类型转换在对变量进行赋值时，如果是将高级数据类型的数据赋值给低级数据类型的变量，java 不会自动完成类型的转换，需要主动转换； // 定义int类型的变量，并赋值double类型的36.5 int count = 36.5; System.out.println(&quot;count=&quot;+count); 上述代码在编译时会提示错误，因为将高级类型的数据36.5赋给了低级类型的变量count。 可改为下面这种形式： //强制类型转换 int count = (int)36.5; //输出count变量的值：count=36 System.out.println(&quot;count=&quot;+count); 在上面的代码中，（int）显示为强制类型转换的语法，即在欲转换的数据或变量前面，用“（目的数据类型）”的形式，强制转换为括号中的目的数据类型。另外，在上面的示例中也可以看到，在进行强制类型转换时，进行了简单的截断而不是四舍五入（输出的是36，而不是37）。 4.运算符4.1 算术运算符 4.2 赋值运算符 4.3 关系运算符 4.4 位运算符 4.5 逻辑运算符 4.6 三元运算符逻辑表达式 ？ 表达式1（为true） : 表达式2 (为false) 4.7 运算符优先级]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务-Maven私服搭建(nexus3)和使用]]></title>
    <url>%2F2019%2F08%2F08%2Fmaven-nexus-build%2F</url>
    <content type="text"><![CDATA[1. 使用docker安装1.1 编写docker-compose.yml文件位置: /service 具体内容: version: &#39;3.1&#39; services: #服务名称:docker-compose exec 服务名称 nexus: restart: always image: sonatype/nexus3 #容器名称 container_name: nexus3 ports: - 8081:8081 volumes: # ${DATA_PATH} 变量信息，放在了.env 里 - ${DATA_PATH}/nexus:/nexus-data 1.2 编写.env 配置文件文件位置: /service 具体内容: #服务数据目录 DATA_PATH=/service 1.3 创建目录创建对应的服务目录:/service/nexus,用来保存nexus服务的相关数据信息，并设置权限为可读写 # 创建目录 root@hui-X555LD /service » mkdir nexus # 设置权限 root@hui-X555LD /service » chmod 777 nexus 目录信息总览: root@hui-X555LD /service » pwd /service root@hui-X555LD /service » ls -la 总用量 20 drwxrwxrwx 3 root root 4096 11月 23 23:23 . drwxr-xr-x 25 root root 4096 11月 23 23:10 .. -rw-r--r-- 1 root root 189 11月 23 23:10 docker-compose.yml -rwxrwxrwx 1 root root 39 11月 23 23:10 .env drwxrwxrwx 15 root root 4096 11月 23 23:18 nexus 2. 启动nexus3 @注意: 默认密码不是admin123,而是在容器中的/nexus-data/admin.password文件中 2.1 找密码# 进入服务目录 root@hui-X555LD ~ » cd /service # 进入nexus服务容器中 root@hui-X555LD /service » docker-compose exec nexus bash # 在容器中查看密码 bash-4.4$ cat /nexus-data/admin.password # 密码 2f3ab5c2-ea5c-40b5-8677-1fce929687cb 登录之后，根据引导，可以设置新密码。 3. 使用nexus33.1 第一步:修改maven的配置文件在maven的配置文件(settings.xml)中，servers 节点下添加以下代码 &lt;servers&gt; ... &lt;!-- 个人私服开始节点 --&gt; &lt;server&gt; &lt;!-- 注意:pom.xml中的id要和这个一致！！ --&gt; &lt;id&gt;self-nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;self-nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;!-- 个人私服结束节点 --&gt; &lt;/servers&gt; 3.2 第二步:修改项目pom.xml文件修改项目中pom.xml文件，添加节点distributionManagement，代码如下: &lt;!-- 个人私服配置 -开始节点 --&gt; &lt;!-- id名称必须要与 maven settings.xml 中 Servers 配置的ID名称保持一致--&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;self-nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;!-- 这个地址是nexus3的服务地址--&gt; &lt;url&gt;http://192.168.0.110:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;self-nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;!-- 这个地址是nexus3的服务地址--&gt; &lt;url&gt;http://192.168.0.110:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;!-- 个人私服配置 -结束节点--&gt; @注意: repository节点和snapshotRepository节点下的id名称必须要与maven的配置文件(settings.xml)中的server下配置的id名称保持一致 4. 把中央仓库的依赖同步到私服中如果所有的依赖都从中央仓库下载，在一些不能联外网或者网络差的情况下，势必会影响开发，最好的解决方法是从私服上下载； 4.1 下载依赖包的流程: 4.2 开始配置 第一步:修改maven的配置文件中的servers在maven的配置文件(settings.xml)中，servers 节点下新增一个server,代码如下: &lt;servers&gt; ... &lt;!-- 个人私服开始节点 --&gt; &lt;server&gt; &lt;!-- 注意:pom.xml中的id要和这个一致！！ --&gt; &lt;id&gt;self-nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;self-nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;!-- 新增节点:maven-public--&gt; &lt;server&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;!-- 个人私服结束节点 --&gt; &lt;/servers&gt; 第二步:修改maven的配置文件中的mirrors &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;maven-public&lt;/name&gt; &lt;url&gt;http://192.168.0.114:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 第三步:修改maven的配置文件中的profiles &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://192.168.0.114:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://192.168.0.114:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; 最后一步: 删除本地仓库代码，重新下载 本地仓库一般位置在: /Users/xx/.m2/repository 效果图:]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx-限流(防恶意请求)]]></title>
    <url>%2F2019%2F08%2F07%2Fnginx-limit%2F</url>
    <content type="text"><![CDATA[1. 限流算法1.1 漏桶算法以固定速率从桶中流出水滴，以任意速率往桶中放入水滴，桶容量大小是不会发生改变的。 流入：以任意速率往桶中放入水滴。 流出：以固定速率从桶中流出水滴。 水滴：是唯一不重复的标识。 因为桶中的容量是固定的，如果流入水滴的速率&gt;流出的水滴速率，桶中的水滴可能会溢出。那么溢出的水滴请求都是拒绝访问的，或者直接调用服务降级方法 1.2 令牌桶算法 令牌以固定速率产生，并缓存到令牌桶中； 令牌桶放满时，多余的令牌被丢弃； 请求要消耗等比例的令牌才能被处理； 令牌不够时，请求被缓存。 相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的 从作用上来说，漏桶和令牌桶算法最明显的区别就是是否允许突发流量(burst)的处理，漏桶算法能够强行限制数据的实时传输（处理）速率，对突发流量不做额外处理；而令牌桶算法能够在限制数据的平均传输速率的同时允许某种程度的突发传输。 2. 限速使用nginx可以通过limit_conn_zone 和limit_req_zone两个组件来对客户端访问目录和文件的访问频率和次数进行限制，另外还可以善用进行服务安全加固，两个模块都能够对客户端访问进行限制。能够对 CC攻击、DDOS攻击等此类进行有效的防御。 2.1 示例http { # 定义一个名称为one内存区域大小为10m,表示请求的速率是1秒10个请求。 limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; # 定义 按IP配置内存区域zone的大小为10m: limit_conn_zone $binary_remote_addr zone=perip_conn:10m; # 定义 按server配置一个连接 zone limit_conn_zone $server_name zone=perserver_conn:100m; } # 负载均衡配置 upstream server_list{ server 192.168.40.11:8000 max_fails=3 fail_timeout=10s weight=50; server 192.168.40.12:8000 max_fails=3 fail_timeout=10s weight=100; server 192.168.40.13:8000 max_fails=3 fail_timeout=10s weight=100; keepalive 1000; } server { listen 8887; server_name 127.0.0.1; access_log /var/log/nginx/sz_proxy_access.log main; location / { # 使用one(与上面limit_req_zone，的name一致)区域配置限制，burst队列长度为100,nodelay:是否抛出503 limit_req zone=one burst=100 nodelay; # 限制同一个IP同一时间来源的连接数:10个 limit_conn perip_conn 10; # 限制同一个虚拟服务器同一时的总连接数 limit_conn perserver_conn 2000; # 限制速度 # limit_rate 1k; proxy_buffer_size 64k; proxy_buffers 32 32k; proxy_busy_buffers_size 128k; proxy_set_header Connection &quot;Keep-Alive&quot;; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_intercept_errors on; proxy_pass http://server_list/; } # 以上限制，超出后会报503，以下代码会把把503转成200，并返回固定的错误页面 error_page 503 =200 /success.html; location = /success.html { root /data/web/test/www/; index error.html; } } 2.2 示例解析2.2.1 http 配置段1. limit_req_zone语法 limit_req_zone $binary_remote_addr zone=one:?m rate=?r/s; # 限速配置: 设置一个名称为one内存区域大小为10m,表示请求的速率是1秒10个请求。 limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; 第一个参数key: $binary_remote_addr 表示远程的ip地址，当此nginx前方还存在代理时，需进行处理。 第二个参数zone: 定义共享内存区来存储访问信息，1M能存储16000 IP地址的访问信息，10M可以存储16W个IP地址访问信息。zone=one:10m表示生成一个大小为10M，名字为one的内存区域 第三个参数rate : rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次 当单位设置成60r/m时，并不能达到限速1分钟60次的效果，它等同于1r/s 2. limit_conn_zone语法 imit_conn_zone $variable zone=name:size; 参数说明: $variable: 定义的键，要限流的维度,[$binary_remote_addr:同一客户端IP，$server_name:限制同一server最大并发数] size: 定义各个键共享内存空间大小 name: zone名称 # 按IP配置内存区域zone的大小为10m: limit_conn_zone $binary_remote_addr zone=perip_conn:10m; # 按server配置一个连接 zone limit_conn_zone $server_name zone=perserver_conn:100m; 2.2.2 server 配置段1. limit_reqlimit_req zone=one burst=100 nodelay; zone=one : 设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应 burst=100 : 表示请求队列的长度 nodelay : 表示不延时 2. limit_conn # 限制同一个IP同一时间来源的连接数:10个 limit_conn perip_conn 10; # 限制同一个虚拟服务器同一时的总连接数 limit_conn perserver_conn 2000; 3.limit_rate 限速# 从下载指定的文件大小(1M)之后开始限速 limit_rate_after 1m; # 限制请求资源 limit_rate 1k; 2.3 为什么使用$binary_remote_addr，而不使用$remote_addr原因是，两个变量的长度不一样。 $remote_addr变量的长度为7字节到15字节，而存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。 $binary_remote_addr变量的长度是固定的4字节，存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。]]></content>
      <categories>
        <category>服务使用</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-mysql8问题归纳]]></title>
    <url>%2F2019%2F08%2F03%2Fphp-mysql8-bug%2F</url>
    <content type="text"><![CDATA[报错：PDO::__construct(): Server sent charset (255) unknown to the client. Please, report to the developers根据网上资料显示，是由于Mysql8.0将默认的字符集改为了utfmb4，因此和客户端（不仅仅是PHP）的通信无法识别，我们需要更改my.cnf来指定字符集。 [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci character-set-server = utf8 报错：PDO::__construct(): The server requested authentication method unknown to the client [caching_sha2_password]根据网上资料显示，是由于用户身份认证的加密方式不兼容导致的，mysql8.0中默认方式为caching_sha2_password，引起老版本兼容性问题，老版本加密方式为mysql_native_password。 新建用老版加密方式初始化密码的用户即可： CREATE USER username@localhost identified with mysql_native_password by &#39;password&#39;;]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-创建自己的镜像]]></title>
    <url>%2F2019%2F05%2F21%2Fcreate-self-Image%2F</url>
    <content type="text"><![CDATA[1.创建一个简单的Node.js 应用镜像1.1 创建一个本地目录 makedir helloword 1.2 编写应用代码server.js,代码保存到 “helloword/“文件下var http = require(&#39;http&#39;); var handleRequest = function(request, response) { console.log(&#39;Received request for URL: &#39; + request.url); response.writeHead(200); response.end(&#39;Hello World!&#39;); }; var www = http.createServer(handleRequest); www.listen(8080); 1.3 编写Dockerfile文件 FROM node:4.4 EXPOSE 8080 COPY server.js . CMD node server.js 1.4 创建新镜像，给它起一个名字 使用命令: docker build [OPTIONS] PATH | URL | ---tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 ➜ docker build -t liuqh/hellonde:v1 . Sending build context to Docker daemon 3.072kB Step 1/4 : FROM node:4.4 4.4: Pulling from library/node 357ea8c3d80b: Pull complete 52befadefd24: Pull complete 3c0732d5313c: Pull complete ceb711c7e301: Pull complete 868b1d0e2aad: Pull complete 3a438db159a5: Pull complete Digest: sha256:7b657ccf24be2c8bab969b215e6853bc87a0d2fbe0896d5305cc87122f5360d0 Status: Downloaded newer image for node:4.4 ---&gt; 93b396996a16 Step 2/4 : EXPOSE 8080 ---&gt; Running in a7798374f671 Removing intermediate container a7798374f671 ---&gt; 0c394b4854fa Step 3/4 : COPY server.js . ---&gt; cb0dd1a3ffed Step 4/4 : CMD node server.js ---&gt; Running in 7d1ec9e39d79 Removing intermediate container 7d1ec9e39d79 ---&gt; db149c04d3fa Successfully built db149c04d3fa Successfully tagged liuqh/hellonde:v1 注意命令后面的圆点 1.5 查看本地镜像，会发现自己建议的镜像➜ docker images REPOSITORY TAG IMAGE ID CREATED SIZE liuqh/hellonde v1 db149c04d3fa 12 seconds ago 648MB laradock_nginx latest fb8945ae0cb8 11 days ago 27.6MB 1.6 运行容器➜ docker run -d -p 8080:8080 --name hello-word liuqh/hellonde:v1 f18a619dafb3e333cd3592ce5e8e7b373d622c81fe968558307970f22cb1a92a 1.7 验证在浏览器输入 http://127.0.0.1:8080 2.镜像上传至dockerHub前提是有自己的帐号，没有请去注册。 2.1 将容器commit 成镜像 使用命令 docker commit /[:] ➜ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f18a619dafb3 liuqh/hellonde:v1 &quot;/bin/sh -c &#39;node se…&quot; 3 seconds ago Up 2 seconds 0.0.0.0:8080-&gt;8080/tcp hello-word ➜ docker commit f18a619dafb3 liuqinghui/helloword sha256:efb1301fb0fdd607b4e0ff2c34e3d36c890c665a14abef1bf82316ec05938491 如果是已经存在的镜像则使用:docker tag &lt;existing-image&gt; &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;] 这里的不指定就是latest。 2.2 push 镜像到docker hub的仓库# 登录 docker hub ➜ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one. Username: liuqinghui Password: Login Succeeded # docker push 镜像到docker hub 的仓库 ➜ docker push liuqinghui/helloword:v1 The push refers to repository [docker.io/liuqinghui/helloword] 99393065d499: Pushed 20a6f9d228c0: Mounted from library/node 80c332ac5101: Mounted from library/node 04dc8c446a38: Mounted from library/node 1050aff7cfff: Mounted from library/node 66d8e5ee400c: Mounted from library/node 2f71b45e4e25: Mounted from library/node v1: digest: sha256:b567d7fbcfe5d1987d2bd6fd8f8633f11ca32c666868cb6366a5d0ae3380a9fe size: 1794]]></content>
      <categories>
        <category>容器管理</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-sql优化]]></title>
    <url>%2F2019%2F04%2F15%2FSQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1 优化步骤1.1 使用show status 查看各种SQL的执行频率show [session|global] status 可以根据需要加上参数&quot;session&quot; 或者&quot;global&quot; 来显示 session 级(当前连接)的统计结果和 global 级(自数据库上次启动至今)的统计结果。如果不写，默认使 用参数是&quot;session&quot;。 1.1.1 查看CRUD执行情况# 查看自数据库上次启动至今的统计结果 mysql&gt; show global status like &#39;Com_%&#39;; +---------------------------+-------+ | Variable_name | Value | +---------------------------+-------+ .... | Com_insert | 8877 | | Com_select | 438 | | Com_update | 4138 | | Com_delete | 126 | .... +---------------------------+-------+ 142 rows in set (0.00 sec) Com_xxx 表示每个 xxx 语句执行的次数,通常比较关心的是以上几个统计参数 Com_select:执行 select 操作的次数，一次查询只累加 1。 Com_insert:执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update:执行 UPDATE 操作的次数。 Com_update:执行 UPDATE 操作的次数。 上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。 mysql&gt; show global status like ‘Innodb_rows_%’; Innodb_rows_read:select 查询返回的行数。 Innodb_rows_inserted:执行 INSERT 操作插入的行数。 Innodb_rows_updated:执行 UPDATE 操作更新的行数。 Innodb_rows_deleted:执行 DELETE 操作删除的行数。 通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主 1.1.2 查看事务的执行情况对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况， 对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题 Com_commit: 事务提交的次数 Com_rollback: 事务回滚的次数 1.1.3 其他参数 Connections:试图连接 MySQL 服务器的次数 Uptime:服务器工作时间 Slow_queries:慢查询的次数 1.2 定位执行效率较低的 SQL 语句1.2.1 慢日志 慢查询日志相关参数 slow_query_log：是否开启慢查询日志，1表示开启，0表示关闭。 log_slow_queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log slow_query_log_file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。默认10s log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。 log_output：日志存储方式。log_output=&#39;FILE&#39;表示将日志存入文件，默认值是&#39;FILE&#39;。log_output=&#39;TABLE&#39;表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=&#39;FILE,TABLE&#39;。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。 1.3 explan分析SQL查看explan使用分析 2 索引使用MySQL 中索引的存储类型目前只有两种(BTREE 和 HASH)，具体和表的存储引擎相关: MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引;MEMORY/HEAP 存储引擎可以支持 HASH 和 BTREE 索引 2.1 索引类型2.1.1 普通索引-- 创建索引 CREATE INDEX index_name ON table(column(length)) -- 修改表结构的方式添加索引 ALTER TABLE table_name ADD INDEX index_name ON (column(length)) -- 删除索引 DROP INDEX index_name ON table 2.1.2 唯一索引-- 创建索引 REATE UNIQUE INDEX indexName ON table(column(length)) -- 修改表结构的方式添加索引 ALTER TABLE table_name ADD UNIQUE indexName ON (column(length)) 2.1.3 全文索引（FULLTEXT） MySQL允许在char、varchar、text类型上建立全文索引,MySQL5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引 MySQL 之全文索引 MYISAM-- 创建表的适合添加全文索引 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , `time` int(10) NULL DEFAULT NULL , PRIMARY KEY (`id`), FULLTEXT (content) ); -- 修改表结构添加全文索引 ALTER TABLE table_name ADD FULLTEXT index_content(content) -- 直接创建索引 CREATE FULLTEXT INDEX index_content ON table_name(content) InnoDb MySQL中的全文索引（InnoDB存储引擎） 2.1.4 联合索引(多列索引)-- 联合索引创建 create index indexName on table_name（column1，column2，..） 为了说明联合索引的使用，设: key a_b_c (a,b,c) 在and查询中-- 查询效率最高，索引全覆盖。 select * from test where a=? and b=? and c=? -- 索引覆盖a和b。 select * from test where a=? and b=?； -- 经过mysql的查询分析器的优化，索引覆盖a和b。 select * from test where b=? and a=?； -- 索引覆盖a select * from test where a=?；。 -- 没有a列，不走索引，索引失效 select * from test where b=? and c=?；。 -- 没有a列，不走索引，索引失效。 select * from test where c=?； 索引的最左匹配特性 在范围查询中-- 索引覆盖a和b，因b列是范围查询，因此c列不能走索引。 select * from test where a=? and b between ? and ? and c=?； -- a列走索引，因a列是范围查询，因此b列是无法使用索引。 select * from test where a between ? and ? and b=?； -- a列走索引，因a列是范围查询，b列是范围查询也不能使用索引。 select * from test where a between ? and ? and b between ? and ? and c=?； 索引查找遵循最左侧原则。但是遇到范围查询列之后的列索引失效。 在排序中-- a、b、c三列全覆盖索引，查询效率最高。 select * from test where a=? and b=? order by c； -- a、b列使用索引查找，因b列是范围查询，因此c列不能使用索引，会出现 file sort。 select * from test where a=? and b between ? and ? order by c； 如何设置多列索引顺序大部分采用经验法则来计算,但是针对特殊情况则不起作用，以下内容是由经验法则推演: mysql&gt; SELECT COUNT( DISTINCT staff_id ) / COUNT( * ) AS staff_id_selectivity, COUNT( DISTINCT customer_id ) / COUNT( * ) AS customer_id_selectivity, COUNT( * ) FROM payment; +-------------------------+----------------------+------------+ | staff_id_selectivity | customer_id_selectivity | COUNT( * ) | +-------------------------+----------------------+------------+ | 0.0001 | 0.0373 | 16049 | +-------------------------+----------------------+------------+ 1 row in set (0.12 sec) customer_id 选择性更高，所以索引顺序应该是:key indexName (customer_id,staff_id) 2.1.5 前缀索引当要索引的列字符很多时,索引则会很大且变慢。而前缀索引可以只索引列开始的部分字符串,节约索引空间,从而提高索引效率。 前缀索引长度计算前缀索引长度中的一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整的选择性(1),下面计算显示如何计算完整列的选择性 -- desc 字段为 text mysql&gt; SELECT COUNT( DISTINCT LEFT ( desc, 3 ) ) / count( * ) AS sel3, COUNT( DISTINCT LEFT ( desc, 6 ) ) / count( * ) AS sel6, COUNT( DISTINCT LEFT ( desc, 9 ) ) / count( * ) AS sel9, COUNT( DISTINCT LEFT ( desc, 12 ) ) / count( * ) AS sel12, COUNT( DISTINCT LEFT ( desc, 36 ) ) / count( * ) AS sel36 FROM study; +--------+--------+--------+--------+--------+ | sel3 | sel6 | sel9 | sel12 | sel36 | +--------+--------+--------+--------+--------+ | 0.1585 | 0.3432 | 0.4091 | 0.4304 | 0.4401 | +--------+--------+--------+--------+--------+ 1 row in set (0.02 sec) -- 建立前缀索引 alter table study add key (desc(12)) 由上述可以看出，当达到前缀长度12，在增加前缀长度，选择性提升的幅度已经很小了。所以可以设置key的长度为12 前缀索引优点 前缀索引是一种能使索引更小、更快的有效办法; 前缀索引缺点 无法使用前缀索引做order by 和 group by, 无法使用前缀索引覆盖扫描 2.2 使用到索引的场景 对于联合索引，只要查询的条件中用到了最左边的列，索引一般才会被使用（最左原则）。 对于使用 like 的查询，使用【n%】能用到索引，而【%n】不能用到索引。 对于大的文本进行搜索，使用全文索引而不用使用 like ‘%…%’ 对于column_name是索引，使用column_name is null将使用索引。 2.3 存在索引但不使用索引 如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引 如果使用 MEMORY/HEAP(存储引擎) 表并且 where 条件中不使用“=”进行索引列，那么 不会用到索引。heap 表只有在“=”的条件下才会使用索引 如果用 or 分割开的条件，如: A or B, 若A、B 中有一个没有索引，则不会使用到索引 如果是联合索引，在没有用到最左边列情况下，则不会使用索引。 如果使用 like ,是以%开始【%n】不能用到索引 如果列类型是字符串，那么查询时需要用把字符常量值用引号引起来，否则的话即便这个列上有索引,也不会使用。 -- 假如 number 字段有索引，并且是字符串字段 -- 会使用到索引 select * FROM study WHERE number= &#39;12&#39; -- 不会使用到索引 select * FROM study WHERE number= 12 如果where条件中使用表达式则也不会用到索引 -- 不会使用到索引 select * from test where id + 1 =7 -- 会使用到索引 select * from test where id=6 2.4 查看索引使用情况mysql&gt; show global status like &#39;handler_read%&#39;; +-----------------------+------------+ | Variable_name | Value | +-----------------------+------------+ | Handler_read_first | 2147391 | | Handler_read_key | 448430738 | | Handler_read_last | 14857 | | Handler_read_next | 1056940046 | | Handler_read_prev | 1753960 | | Handler_read_rnd | 46990892 | | Handler_read_rnd_next | 239392047 | +-----------------------+------------+ 7 rows in set (0.03 sec) Handler_read_key:代表了一个行被索引值读的 次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用 Handler_read_rnd_next:代表在数据文件中读下一行的请求数。如果正进行大量的表扫描，其值较高，则通常说明表索引不正确或写入的查询没有利用索引。（值越高就意味着查询运行低效，应建立索引补救） 更多内容查看:MySQL Handler 监控 3 MySQL优化特定类型的查询3.1 优化关联查询 确保ON或者USING子句中的列上有索引。在创建索引的时候需要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器的关联顺序是B、A，那么就不需要在B表的对应列上建索引。除非有其他理由，否则只需要在关联顺序的第二个表的对应列上创建索引，没有用的索引只会带来额外的负担。 确保任何的GROUP BY 和 ORDER BY 中的表达式只涉及一个表中的列，这样MySQL才有可能使用索引来优化这个过程。 当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。因为以前是普通关联的地方可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果等。 3.2 优化INSERT语句 如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语 句快(在一些情况中几倍)。下面是一次插入多值的一个例子: insert into test values(1,2),(1,3),(1,4)... 如果从不同客户插入很多行，能通过使用 INSERT DELAYED 语句得到更高的速度。 DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有 真正写入磁盘，这比每条语句分别插入要快的多;LOW_PRIORITY 刚好相反，在所有其 他用户对表的读写完后才进行插入。 将索引文件和数据文件分在不同的磁盘上存放(利用建表中的选项)。 如果进行批量插入，可以增加 bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用。 当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍。 3.3 优化GROUP BY 语句默认情况下，MySQL 对所有 GROUP BY col1，col2….的字段进行排序。这与在查询中指定 ORDER BY col1，col2…类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则 对 MySQL 的实际执行性能没有什么影响。 如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序，如下面的例子: -- 未指定 ORDER BY NULL mysql&gt; EXPLAIN SELECT tfid,tfMedicalNum from ins_treatment_file GROUP BY tfName; +----+-------------+--------------------+------+---------------+------+---------+------+-------+---------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------------------+------+---------------+------+---------+------+-------+---------------------------------+ | 1 | SIMPLE | ins_treatment_file | ALL | NULL | NULL | NULL | NULL | 12133 | Using temporary; Using filesort | +----+-------------+--------------------+------+---------------+------+---------+------+-------+---------------------------------+ 1 row in set (0.01 sec) -- 指定 ORDER BY NULL mysql&gt; EXPLAIN SELECT tfid,tfMedicalNum from ins_treatment_file GROUP BY tfName ORDER BY NULL; +----+-------------+--------------------+------+---------------+------+---------+------+-------+-----------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+--------------------+------+---------------+------+---------+------+-------+-----------------+ | 1 | SIMPLE | ins_treatment_file | ALL | NULL | NULL | NULL | NULL | 12133 | Using temporary | +----+-------------+--------------------+------+---------------+------+---------+------+-------+-----------------+ 1 row in set (0.02 sec) 从上面的例子可以看出第一个 SQL 语句需要进行“filesort”，而第二个 SQL 由于 ORDER BY NULL 不需要进行“filesort”，而 filesort 往往非常耗费时间 3.4 优化ORDER BY 语句在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。 WHERE 条件和 ORDER BY 使用相同的索引 ORDER BY 的顺序和索引顺序相同(联合索引)， ORDER BY 的字段都是升序或者都是降序。 -- 可以使用索引Sql SELECT * FROM t1 ORDER BY key_part1,key_part2,... ; SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC; SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC; -- 以下几种情况下则不使用索引 -- 原因:order by 的字段混合 ASC 和 DESC SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; -- 原因:用于查询行的关键字与 ORDER BY 中所使用的不相同 SELECT * FROM t1 WHERE key2=constant ORDER BY key1; -- 原因: 对不同的关键字使用 ORDER BY SELECT * FROM t1 ORDER BY key1, key2; 3.5 优化LIMIT 分页在系统中需要进行分页操作的时候，我们通常会使用LIMIT 加上偏移量的方法实现，同时加上合适的ORDER BY 子句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。 但是有一个非常常见又头疼的问题就是，在偏移量非常大的时候，例如可能是 LIMIT 10000,20这样的查询，此时MySQL需要查询10020 条记录并只返回最后的20条，这样的代价非常高。 如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。 优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作最后返回所需要的列。对于偏移量很大的时候，这样做的效率会提高很多。考虑下面这个查询： SELECT file_id, description FROM sakila.film ORDER BY title LIMTI 50, 5; 如果这个表很大，最好可以将这个查询修改成下面这个样子： SELECT flim.file_id, flim.description FROM sakila.film INNER JOIN ( SELECT film_id FROM sakila.film ORDER BY title LIMIT 50,5 ) AS flim USING(film_id) 这里的“延迟关联”将大大提高查询效率，它让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询所需要的所有列。这个技术也可以用于优化关联查询中的LIMIT子句。 还有另外一种优化的方法，就是使用应用程序记录上次数据的位置，在下次查询时就可以直接从该记录的位置开始扫描，这样就避免了使用OFFSET。使用这样的方法可以将其变成一个范围查询，无论翻页到多后面，其性能都会很好。 3.6 优化 OR 条件对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引; 如果没有索引，则应该考虑增加索引 如: A or B, 若A、B 中有一个没有索引，则不会使用到索引]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyISAM和InnoDB之存储结构对比]]></title>
    <url>%2F2019%2F04%2F03%2Finnodb-storage%2F</url>
    <content type="text"><![CDATA[1. 什么是存储引擎MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。 MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿来进行开发。存储引擎是MySQL区别于其他数据库的一个最重要特性。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。注意: 需要特别注意的是，存储引擎是基于表的，而不是数据库。 2. MyISAMMyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些在线分析处理(OLAP)数据库应用。在MySQL 5.5.8版本之前MyISAM存储引擎是默认的存储引擎（除Windows版本外）。数据库系统与文件系统很大的一个不同之处在于对事务的支持，然而MyISAM存储引擎是不支持事务的。此外，MyISAM存储引擎的另一个与众不同的地方是: 只缓存其索引文件，数据文件的缓存交由操作系统本身来完成，这与其他使用LRU算法缓存数据的大部分数据库大不相同。 2.1 存储结构每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是: .frm (存储表定义); .MYD (MYData，存储数据); .MYI (MYIndex，存储索引)。 数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。 2.2 存储空间1.可被压缩:可以通过使用myisampack工具来进一步压缩数据文件，因为myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的，也可以通过myisampack来解压数据文件。 2.存储大小: MySQL 5.0版本之前: MyISAM默认支持的表大小为4GB，如果需要支持大于4GB的MyISAM表时，则需要制定MAX_ROWS和AVG_ROW_LENGTH属性。 MySQL 5.0版本开始: MyISAM默认支持256TB的单表数据 2.3 存储格式MyISAM的表支持3种不同的存储格式，分别是：静态（固定长度）表、动态表、压缩表。 静态表:静态表是默认的存储格式。静态表的数据在存储时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。如果需要保存的内容后面本来就带有空格，那么在返回结果的时候也会被去掉。 优缺点: 静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优缺点如下: 优点: 存储非常迅速，容易缓存，出现故障容易恢复； 缺点: 占用的空间通常比动态表多。 动态表:动态表中包含变长字段，记录不是固定长度的。 优缺点: 优点: 占用的空间相对较少 缺点: 频繁地更新和删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk-r命令来改善性能，并且在出现故障时恢复相对比较困难 压缩表压缩表由myisampack工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所以只有非常小的访问开支。使用myisampack工具压缩后的表是只读的。 2.4 主要特征 不支持事物 不支持行级锁 不支持外键 支持全文索引 锁机制是:表锁 数据可被压缩 3.InnoDBInnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。 3.1 存储结构InnoDB存储引擎的逻辑存储结构和Oracle大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block）。 表空间表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。在默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都存放在这个表空间内。如果启用了参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。@注意: 如果启用了innodb_file_per_table的参数，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲页。其他的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。这同时也说明了另一个问题：即使在启用了参数innodb_file_per_table之后，共享表空间还是会不断地增加其大小 段表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。 结合图1 InnoDB逻辑存储结构说明段: 数据段: 为B+树的叶子节点（图1中的Leaf node segment）。 索引段: 为B+树的非索引节点（图1中的Non-leaf node segment）。 回滚段: 图1中的Rollback segment 在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这和Oracle数据库中的自动段空间管理（ASSM）类似，从一定程度上简化了DBA对于段的管理。 区区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。 InnoDB 1.2.x版本新增了参数innodb_page_size，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。这时区中页的数量同样也为256、128。总之，不论页的大小怎么变化，区的大小总是为1M。 这里还有这样一个问题：在用户启用了参数innodb_file_per_talbe后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页（fragment page）来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。 页同大多数数据库一样，InnoDB有页（Page）的概念（也可以称为块），页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。而从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。 在InnoDB存储引擎中，常见的页类型有: 数据页（B-tree Node） undo页（undo Log Page） 系统页（System Page） 事务数据页（Transaction system Page） 插入缓冲位图页（Insert Buffer Bitmap） 插入缓冲空闲列表页（Insert Buffer Free List） 未压缩的二进制大对象页（Uncompressed BLOB Page） 压缩的二进制大对象页（compressed BLOB Page） 行InnoDB存储引擎是面向列的（row-oriented），也就说数据是按行进行存放的。每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2-200行的记录，即7992行记录。 3.2 InnoDB 行记录格式InnoDB存储引擎和大多数数据库一样（如Oracle和Microsoft SQL Server数据库），记录是以行的形式存储的。这意味着页中保存着表中一行行的数据。 行格式分类 InnoDB 1.0.x版本之前: 提供了 Compact 和 Redundant 两种格式来存放行记录数据 InnoDB 1.0.x版本之后，引入了新的两种行记录格式：Compressed 和 Dynamic。 可以通过命令show table status like &#39;table_name&#39; 查看当前表使用的行格式，如下: mysql&gt; show table status like &#39;hb_user&#39;\G; *************************** 1. row *************************** Name: hb_user Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 398 Avg_row_length: 288 Data_length: 114688 Max_data_length: 0 Index_length: 131072 Data_free: 0 Auto_increment: NULL Create_time: 2019-10-27 04:00:47 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 用户表 1 row in set (0.00 sec) ERROR: No query specified CompactCompact行记录是在MySQL 5.0中引入的，其设计目标是高效地存储数据。简单来说，一个页中存放的行数据越多，其性能就越高。 Compact行记录的存储方式如下: Compact记录头信息: Compact特点整理: 首部: Compact行记录格式的首部是一个非NULL变长字段长度列表； 变长字段长度:若列的长度小于255字节，用1字节表示;若大于255个字节，用2字节表示。(变长字段的长度最大不可以超过2字节) NULL标志位:该位指示了该行数据中是否有NULL值，有则用1表示。该部分所占的字节应该为1字节 不管是CHAR类型还是VARCHAR类型，NULL在Compact存储格式下都不占用存储空间。 记录头信息: 固定占用5字节（40位） 列部分就是实际存储每个列的数据 每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小 InnoDB表没有定义主键，每行还会增加一个6字节的rowid列 RedundantRedundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。 Redundant行记录的存储方式如下: Redundant记录头信息: Redundant特点整理: 首部 : Redundant行记录格式的首部是一个字段长度偏移列表。 字段长度偏移列表 : 若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示 记录头 : Redundant行记录格式的记录头占用6字节（48位） NULL: 对于VARCHAR类型的NULL值同样不占用存储空间，但是CHAR类型的NULL值会占用存储空间。 Compressed 和 Dynamic 对于存放在 BLOB 中的数据，完全采用行溢出数据存放 Compressed 存放的行数据会采用 zlib 算法进行压缩 查看表行格式# 查看当前版本 mysql&gt; select version(); +-----------+ | version() | +-----------+ | 8.0.18 | +-----------+ 1 row in set (0.00 sec) # 查看用户表使用的行格式 mysql&gt; show table status like &#39;hb_user&#39;\G; *************************** 1. row *************************** Name: hb_user Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 398 Avg_row_length: 288 Data_length: 114688 Max_data_length: 0 Index_length: 131072 Data_free: 0 Auto_increment: NULL Create_time: 2019-10-27 04:00:47 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 用户账号表 1 row in set (0.06 sec) 其中row_format属性表示当前所使用的行记录结构类型 指定表行格式create Table test ( t1 varchar(10), t2 varchar(10) ) engine=INNODB ROW_FORMAT=COMPACT]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx-配置调优]]></title>
    <url>%2F2019%2F03%2F28%2Fnginx-optimization%2F</url>
    <content type="text"><![CDATA[1. nginx.conf 配置文件#运行的用户 user www-data; pid /var/run/nginx.pid; #定义了nginx对外提供web服务时的worder进程数，CPU核的数量、存储数据的硬盘数量及负载模式 worker_processes auto; #更改worker进程的最大打开文件数限制,比&#39;ulimit -a&#39;多。解决&quot;too many open files&quot; worker_rlimit_nofile 100000; events { #worker进程同时打开的最大连接数 worker_connections 65536; #当收到一个新连接通知后接受尽可能多的连接 multi_accept on; #设置用于复用客户端线程的轮询方法,epoll需要linux2.6+ use epoll; } http { access_log off; #设置nginx是否将存储访问日志。关闭这个选项可以让读取磁盘IO操作更快(aka,YOLO) error_log /var/log/nginx/error.log crit; #告诉nginx只能记录严重的错误 #HTTP和TCP优化 keepalive_timeout 10; #给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接 keepalive_requests 1024;#限制了一个 HTTP 长连接最多可以处理完成的最大请求数, 默认是 100。当连接处理完成的请求数达到最大请求数后，将关闭连接。 tcp_nopush on; #在一个数据包里发送所有头文件，而不一个接一个的发送 tcp_nodelay on; #nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。 #Buffers size优化 client_body_buffer_size 128k;#处理客户端缓冲区大小。 大多数客户端缓冲区都来自POST方法表单提交。128k通常是此设置的不错选择。 client_max_body_size 10m;#置最大body缓冲区大小。如果请求中的大小超过配置的值，则会将413（请求实体过大）错误返回给客户端。 不过浏览器无法正确显示413错误。 将大小设置为0将禁用对客户机请求正文大小的检查 client_header_buffer_size 1k; #处理客户端头大小。 默认情况下，1k通常是一个合理的选择。 large_client_header_buffers 4 4k; #设置客户端头的缓冲区的最大数量和大小。 4个报头与4k缓冲区应该足够了。 output_buffers 1 32k;#置用于从磁盘读取响应的缓冲区的数量和大小。 如果可能，客户端数据的传输将被推迟，直到Nginx至少具有要发送的数据的字节数的集合大小。零值禁止推迟数据传输。 postpone_output 1460;#指定Nginx发送给客户端最小的数值，如果可能的话，没有数据会发送，直到达到此值 #超时 client_header_timeout 10; #设置请求头超时时间，建议低 client_body_timeout 10; #请求体(各自)的超时时间 reset_timedout_connection on; #关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间 send_timeout 10; #指定客户端的响应超时时间 #静态资源服务 open_file_cache max=100000 inactive=20s; #打开缓存的同时也指定了缓存最大数目，以及缓存的时间 open_file_cache_valid 30s; #在open_file_cache中指定检测正确信息的间隔时间 open_file_cache_min_uses 2; #定义了open_file_cache中指令参数不活动时间期间里最小的文件数 open_file_cache_errors on; #指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件 #Gzip压缩内容 gzip on; #开启gzip压缩 gzip_disable &quot;msie6&quot;; #低版本兼容 gzip_proxied any; #允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求 gzip_static on; #告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源 gzip_min_length 1000; #设置对数据启用压缩的最少字节数 gzip_comp_level 6; #压缩级别,1-10越高越消耗CPU，但是压缩越好 gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; #设置需要压缩的数据格式 #其他优化 limit_conn_zone $binary_remote_addr zone=addr:5m; #设置用于保存各种key（比如当前连接数）的共享内存的参数。5m就是5兆字节，这个值应该被设置的足够大以存储（32K*5）32byte状态或者（16K*5）64byte状态。 limit_conn addr 100; #给定的key设置最大连接数。这里key是addr，我们设置的值是100，也就是说我们允许每一个IP地址最多同时打开有100个连接。 server_tokens off; #关闭nginx版本号 sendfile on; #sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile) default_type text/html; #设置文件默认MIME-type include /etc/nginx/mime.types; #只是一个在当前文件中包含另一个文件内容的指令。 include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } 2.nginx.pid文件2.1 什么是 var/run/nginx.pid文件? var/run这个目录包含描述系统启动以来系统信息的数据。此文件夹下的文件必须在启动过程初期清除（删除或归零）。程序可以在/var/run下有自己的子文件夹。原先放在/etc下的进程标识（PID）文件必须放在/var/run里面。PID文件的命名惯例是.pid。所以，nginx的PID文件名为/var/run/nginx.pid。 nginx.pid存放的是nginx的master进程的进程号。 2.2 nginx启动报错找不到nginx.pidnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory) [root@localhost nginx]# nginx -c /usr/local/nginx/conf/nginx.conf 3.Worker Processess 说明通常来说设置一个cpu核心对应一个worker processer，最多不超过4个，提高worker process的值是为了提高计算能力，但一般在越到cpu瓶颈前，你会遇到别的瓶颈(如网络问题)只有当你要处理大量静态文件的磁盘I/O时，worker进程是单线程的，所以这个读取文件的阻塞IO会降低CPU的处理速度，这是可以增加worker进程数量，其它情况是不需要的。 //一般设置为:auto # worker_processes auto; //如果你想手动设置，你可以使用以下命令行查找服务器的cpu线程数。 # grep ^processor /proc/cpuinfo | wc -l 4.Worker进程连接数优化(worker_connections)worker_connections选项设置每个worker进程一次可以处理的最大连接数。 默认情况下，worker连接限制为512，但系统可以处理比这值更多的连接。 适当的值可以通过测试得出。 系统的核心限制也可以通过使用ulimit找到 # ulimit -n 5.HTTP和TCP优化5.1 Keep Alive:减少浏览器重新连接的次数 keepalive_timeout和keepalive_requests 控制保持活动设置。 sendfile 优化Nginx提供文件系统的静态文件服务的性能，如logo。 tcp_nodelay 允许Nginx使TCP发送多个缓冲区作为单独的数据包。 tcp_nopush 通过激活TCP堆栈中的TCP_CORK选项来优化一次向下游发送的数据量。TCP_CORK阻塞数据，直到分组到达MSS，这等于MTU减去IP报头的40或60字节。 5.2 服务处于TIME_WAIT 状态的 TCP 连接数异常的原因 keepalive_requests 参数限制了一个 HTTP 长连接最多可以处理完成的最大请求数, 默认是 100。当连接处理完成的请求数达到最大请求数后，将关闭连接 而我并没有配置 keepalive_requests，所以，就是使用的默认数 100，即一个长连接只能处理一百个请求，然后 Nginx 就就会主动关闭连接，使大量连接处于 TIME_WAIT 状态 6. Buffers size优化调整缓冲区大小可能是有利的。 如果缓冲区大小太低，那么Nginx将写入一个临时文件。 这将导致过多的磁盘I/O。 client_body_buffer_size 处理客户端缓冲区大小。 大多数客户端缓冲区都来自POST方法表单提交。 128k通常是此设置的不错选择。 client_max_body_size 设置最大body缓冲区大小。 如果请求中的大小超过配置的值，则会将413（请求实体过大）错误返回给客户端。 不过浏览器无法正确显示413错误。 将大小设置为0将禁用对客户机请求正文大小的检查。 client_header_buffer_size 处理客户端头大小。 默认情况下，1k通常是一个合理的选择。 large_client_header_buffers 设置客户端头的缓冲区的最大数量和大小。 4个报头与4k缓冲区应该足够了。 output_buffers 设置用于从磁盘读取响应的缓冲区的数量和大小。 如果可能，客户端数据的传输将被推迟，直到Nginx至少具有要发送的数据的字节数的集合大小。 零值禁止推迟数据传输。 7. 超时设置超时设置还可以大幅提高性能。 client_body_timeout 指令设置服务器等待客户端完成发送body的最大时间。 client_header_timeout 指令设置服务器等待客户端完成发送header的最大时间。 sent_timeout 指定对客户端的响应超时。 此超时不适用于整个传输，而是仅应用于两个后续的客户端读取操作之间。 因此，如果客户端没有读取任何数据这段时间，那么Nginx关闭连接。 8.静态资源服务如果您的网站提供静态资源（如CSS/JavaScript/images），Nginx可以缓存这些文件很短的时间。 #告诉Nginx缓存1000个文件30秒，不包括在20秒内未被访问的任何文件 open_file_cache max=100000 inactive=20s; #在open_file_cache中指定检测正确信息的间隔时间 open_file_cache_valid 30s; #定义了open_file_cache中指令参数不活动时间期间里最小的文件数 open_file_cache_min_uses 2; #指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件 open_file_cache_errors on; 还可以缓存特定位置的资源,缓存文件很长时间是有好处的。如放在具体某个服务配置中.. location ~* .(woff|eot|ttf|svg|mp4|webm|jpg|jpeg|png|gif|ico|css|js)$ { expires 365d; } 9.Gzip压缩内容#开启gzip压缩 gzip on; #低版本兼容 gzip_disable &quot;msie6&quot;; #允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求 gzip_proxied any; #告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源 gzip_static on; #设置对数据启用压缩的最少字节数 gzip_min_length 1000; #压缩级别,1-10越高越消耗CPU，但是压缩越好 gzip_comp_level 6; #设置需要压缩的数据格式 gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;]]></content>
      <categories>
        <category>服务使用</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-双向链表、循环链]]></title>
    <url>%2F2019%2F03%2F27%2FLisked-List-two%2F</url>
    <content type="text"><![CDATA[1. 什么是双向链表? 双向链表(双链表)又叫双面链表,双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。 由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。 2. 什么是循环链表? 循环链表指的是首节点和末节点被连接在一起的链表，这种方式在单向和双向链表中皆可实现。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理。 3. 单向链表与双向链表优缺点3.1 单向链表优点： 单向链表增加删除节点简单。遍历时候不会死循环。（双向也不会死循环，循环链表忘了进行控制的话很容易进入死循环） 缺点： 只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。 3.2 双向链表优点： 可以找到前驱和后继，可进可退。 缺点： 增加删除节点复杂（其实就复杂一点点） 4. 代码（PHP）实现双向链表&lt;?php /** * Class Node */ class Node { /** * * @var */ private $Data;//数据集 /** * * @var */ private $Prev;//上一个节点 /** * * @var */ private $Next;//下一个节点 /** * Node constructor. * @param $next * @param $data * @param $prev */ public function __construct($data, $next,$prev) { $this-&gt;setData($data); $this-&gt;setNext($next); $this-&gt;setPrev($prev); } /** * Functional description : * Programmer : Mr.Liu * @param $data */ public function setData($data) { $this-&gt;Data = $data; } /** * Functional description : * Programmer : Mr.Liu * @return mixed */ public function getData() { return $this-&gt;Data; } /** * Functional description : * Programmer : Mr.Liu * @param $next */ public function setNext($next) { $this-&gt;Next = $next; } /** * Functional description : * Programmer : Mr.Liu * @return mixed */ public function getNext() { return $this-&gt;Next; } /** * Functional description : * Programmer : Mr.Liu * @param $prev */ public function setPrev($prev) { $this-&gt;Prev = $prev; } /** * Functional description : * Programmer : Mr.Liu * @return mixed */ public function getPrev() { return $this-&gt;Prev; } } /** * Class LinkList */ class LinkList { /** * * @var */ private $header; /** * * @var */ private $len;//链表长度 /** * LinkList constructor. */ public function __construct() { //初始化根节点 $this-&gt;setHeader(new Node(null, null,null)); $this-&gt;len = 0; } /** * Functional description : * Programmer : Mr.Liu * @param Node $node */ public function setHeader(Node $node) { $this-&gt;header = $node; } /** * Functional description : 获取头部节点 * Programmer : Mr.Liu * @return Node */ public function getHeader() : Node { return $this-&gt;header; } /** * Functional description : 获取链表长度 * Programmer : Mr.Liu * @return mixed */ public function getLen() : int { return $this-&gt;len; } /** * Functional description : 末尾追加 * Programmer : Mr.Liu * @param $data */ public function append($data) { $node = $this-&gt;getHeader(); //查找没有子节点的节点 while ($node-&gt;getNext() != null) { $node = $node-&gt;getNext(); } //找到后设置其下级节点 $node-&gt;setNext(new Node($data, null,$node)); //链表长度递增 $this-&gt;len++; } /** * Functional description : 头部添加 * Programmer : Mr.Liu * @param $data */ public function addFirst($data){ $rootNode = $this-&gt;getHeader(); //查找没有子节点的节点(根节点) while ($rootNode-&gt;getPrev() != null) { $rootNode = $rootNode-&gt;getPrev(); } //Root-A-B-C Root-D-A-B-C $oldFirst = $rootNode-&gt;getNext(); $newFirst = new Node($data,$oldFirst,$rootNode); $oldFirst-&gt;setPrev($newFirst); $rootNode-&gt;setNext($newFirst); $this-&gt;len++; } /** * Functional description : 根据指定位置添加 * Programmer : Mr.Liu * @param int $index * @param $data */ public function insertByIndex(int $index,$data){ $key = 1; //尾部添加 if ($this-&gt;getLen() &lt; $index){ $this-&gt;append($data); return; } //头部添加 if ($index == 1){ $this-&gt;addFirst($data); return; } $node = $this-&gt;getHeader(); while ($key &lt; $index){ $node = $node-&gt;getNext(); $key++; } //中间添加 如：添加D到A和B之间 A-B-C ---&gt; A-D-B-C $node-&gt;setNext(new Node($data,$node-&gt;getNext(),$node)); $this-&gt;len++; } /** * Functional description : 删除第一个节点 * Programmer : Mr.Liu */ public function delFirst(){ $rootNode = $this-&gt;getHeader(); while ($rootNode-&gt;getPrev() !=null){ $rootNode = $rootNode-&gt;getPrev(); } //删除：ROOT-A-B-C --&gt; ROOT-B-C $firstNode = $rootNode-&gt;getNext(); $secondNode = $firstNode-&gt;getNext(); $rootNode-&gt;setNext($secondNode); $secondNode-&gt;setPrev($rootNode); $this-&gt;len--; } /** * Functional description : 删除最后一个节点 * Programmer : Mr.Liu */ public function delLast(){ $node = $this-&gt;getHeader(); while ($node-&gt;getNext() !=null){ $node = $node-&gt;getNext(); } //删除：ROOT-A-B-C --&gt; ROOT-A-B $newLastNode = $node-&gt;getPrev(); $newLastNode-&gt;setNext(null); $this-&gt;len--; } /** * Functional description : 反转双向链表 * Programmer : Mr.Liu * @return void */ public function reverse(){ if ($this-&gt;getHeader() != null){ return ; } //除去根节点后的节点 $currentNode = $this-&gt;getHeader()-&gt;getNext(); //后一个节点 $next=null; $prev=null;//根节点,当前为null //rootNode-&gt;0-&gt;1-&gt;2-&gt;3 --&gt; 3-&gt;2-&gt;1-&gt;0 //查找最后一个 while ($currentNode != null){ //用一个变量暂时存储后一节点，因为一旦前面反转，就断链了 $next = $currentNode-&gt;getNext(); //将前一节点作为当前节点的后一节点，是为反转 $currentNode-&gt;setNext($prev); $currentNode-&gt;setPrev($next); #指针后移 $prev = $currentNode; $currentNode = $next; } return $prev; } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单向链表]]></title>
    <url>%2F2019%2F03%2F25%2FLinked-List%2F</url>
    <content type="text"><![CDATA[1. 什么是链表? 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 2. 链表的组成部分 链表通常由一连串节点组成，每个节点包含任意的实例数据（信息域 ）和一或两个用来指向上一个/或下一个节点的位置的链接（链域） 3. 数组和链 链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理 4. 数组与链表的优缺点 存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取； 存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定； 存储空间上，链表由于带有指针域，存储密度不如数组大； 按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)； 按值查找时，若数组无序，数组和链表时间复杂度均为O(n)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)； 插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可； 空间分配方面： 数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败； 链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效； 经典数据结构涵盖了多种抽象数据类型（ADT），其中包括栈、队列、有序列表、排序表、哈希表及分散表、树、优先队列、集合和图等。对于每种情况，都可以选用数组或某一种链表数据结构来实现其抽象数据类型（ADT）。由于数组和链表几乎是建立所有ADT的基础，所以称数组与链表为基本数据结构 5. 链表类型 单向链表 双向链表 循环链表 6. 单向链表 链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。 一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。 7. 代码（PHP）实现单向链表&lt;?php /** * Class Node */ class Node { /** * * @var */ private $Data;//数据集 /** * * @var */ private $Next;//下一个节点 /** * Node constructor. * @param $next * @param $data */ public function __construct($data, $next) { $this-&gt;setData($data); $this-&gt;setNext($next); } /** * Functional description : * Programmer : Mr.Liu * @param $data */ public function setData($data) { $this-&gt;Data = $data; } /** * Functional description : * Programmer : Mr.Liu * @return mixed */ public function getData() { return $this-&gt;Data; } /** * Functional description : * Programmer : Mr.Liu * @param $next */ public function setNext($next) { $this-&gt;Next = $next; } /** * Functional description : * Programmer : Mr.Liu * @return mixed */ public function getNext() { return $this-&gt;Next; } } /** * Class LinkList */ class LinkList { /** * * @var */ private $header;//链表头部信息 /** * * @var */ private $len;//链表长度 /** * LinkList constructor. */ public function __construct() { $this-&gt;setHeader(new Node(null, null)); $this-&gt;len = 0; } /** * Functional description : * Programmer : Mr.Liu * @param Node $node */ public function setHeader(Node $node) { $this-&gt;header = $node; } /** * Functional description : 获取当前节点 * Programmer : Mr.Liu * @return Node */ public function getHeader() : Node { return $this-&gt;header; } /** * Functional description : 获取链表长度 * Programmer : Mr.Liu * @return mixed */ public function getLen() : int { return $this-&gt;len; } /** * Functional description : * Programmer : Mr.Liu * @param $data */ public function add(string $data) { $node = $this-&gt;getHeader(); //查找没有子节点的节点 while ($node-&gt;getNext() != null) { $node = $node-&gt;getNext(); } //找到后设置其下级节点 $node-&gt;setNext(new Node($data, null)); //链表长度递增 $this-&gt;len++; } /** * Functional description : * Programmer : Mr.Liu * @param Node $currentNode * @param Node $prevNode * * 示例：A-B-C ==&gt; A-C * @return bool */ private function delLink(Node $currentNode, Node $prevNode) { $prevNode-&gt;setNext($currentNode-&gt;getNext()); $this-&gt;len--; return true; } /** * Functional description : 根据节点的数据进行删除 * Programmer : Mr.Liu * @param $data */ public function delByData($data) { $node = $this-&gt;getHeader(); $prevNode = $node; //查找没有数据一致的节点 while ($node-&gt;getData() != $data) { $prevNode = $node; $node = $node-&gt;getNext(); } //删除(把要删的节点A下的子节点位置移到A节点，从而删除) $this-&gt;delLink($node, $prevNode); } /** * Functional description : 删除第一个节点0~N * Programmer : Mr.Liu * @param int $index * @return bool */ public function delByIndex(int $index) { $node = $prevNode = $this-&gt;getHeader(); $i = 0; if ($i &gt; $this-&gt;getLen() -1 ){ //节点超 return false; } while ($i != $index) { if ($node-&gt;getNext() == null) { return false; } $prevNode = $node; $node = $node-&gt;getNext(); $i++; } return $this-&gt;delLink($node, $prevNode); } /** * Functional description : 获取链表上所有数据 * Programmer : Mr.Liu * @return array */ public function getLinkData() { $node = $this-&gt;getHeader(); $list = []; //根节点处理 if ($node-&gt;getData() != null) { $list[] = $node-&gt;getData(); } //从下一个节点开始获取数据 $node = $node-&gt;getNext(); if ($node-&gt;getData() == null) { return $list; } while ($node-&gt;getData() != null &amp;&amp; $node-&gt;getNext() != null) { $list[] = $node-&gt;getData(); $node = $node-&gt;getNext(); } return $list; } /** * Functional description : * Programmer : Mr.Liu * 添加D到1示例：A-B-C ==&gt; A-D-B-C * @param int $index * @param string $data * @return bool */ public function addByIndex(int $index,string $data){ $node = $this-&gt;getHeader(); $i=0; while ($i != $index){ if ($node-&gt;getNext() == null) { return false; } $node = $node-&gt;getNext(); $i++; } //进行添加 $node-&gt;setNext(new Node($data,$node-&gt;getNext())); $this-&gt;len++; return true; } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-并发请求]]></title>
    <url>%2F2019%2F03%2F22%2FmultiRequest%2F</url>
    <content type="text"><![CDATA[进程是资源分配的最小单位，线程是CPU调度的最小单位 1. 多线程并发:通过cURL并发请求1.1 通过curl_multi实现PHP cURL所有函数列表 并发中用的curl_multi_*相关函数 curl_multi_add_handle— 向curl批处理会话中添加单独的curl句柄 curl_multi_close — 关闭一组cURL句柄 curl_multi_exec — 运行当前 cURL 句柄的子连接 curl_multi_getcontent — 如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流 curl_multi_info_read — 获取当前解析的cURL的相关传输信息 curl_multi_init — 返回一个新cURL批处理句柄 curl_multi_remove_handle — 移除curl批处理句柄资源中的某个句柄资源 curl_multi_select — 等待所有cURL批处理中的活动连接 curl_multi_setopt — 为 cURL 并行处理设置一个选项 curl_multi_strerror — 返回字符串描述的错误代码 1.2 PHP curl_multi 实现并发请求步骤 调用 curl_multi_init，初始化一个批处理handle 循环调用 curl_multi_add_handle，往1中的批处理handle 添加curl_init来的子handle 持续调用 curl_multi_exec，直到所有子handle执行完毕。 根据需要循环调用 curl_multi_getcontent 获取结果 调用 curl_multi_remove_handle，并为每个字handle调用curl_close 调用 curl_multi_close 1.3 PHP curl_multi 实现代码&lt;?php /** * Functional description : * Programmer : Mr.Liu * @param array $urls * $urls = [ &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, ]; * @return array */ function multiGetRequest(array $urls):array { //1、初始化一个批处理handle $mh = curl_multi_init(); //2、往批处理handle 添加curl_init来的子handle foreach ($urls as $i =&gt; $url) { $connect[$i] = curl_init($url); curl_setopt($connect[$i], CURLOPT_HEADER, 0); curl_setopt($connect[$i], CURLOPT_CONNECTTIMEOUT, 60); curl_setopt($connect[$i], CURLOPT_RETURNTRANSFER, true); curl_multi_add_handle($mh, $connect[$i]); } //3、并发执行，直到全部结束。 do { curl_multi_exec($mh, $active); } while ($active); //4、获取结果 $return=[]; foreach ($urls as $i =&gt; $url) { $return[] = curl_multi_getcontent($connect[$i]); } //5、移除子handle，并close子handle foreach ($urls as $i =&gt; $url) { curl_multi_remove_handle($mh, $connect[$i]); curl_close($connect[$i]); } //6、关闭批处理handle curl_multi_close($mh); return $return; } 2. 多进程并发：通过swoole_process实现查看文档 2.1 示例代码&lt;?php $start_time = microtime(true); $urls = [ &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, &#39;http://liuqinghui.dev.lywf.me/test/libin/ttt&#39;, ]; //遍历任务创建子进程 foreach ($urls as $url) { /** * 创建子进程，并调用方法 my_process */ $process = new swoole_process(&quot;my_process&quot;, true); /** * 1.执行fork系统调用，启动进程; * 创建成功返回子进程的PID，创建失败返回false */ $process-&gt;start(); /** * 通过管道发数据到子进程。 * 管道是单向的：发出的数据必须由另一端读取。不能读取自己发出去的 */ $process-&gt;write($url); /** * 保存进程,循环结算后统一调取返回数数据： */ $process_list[] = $process; } //读取结果 foreach ($process_list as $process){ //从管道中读取数据。 echo $rec = $process-&gt;read(); } /** * 子进程结束必须要执行wait进行回收，否则子进程会变成僵尸进程 * $ret 是个数组其数据结构： array(3) { &#39;pid&#39; =&gt; int(461) &#39;code&#39; =&gt; int(0) &#39;signal&#39; =&gt; int(0) } */ while ($ret = swoole_process::wait()) { $pid = $ret[&#39;pid&#39;]; echo PHP_EOL . &quot;Worker Exit, PID=&quot; . $pid . PHP_EOL; } //子进程创建成功后要执行的函数 function my_process(swoole_process $worker) { sleep(1);//暂停1s $url = $worker-&gt;read(); //---- 执行具体业务程序开始----- $ch = curl_init(); // 设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取URL并把它传递给浏览器 $return = curl_exec($ch); // 关闭cURL资源，并且释放系统资源 curl_close($ch); //---- 执行具体业务程序结束----- $worker-&gt;write($return);//写入数据到管道 } $end_time = microtime(true); echo sprintf(&quot;use time:%.3f s\n&quot;, $end_time - $start_time); 3. 多进程和多线程的区别？如何选择3.1 不同的维度的对比 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 因共享进程数据，数据共享简单。但也因此导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂。CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；扩展到多台机器比较简单 适应于多核分布式 进程占优 如何选择?]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-php-fpm配置详情及优化]]></title>
    <url>%2F2019%2F03%2F10%2FphpFpm%2F</url>
    <content type="text"><![CDATA[PHP-FPM是一个PHPFastCGI管理器，是只用于PHP的。 配置文件详情注释 pid = run/php-fpm.pid #pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启 error_log = log/php-fpm.log #错误日志，默认在安装目录中的var/log/php-fpm.log log_level = notice #错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice. emergency_restart_threshold = 60 emergency_restart_interval = 60s #表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。 process_control_timeout = 0 #设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0. daemonize = yes #后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。 listen = 127.0.0.1:9000 #fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: &#39;ip:port&#39;, &#39;port&#39;, &#39;/path/to/unix/socket&#39;. 每个进程池都需要设置. listen.backlog = -1 #backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41 listen.allowed_clients = 127.0.0.1 #允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接 listen.owner = www listen.group = www listen.mode = 0666 #unix socket设置选项，如果使用tcp方式访问，这里注释即可。 user = www group = www #启动进程的帐户和组 pm = dynamic #对于专用服务器，pm可以设置为static。 #如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定： pm.max_children #，子进程最大数 pm.start_servers #，启动时的进程数 pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程 pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理 pm.max_requests = 1000 #设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 &#39;0&#39; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0. pm.status_path = /status #FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到 ping.path = /ping #FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。 ping.response = pong #用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong. request_terminate_timeout = 0 #设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的&#39;max_execution_time&#39;因为某些特殊原因没有中止运行的脚本有用. 设置为 &#39;0&#39; 表示 &#39;Off&#39;.当经常出现502错误时可以尝试更改此选项。 request_slowlog_timeout = 10s #当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 &#39;0&#39; 表示 &#39;Off&#39; slowlog = log/$pool.log.slow #慢请求的记录日志,配合request_slowlog_timeout使用 rlimit_files = 1024 #设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。 rlimit_core = 0 #设置核心rlimit最大限制值. 可用值: &#39;unlimited&#39; 、0或者正整数. 默认值: 系统定义值. chroot = #启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用. chdir = #设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时） catch_workers_output = yes #重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空. 主要参数介绍 pm (进程管理)管理进程方式: pm = static/dynamic static(静态) ：表示在fpm运行时直接fork出pm.max_chindren个worker进程 dynamic(动态)：表示运行时fork出start_servers个进程，随着负载的情况，动态的调整，最多不超过max_children个进程 一般推荐用static，优点是不用动态的判断负载情况，提升性能，缺点是多占用些系统内存资源。 max_children(子进程最大数) 这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。 设置’max_children’需要根据服务器的性能进行设定 一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右 假设“max_children”设置成100个，20M*100=2000M 在峰值的时候所有PHP-CGI所耗内存在2000M以内。 假设’max_children’设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。 如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。 start_servers(启动时的进程数) pm.start_servers的默认值为2。 其在php-fpm中给的计算方式也为：{（cpu空闲时等待连接的php的最小子进程数） + （cpu空闲时等待连接的php的最大子进程数 - cpu空闲时等待连接的php的最小子进程数）/ 2} 用配置表示就是：min_spare_servers + (max_spare_servers - min_spare_servers) / 2； 一般而言，设置成10-20之间的数据足够满足需求了 max_requests(最大请求数) 最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新spawn一个新的。这个配置的主要目的是避免php解释器或程序引用的第三方库造成的内存泄露。 出现502的原因？ 502，是后端PHP-FPM不可用造成的，间歇性的502一般认为是由于PHP-FPM进程重启造成的 但是为什么要重启进程呢？ 如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长（比如第三方库有问题等）。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长 也正是因为这个机制，在高并发中，经常导致502错误， request_terminate_timeout(最长执行时间)设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 &#39;max_execution_time&#39; 因为某些特殊原因没有中止运行的脚本有用。设置为 &#39;0&#39; 表示 &#39;Off&#39;。 这两项都是用来配置一个PHP脚本的最大执行时间的。当超过这个时间时，PHP-FPM不只会终止脚本的执行，还会终止执行脚本的Worker进程,Nginx会发现与自己通信的连接断掉了，就会返回给客户端502错误 php-fpm 调优 尽量少安装PHP模块 的PHPFastCGI子进程数（max_children）调到适应大小 使用socket连接FastCGI，linux操作系统可以放在 /dev/shm中 注：在php-fpm.cnf里设置/tmp/nginx.socket就可以通过socket连接FastCGI了，/dev/shm是内存文件系统，放在内存中肯定会快了.记得这时也要在nginx里的配置里进行修改，保持一致． location ~ \.php${ #将Nginx与FastCGI的通信方式由TCP改为Unix Socket。TCP在高并发访问下比Unix Socket稳定，但Unix Socket速度要比TCP快。 fastcgi_pass unix:/tmp/php-cgi.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fcgi.conf; } 以root身份执行以下命令，调高linux内核打开文件数量 echo &#39;ulimit -HSn 65536&#39; &gt;&gt; /etc/profile echo &#39;ulimit -HSn 65536&#39; &gt;&gt; /etc/rc.local source /etc/profile 增加 PHP-FPM 打开文件描述符的限制: 把php-fpm.conf文件中的rlimit_files值1024改为4096或者更高，然后重启 PHP-FPM 使用php代码加速器，例如 eAccelerator, XCache.在linux平台上可以把cache_dir指向 /dev/shm]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-php7更新记录]]></title>
    <url>%2F2018%2F10%2F06%2Fphp7-update-log%2F</url>
    <content type="text"><![CDATA[一.PHP5.6.x 移植PHP7.0.x1、PHP7.0.x 新特性 1.1 太空船操作符（组合比较符） (&lt;=&gt;)太空船操作符用于比较两个表达式，当$a小于、等于或大于$b时它分别返回-1、0或1，比较规则延续常规比较规则。对象不能进行比较。 &lt;?php // 整数 echo 1 &lt;=&gt; 1; // 0 echo 1 &lt;=&gt; 2; // -1 echo 2 &lt;=&gt; 1; // 1 // 浮点数 echo 1.5 &lt;=&gt; 1.5; // 0 echo 1.5 &lt;=&gt; 2.5; // -1 echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串 echo &quot;a&quot; &lt;=&gt; &quot;a&quot;; // 0 echo &quot;a&quot; &lt;=&gt; &quot;b&quot;; // -1 echo &quot;b&quot; &lt;=&gt; &quot;a&quot;; // 1 ?&gt; 1.2 null合并运算符由于日常使用中存在大量同时使用三元表达式和 isset()的情况， 我们添加了null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。 &lt;?php # php7以前 $a = isset($_GET[&#39;a&#39;]) ? $_GET[&#39;a&#39;] : &#39;none&#39;; #PHP 7 $a = isset($_GET[&#39;a&#39;]) ?? &#39;none&#39;; 1.3 变量类型声明变量类型声明有两种模式。一种是强制的，和严格的。允许使用下列类型参数int、string、float、bool 非严格模式 &lt;?php function sumOfInts(int ...$ints) { return array_sum($ints); } var_dump(sumOfInts(2, &#39;3&#39;, 4.1)); // int(9) 严格模式 &lt;?php # 严格模式 declare(strict_types=1); function add(int $x, int $y) { return $x + $y; } var_dump(add(&#39;2&#39;, 3)); // Fatal error: Argument 1 passed to add() must be of the type integer 要使用严格模式，一个declare声明指令必须放在文件的顶部。这意味着严格声明标量是基于文件可配的。 这个指令不仅影响参数的类型声明，也影响到函数的返回值声明 1.4 返回值类型声明 增加了返回类型声明，类似参数类型。这样更方便的控制函数的返回值.在函数定义的后面加上:类型名即可 &lt;?php function fun(int $a): array { return $a; } fun(3);//Fatal error 1.5 匿名类php7允许new class {} 创建一个匿名的对象。 &lt;?php //php7以前 class Logger { public function log($msg) { echo $msg; } } $util-&gt;setLogger(new Logger()); // php7+ $util-&gt;setLogger(new class { public function log($msg) { echo $msg; } }); 1.6 Unicode codepoint 转译语法这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的 &lt;?php echo &quot;\u{aa}&quot;;// ª echo &quot;\u{0000aa}&quot;;// ª echo &quot;\u{9999}&quot;;// 香 1.7 Closure::call闭包绑定 简短干练的暂时绑定一个方法到对象上闭包并调用它。 &lt;?php class A {private $x = 1;} // PHP 7 之前版本的代码 $getXCB = function() {return $this-&gt;x;}; $getX = $getXCB-&gt;bindTo(new A, &#39;A&#39;); // 中间层闭包 echo $getX(); // PHP 7+ 及更高版本的代码 $getX = function() {return $this-&gt;x;}; echo $getX-&gt;call(new A); 1.8 带过滤的unserialize 提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入 &lt;?php // 将所有的对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [&quot;allowed_classes&quot; =&gt; false]); // 将除 MyClass 和 MyClass2 之外的所有对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [&quot;allowed_classes&quot; =&gt; [&quot;MyClass&quot;, &quot;MyClass2&quot;]); // 默认情况下所有的类都是可接受的，等同于省略第二个参数 $data = unserialize($foo, [&quot;allowed_classes&quot; =&gt; true]); 1.9 IntlChar类新增加的 IntlChar 类旨在暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。 &lt;?php printf(&#39;%x&#39;, IntlChar::CODEPOINT_MAX);//10ffff echo IntlChar::charName(&#39;@&#39;);//COMMERCIAL AT var_dump(IntlChar::ispunct(&#39;!&#39;));//bool(true) 若要使用此类，请先安装Intl扩展 1.10 预期预期是向后兼用并增强之前的 assert() 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。 &lt;?php ini_set(&#39;assert.exception&#39;, 1); class CustomError extends AssertionError {} assert(false, new CustomError(&#39;Some error message&#39;)); //输出：Fatal error: Uncaught CustomError: Some error message ?&gt; 1.11 命名空间按组导入从同一个命名空间下导入的类、函数、常量支持按组一次导入 &lt;?php //php7以前 use app\model\A; use app\model\B; //php7+ use app\model{A,B} 1.12 生成器支持返回表达式此特性基于 PHP 5.5 版本中引入的生成器特性构建的。 它允许在生成器函数中通过使用 return 语法来返回一个表达式 （但是不允许返回引用值）， 可以通过调用 Generator::getReturn() 方法来获取生成器的返回值， 但是这个方法只能在生成器完成产生工作以后调用一次。 &lt;?php $gen = (function() { yield 1; yield 2; return 3; })(); foreach ($gen as $val) { echo $val, PHP_EOL; } echo $gen-&gt;getReturn(), PHP_EOL; //输出 /** 1 2 3 */ 1.13 生成器委派现在，只需在最外层生成其中使用 yield from， 就可以把一个生成器自动委派给其他的生成器， Traversable 对象或者 array。 &lt;?php function gen() { yield 1; yield 2; yield from gen2(); } function gen2() { yield 3; yield 4; } foreach (gen() as $val) { echo $val, PHP_EOL; } //输出 // 1 // 2 // 3 // 4 ?&gt; 1.14 整数除法函数intdiv &lt;?php var_dump(intdiv(10,3)); //3 1.15 会话选项设置session_start() 可以加入一个数组覆盖php.ini的配置 &lt;?php session_start([ &#39;cache_limiter&#39; =&gt; &#39;private&#39;, &#39;read_and_close&#39; =&gt; true, ]); 1.16 preg_replace_callback_array在 PHP7 之前，当使用 preg_replace_callback() 函数的时候， 由于针对每个正则表达式都要执行回调函数，可能导致过多的分支代码。 而使用新加的 preg_replace_callback_array() 函数， 可以使得代码更加简洁。 &lt;?php //string preg_replace_callback_array(array $regexesAndCallbacks, string $input); $tokenStream = []; // [tokenName, lexeme] pairs $input = &lt;&lt;&lt;&#39;end&#39; $a = 3; // variable initialisation end; // Pre PHP 7 code preg_replace_callback( [ &#39;~\$[a-z_][a-z\d_]*~i&#39;, &#39;~=~&#39;, &#39;~[\d]+~&#39;, &#39;~;~&#39;, &#39;~//.*~&#39; ], function ($match) use (&amp;$tokenStream) { if (strpos($match[0], &#39;$&#39;) === 0) { $tokenStream[] = [&#39;T_VARIABLE&#39;, $match[0]]; } elseif (strpos($match[0], &#39;=&#39;) === 0) { $tokenStream[] = [&#39;T_ASSIGN&#39;, $match[0]]; } elseif (ctype_digit($match[0])) { $tokenStream[] = [&#39;T_NUM&#39;, $match[0]]; } elseif (strpos($match[0], &#39;;&#39;) === 0) { $tokenStream[] = [&#39;T_TERMINATE_STMT&#39;, $match[0]]; } elseif (strpos($match[0], &#39;//&#39;) === 0) { $tokenStream[] = [&#39;T_COMMENT&#39;, $match[0]]; } }, $input ); // PHP 7+ code preg_replace_callback_array( [ &#39;~\$[a-z_][a-z\d_]*~i&#39; =&gt; function ($match) use (&amp;$tokenStream) { $tokenStream[] = [&#39;T_VARIABLE&#39;, $match[0]]; }, &#39;~=~&#39; =&gt; function ($match) use (&amp;$tokenStream) { $tokenStream[] = [&#39;T_ASSIGN&#39;, $match[0]]; }, &#39;~[\d]+~&#39; =&gt; function ($match) use (&amp;$tokenStream) { $tokenStream[] = [&#39;T_NUM&#39;, $match[0]]; }, &#39;~;~&#39; =&gt; function ($match) use (&amp;$tokenStream) { $tokenStream[] = [&#39;T_TERMINATE_STMT&#39;, $match[0]]; }, &#39;~//.*~&#39; =&gt; function ($match) use (&amp;$tokenStream) { $tokenStream[] = [&#39;T_COMMENT&#39;, $match[0]]; } ], $input ); 1.17 随机数、随机字符函数新加入两个跨平台的函数： random_bytes() 和 random_int() 用来产生高安全级别的随机字符串和随机整数。 &lt;?php $bytes = random_bytes(5); var_dump(bin2hex($bytes));//string(10) &quot;385e33f741&quot; var_dump(random_int(100, 999));//int(248) var_dump(random_int(-1000, 0));//int(-898) 1.18 define 支持定义数组&lt;?php define(&#39;ALLOWED_IMAGE_EXTENSIONS&#39;, [&#39;jpg&#39;, &#39;jpeg&#39;, &#39;gif&#39;, &#39;png&#39;]); 查看所有新特性详情 2、PHP7.0.x 新变化 2.1 错误和异常处理相关的变更在PHP7 中，很多致命错误以及可恢复的致命错误，都被转换为异常来处理了。 这些异常继承自 Error 类，此类实现了 Throwable 接口 （所有异常都实现了这个基础接口）。 这也意味着，当发生错误的时候，以前代码中的一些错误处理的代码将无法被触发。 因为在 PHP7 版本中，已经使用抛出异常的错误处理机制了。（如果代码中没有捕获 Error 异常，那么会引发致命错误） set_exception_handler() 不再保证收到的一定是 Exception 对象 _抛出Error对象时，如果set_exception_handler()里的异常处理代码声明了类型 Exception ，将会导致fatal error。想要异常处理器同时支持PHP5和PHP7，应该删掉异常处理器里的类型声明。如果代码仅仅是升级到PHP7，则可以把类型 Exception替换成Throwable_ &lt;?php // PHP 5 时代的代码将会出现问题 function handler(Exception $e) { ... } set_exception_handler(&#39;handler&#39;); // 兼容 PHP 5 和 7 function handler($e) { ... } // 仅支持 PHP 7 function handler(Throwable $e) { ... } ?&gt; 2.2 list() 会按照原来的顺序进行赋值。不再是逆序了 list($a,$b,$c) = [1,2,3]; //PHP5 var_dump($a);//3 var_dump($b);//2 var_dump($c);//1 //PHP7+ var_dump($a);//1 var_dump($b);//2 var_dump($c);//3 空的list()赋值支持已经被移除list() 结构现在不再能是空的。如下的例子不再被允许： &lt;?php list() = $a; list(,,) = $a; list($x, list(), $y) = $a; 2.3 foreach不再改变内部数组指针在PHP7之前，当数组通过 foreach 迭代时，数组指针会移动。现在开始，不再如此，见下面代码 &lt;?php $array = [0, 1, 2]; foreach ($array as &amp;$val) { var_dump(current($array)); } //PHP5 输出 int(1); int(2); bool(false); //PHP7+ 输出 int(0); int(0); int(0); 2.4 十六进制字符串不再被认为是数字 含十六进制字符串不再被认为是数字 &lt;?php var_dump(is_numeric(&quot;0x123&quot;)); //PHP5 输出 bool(true); //PHP7+ 输出 bool(false); 查看所有变化详情 3、PHP7.0.x 废弃的特性 3.1 PHP4风格的构造函数（方法名和类名一样）将被弃用，并在将来移除。 PHP4 风格的构造函数（方法名和类名一样）将被弃用，并在将来移除。 如果在类中仅使用了 PHP4 风格的构造函数，PHP7 会产生 E_DEPRECATED 警告。 如果还定义了 __construct() 方法则不受影响。 &lt;?php class foo { function foo() { echo &#39;I am the constructor&#39;; } } 以上例程会输出：Deprecated: Methods with the same name as their class will not be constructors in a future version of PHP; foo has a deprecated constructor in example.php on line 3 3.2 静态调用非静态的方法废弃了 静态（Static） 调用未声明成 static 的方法，未来可能会彻底移除该功能。 &lt;?php class foo { function bar() { echo &#39;I am not static!&#39;; } } foo::bar(); 以上例程会输出：Deprecated: Non-static method foo::bar() should not be called statically in - on line 8 I am not static! 查看更多PHP7.0.x 弃用的功能 4、PHP7.0.x 移除的扩展和 SAPI 4.1 移除的扩展 ereg mssql mysql sybase_ct 4.2 移除的 SAPI aolserver apache apache_hooks apache2filter caudium continuity isapi milter nsapi phttpd pi3web roxen thttpd tux webjames 二.PHP7.0.x 移植PHP7.1.x1、PHP7.1.x 新特性 1.1 可为空(Nullables)类型参数以及返回值的类型现在可以通过在类型前加上一个问号使之允许为空。 当启用这个特性时，传入的参数或者函数返回的结果要么是给定的类型，要么是null 。 &lt;?php function test(?string $name) { var_dump($name); } test(&#39;elePHPant&#39;); test(null); test(); 输出结果 string(10) &quot;elePHPant&quot; NULL Uncaught Error: Too few arguments to function test(), 0 passed in... 1.2 Void 函数一个新的返回值类型void被引入。 返回值声明为 void 类型的方法要么干脆省去 return 语句，要么使用一个空的 return 语句。 对于 void 函数来说，NULL 不是一个合法的返回值 &lt;?php function swap(&amp;$left, &amp;$right) : void { if ($left === $right) { return; } $tmp = $left; $left = $right; $right = $tmp; } $a = 1; $b = 2; var_dump(swap($a, $b), $a, $b); 输出结果 null int(2) int(1) 试图去获取一个 void 方法的返回值会得到 NULL ，并且不会产生任何警告。这么做的原因是不想影响更高层次的方法。 1.3 类常量可见性现在起支持设置类常量的可见性(public、protected、private)。 &lt;?php class ConstDemo { const PUBLIC_CONST_A = 1; public const PUBLIC_CONST_B = 2; protected const PROTECTED_CONST = 3; private const PRIVATE_CONST = 4; } 1.4 短数组语法（[]）短数组语法（[]）现在作为list()语法的一个备选项，可以用于将数组的值赋给一些变量（包括在foreach中）。 &lt;?php $data = [ [1, &#39;Tom&#39;], [2, &#39;Fred&#39;], ]; // list() style list($id1, $name1) = $data[0]; // [] style [$id1, $name1] = $data[0]; // list() style foreach ($data as list($id, $name)) { // logic here with $id and $name } // [] style foreach ($data as [$id, $name]) { // logic here with $id and $name } 1.5 iterable伪类现在引入了一个新的被称为iterable的伪类 (与callable类似)。 这可以被用在参数或者返回值类型中，它代表接受数组或者实现了Traversable接口的对象。 至于子类，当用作参数时，子类可以收紧父类的iterable类型到array 或一个实现了Traversable的对象。对于返回值，子类可以拓宽父类的 array或对象返回值类型到iterable。 &lt;?php function iterator(iterable $iter) { foreach ($iter as $val) { // } } 1.6 多异常捕获处理一个catch语句块现在可以通过管道字符(|)来实现多个异常的捕获。 这对于需要同时处理来自不同类的不同异常时很有用。 &lt;?php try { // some code } catch (FirstException | SecondException $e) { // handle first and second exceptions } 1.7 list支持键名现在list()和它的新的[]语法支持在它内部去指定键名。这意味着它可以将任意类型的数组 都赋值给一些变量（与短数组语法类似） &lt;?php $data = [ [&quot;id&quot; =&gt; 1, &quot;name&quot; =&gt; &#39;Tom&#39;], [&quot;id&quot; =&gt; 2, &quot;name&quot; =&gt; &#39;Fred&#39;], ]; // list() style list(&quot;id&quot; =&gt; $id1, &quot;name&quot; =&gt; $name1) = $data[0]; // [] style [&quot;id&quot; =&gt; $id1, &quot;name&quot; =&gt; $name1] = $data[0]; // list() style foreach ($data as list(&quot;id&quot; =&gt; $id, &quot;name&quot; =&gt; $name)) { // logic here with $id and $name } // [] style foreach ($data as [&quot;id&quot; =&gt; $id, &quot;name&quot; =&gt; $name]) { // logic here with $id and $name } 1.8 支持为负的字符串偏移量现在所有支持偏移量的字符串操作函数 都支持接受负数作为偏移量，包括通过[]或{}操作字符串下标。在这种情况下，一个负数的偏移量会被理解为一个从字符串结尾开始的偏移量。 &lt;?php var_dump(&quot;abcdef&quot;[-2]);//string (1) &quot;e&quot; var_dump(strpos(&quot;aabbcc&quot;, &quot;b&quot;, -3));//int(3) $string = &#39;bar&#39;; echo &quot;The last character of &#39;$string&#39; is &#39;$string[-1]&#39;.\n&quot;; //输出: The last character of &#39;bar&#39; is &#39;r&#39;. 1.9 将callables转为闭包Closure新增了一个静态方法fromCallable()，用于将callable快速地 转为一个Closure 对象。 &lt;?php class Test { public function exposeFunction() { return Closure::fromCallable([$this, &#39;privateFunction&#39;]); } private function privateFunction($param) { var_dump($param); } } $privFunc = (new Test)-&gt;exposeFunction(); $privFunc(&#39;some value&#39;); //输出:string(10) &quot;some value&quot; 1.10 http2服务推送 对服务器推送的支持现在已经被加入到CURL扩展中（ 需要版本 7.46 或更高）。这个可以通过curl_multi_setopt()函数与新的常量 CURLMOPT_PUSHFUNCTION 来进行调节。常量 CURL_PUST_OK 和 CURL_PUSH_DENY 也已经被添加进来，以便服务器推送的回调函数来表明自己会同意或拒绝处理。 2、PHP7.1.x 新变化 2.1 传递参数过少时将抛出错误 过去我们传递参数过少会产生warning。php7.1开始会抛出error 3、PHP 7.1.x 中废弃的特性 3.1 移除了ext/mcrypt拓展 mcrypt 扩展已经过时了大约10年，并且用起来很复杂。因此它被废弃并且被 OpenSSL 所取代。 从PHP7.2起它将被从核心代码中移除并且移到PECL中。 三.PHP7.1.x 移植PHP7.2.x1、PHP7.2.x 新特性 1.1 增加新的类型object这种新的对象类型, object, 引进了可用于逆变（contravariant）参数输入和协变（covariant）返回任何对象类型。 &lt;?php function test(object $obj) : object { return new SplQueue(); } test(new StdClass()); 1.2 通过名称加载扩展扩展文件不再需要通过文件加载 (Unix下以.so为文件扩展名，在Windows下以 .dll 为文件扩展名) 进行指定。可以在php.ini配置文件进行启用, 也可以使用 dl() 函数进行启用。 ; ini file extension=php-ast zend_extension=opcache 1.3 允许重写抽象方法当一个抽象类继承于另外一个抽象类的时候，继承后的抽象类可以重写被继承的抽象类的抽象方法 &lt;?php abstract class A { abstract function test(string $s); } abstract class B extends A { // overridden - still maintaining contravariance for parameters and covariance for return abstract function test($s) : int; } 1.4 使用Argon2算法生成密码散列Argon2 已经被加入到密码散列（password hashing） API (这些函数以 password_ 开头) 以下是暴露出来的常量:` PASSWORD_ARGON2I PASSWORD_ARGON2_DEFAULT_MEMORY_COST PASSWORD_ARGON2_DEFAULT_TIME_COST PASSWORD_ARGON2_DEFAULT_THREADS 1.5 新增 ext/PDO（PDO扩展） 字符串扩展类型 ¶当你准备支持多语言字符集，PDO的字符串类型已经扩展支持国际化的字符集。以下是扩展的常量： PDO::PARAM_STR_NATL PDO::PARAM_STR_CHAR PDO::ATTR_DEFAULT_STR_PARAM 这些常量通过PDO::PARAM_STR利用位运算OR进行计算： &lt;?php $db-&gt;quote(&#39;über&#39;, PDO::PARAM_STR | PDO::PARAM_STR_NATL); 1.5 允许分组命名空间的尾部逗号命名空间可以在PHP7.2中使用尾随逗号进行分组引入。 &lt;?php use Foo\Bar\{ Foo, Bar, Baz, }; 在php7.0中 最后一个(Baz,)不能有逗号否则报错 2、PHP7.2.x 新变化 2.1 number_format 返回值 &lt;?php var_dump(number_format(-0.01)); // now outputs string(1) &quot;0&quot; instead of string(2) &quot;-0&quot; 2.2 get_class()不再允许null。 &lt;?php var_dump(get_class(null)); // warning 2.3 count 作用在不是 Countable Types 将发生warning &lt;?php //PHP7.2 var_dump( count(null), // NULL is not countable count(1), // integers are not countable count(&#39;abc&#39;), // strings are not countable count(new stdclass), // objects not implementing the Countable interface are not countable count([1,2]) // arrays are countable ); 以上例程会输出: Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d int(0) int(1) int(1) int(1) int(2) 2.4 不带引号的字符串在之前不带引号的字符串是不存在的全局常量，转化成他们自身的字符串。现在将会产生waring。 &lt;?php var_dump(HELLO); // PHP7.2前输出：HELLO /* * PHP7.2输出 Warning: Use of undefined constant HELLO - assumed &#39;HELLO&#39; (this will throw an Error in a future version of PHP) in /usr/src/php/dfe807d9bfa587a80b60fbdda823e7be.php on line 2 string(5) &quot;HELLO&quot; */ 2.5 is_object、gettype修正 is_object 作用在__PHP_Incomplete_Class 将返回：truePreviously, using is_object() on the __PHP_Incomplete_Class class would return FALSE. Now, TRUE will be returned. gettype作用在闭包在将正确返回resourcePreviously, using gettype() on a closed resource would return a string of &quot;unknown type&quot;. Now, a string of &quot;resource (closed)&quot; will be returned. 3、PHP7.2.x 废弃的特性 3.1 __autoload 被废弃 3.2 each被废弃使用此函数遍历时，比普通的 foreach 更慢， 并且给新语法的变化带来实现问题。因此它被废弃了 3.3 gmp_random()函数被废弃此函数基于未知的、取决于平台的 limb 尺寸产生随机数。因此，该函数已被废弃。 使用更好的方式产生随机数： GMP 扩展中的gmp_random_bits() 和 gmp_random_range()。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发compose包]]></title>
    <url>%2F2018%2F09%2F23%2Fcomposer-pack-dev%2F</url>
    <content type="text"><![CDATA[1. 创建一个 GitHub 项目# 克隆到本地 https://github.com/52lu/php-tools.git 2. 生成composer.json 前提安装好composer root@707dfe5d675c:/var/www/php-tools# composer init Welcome to the Composer config generator This command will guide you through creating your composer.json config. # 包的名称，后续 composer require lazy/phptools 安装此包 Package name (&lt;vendor&gt;/&lt;name&gt;) [root/php-tools]: lazy/phptools # 对包的描述信息 Description []: 收集PHP开发工程中经常用到的轮子，避免二次开发 # 填写作者信息，可以先跳过，后续修改文件 Author [定时任务 &lt;cron@example.com&gt;, n to skip]: # 此处值不能乱填，否则:Invalid minimum stability &quot;sdfsd&quot;. Must be empty or one of: stable, RC, beta, alpha, dev Minimum Stability []: dev Package Type (e.g. library, project, metapackage, composer-plugin) []: License []: Define your dependencies. Would you like to define your dependencies (require) interactively [yes]? no Would you like to define your dev dependencies (require-dev) interactively [yes]? no { &quot;name&quot;: &quot;52lu/phptools&quot;, &quot;description&quot;: &quot;收集PHP开发工程中经常用到的轮子，避免二次开发。&quot;, &quot;authors&quot;: [ { &quot;name&quot;: &quot;定时任务&quot;, &quot;email&quot;: &quot;cron@example.com&quot; } ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: {} } Do you confirm generation [yes]? yes 上面提示信息可以一直按回车键，生成composer.json文件以后，在对文件修改 修改后的composer.json文件 { &quot;name&quot;: &quot;52lu/phptools&quot;, &quot;description&quot;: &quot;收集PHP开发工程中经常用到的轮子，避免二次开发&quot;, &quot;homepage&quot;: &quot;https://github.com/52lu/php-tools.git&quot;, &quot;authors&quot;: [ { &quot;name&quot;: &quot;qinghui&quot;, &quot;email&quot;: &quot;liuqinghui1991@163.com&quot;, &quot;homepage&quot;: &quot;https://52lu.github.io&quot;, &quot;role&quot;: &quot;Developer&quot; } ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: { &quot;php&quot;: &quot;&gt;=7.0&quot;, &quot;ext-json&quot;: &quot;*&quot; } } 文件简要说明 require : 告诉 Composer 你的项目所依赖的包有哪些,以及包的版本信息 homepage: 源码地址 (可选填) authors.homepage : 个人网站地址(可选填) authors.role: 作者在项目承担的角色 (可选填) minimum-stability: 稳定性标识，定义了按稳定性过滤包的默认值，默认为 stable。所以如果你依赖 dev 包，你应该在你的文件中指定。所有包都将根据稳定性检出相应的版本，那些低于 minimum-stability 设置的版本将被自动忽略。（请注意，你还可以使用在 require 中指定的版本约束来定义每个包的稳定性要求) 3. 创建src目录,编辑代码src/StringTools.php &lt;?php /** * @Description: 字符串处理工具 * @Author: Mr.LiuQHui * @Date: 2020/7/17 11:51 上午 */ namespace phpTools; /** * @Description: * @Class StringTools * @Package phpTools */ class StringTools { /** * @description: 计算字符串长度 * @param $str * @param string $encoding * @return bool|int * @autor Mr.LiuQHui */ public static function strlen(string $str, $encoding = &#39;UTF-8&#39;) { if (is_array($str) || is_object($str)) { return false; } $str = html_entity_decode($str, ENT_COMPAT, &#39;UTF-8&#39;); if (function_exists(&#39;mb_strlen&#39;)) { return mb_strlen($str, $encoding); } return strlen($str); } } 此时的目录结构 ├── README.md ├── composer.json └── src └── StringTools.php 修改 composer.json,加入自动加载 { &quot;name&quot;: &quot;52lu/phptools&quot;, &quot;description&quot;: &quot;收集PHP开发工程中经常用到的轮子，避免二次开发&quot;, &quot;homepage&quot;: &quot;https://github.com/52lu/php-tools.git&quot;, &quot;authors&quot;: [ { &quot;name&quot;: &quot;qinghui&quot;, &quot;email&quot;: &quot;liuqinghui1991@163.com&quot;, &quot;homepage&quot;: &quot;https://52lu.github.io&quot;, &quot;role&quot;: &quot;Developer&quot; } ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: { &quot;php&quot;: &quot;&gt;=7.0&quot;, &quot;ext-json&quot;: &quot;*&quot; }, // 新增自动加载 &quot;autoload&quot;: { &quot;psr-4&quot;: { &quot;phpTools\\&quot;: &quot;src/&quot; } } } 4. 测试4.1 执行 composer installroot@707dfe5d675c:/var/www/php-tools# composer install Loading composer repositories with package information Updating dependencies (including require-dev) Nothing to install or update Writing lock file Generating autoload files 此时目录结构 ├── README.md ├── composer.json ├── composer.lock ├── src │ └── StringTools.php └── vendor ├── autoload.php └── composer ├── ClassLoader.php ├── LICENSE ├── autoload_classmap.php ├── autoload_namespaces.php ├── autoload_psr4.php ├── autoload_real.php ├── autoload_static.php └── installed.json 4.2 创建测试目录tests/testStringTools.php &lt;?php require_once &#39;../vendor/autoload.php&#39;; $str=&#39;hello word&#39;; $len = \phpTools\StringTools::strlen($str); echo &#39;length= &#39;.$len.PHP_EOL; 执行测试文件 root@707dfe5d675c:/var/www/php-tools/tests# php testStringTool.php length= 10 5.发布到 packagistpackagist 指的是 packagist.org。这个网站是 composer 默认下载开发包的资源引用网站。所以，我们得在此网站注册一个账号。然后添加我们开发包的github项目。 5.1 发布步骤 首先要在 Packagist 上注册账号并登录（可以用 GitHub 直接登录） 点击顶部导航条中的 Summit 按钮 在输入框中输入 GitHub 上的刚才包地址，如上图。 然后点击 Check 按钮 Packagist 会去检测此仓库地址的代码是否符合 Composer 的 Package 包的要求 检测正常的话，会出现 Submit 按钮，再点击一下 Submit 按钮，我们的包就提交到 Packagist 上了。 上传成功后的页面 6. 设置composer 包自动更新上面提交上的包提交的包，当我们更新 GitHub 仓库时，Packagist 上面的的包并不会自动更新，现在我们来设置一下自动更新。 6.1 获取 Profile API Token 6.2 设置代码库(github) 打开github settings-&gt;webhooks-&gt;addwebhook 填写Payload URL 格式: https://packagist.org/api/github?username=packagist用户名 7. 疑问7.1 要不要把 composer.lock 上传到代码库？ 如果你的代码是一个项目，就上传，如果是一个工具包，给大家用的，就别上传。 composer.lock的作用 在已经存在 composer.lock 的目录执行 composer install 的时候，是不会分析包依赖的，它只是按 composer.lock 中描述的下载地址直接下载，所以会快很多，而且版本号是具体的。那怕包已经发了新版，只要 composer.lock 没动过，它就会按 composer.lock 里的版本来安装。composer update 时会更新 composer.lock，所以不要乱用 composer update。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ之消息类型]]></title>
    <url>%2F2018%2F09%2F15%2Frabbitmq-msg-type%2F</url>
    <content type="text"><![CDATA[1.简单队列1.模型图片 P:消息的生产者 C:消息的消费者 红色:队列 生产者将消息发送到队列，消费者从队列中获取消息。 2.不足耦合性高 生产消费一一对应(如果有多个消费者想都消费这个消息,就不行了) 队列名称变更时需要同时更改 2.工作队列(又称任务队列)1.模型图片 2.为什么会出现 work queues?使用 simple队列(简单) 的时候我们应用程序在是使用消息系统的时候,一般生产者P 生产消息是毫不费力的(发送消息即可),而消费者接收完消息 后的需要处理,会耗费一定的时间,这时候,就有可能导致很多消息堆积在队列里面,一个消费者有可能不够用。 3.那么怎么让消费者同事处理多个消息呢?在同一个队列上创建多个消费者,让他们相互竞争,这样消费者就可以同时处理多条消息了 4.两种消息发送机制1.Round-robin(轮询分发)轮询分发: 生产者会将消息通过轮询的方式，将消息发送给消费者。结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个分。 2.Fair dispatch(公平分发) 虽然Round-robin(轮询分发)方式也还行，但是有个问题就是:比如:现在有 2 个消费者，所有的偶数的消息都是繁忙的，而 奇数则是轻松的。按照轮询的方式，偶数的任务交给了第一个消费者，所以一直在忙个不停。奇数的任务交给另一 个消费者，则立即完成任务，然后闲得不行。 而 RabbitMQ 则是不了解这些的。他是不知道你消费者的消费能力的,这是因为当消息进入队列，RabbitMQ 就会分派 消息。而 rabbitmq 只是盲目的将消息轮询的发给消费者。你一个我一个的这样发送. 为了解决这个问题，我们使用 basicQos( prefetchCount = 1)方法，来限制 RabbitMQ 只发不超过 1 条的消息给同 一个消费者。当消息处理完毕后，有了反馈 ack，才会进行第二次发送。(也就是说需要手动反馈给 Rabbitmq ) 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 3.订阅模式(Publish/Subscribe)1.模型图片 之前学习的都是一个消息只能被一个消费者消费,那么如果我想发一个消息 能被多个消费者消费,这时候怎么 办? 这时候我们就得用到了消息中的发布订阅模型。 解读 1 个生产者，多个消费者 每一个消费者都有自己的一个队列 生产者没有将消息直接发送到队列，而是发送到了交换机(转发器) 每个队列都要绑定到交换机 生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 4.路由模式(Routing)1.模型图片 生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。也就是让消费者有选择性的接收消息。 5.主题模式(Topics)1.模型图片 上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。 符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-'Row size too large (> 8126) for mysql']]></title>
    <url>%2F2018%2F09%2F11%2FRow-size-too-large-8126-for-mysql%2F</url>
    <content type="text"><![CDATA[问题：SQLSTATE[42000]: Syntax error or access violation: 1118 Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768 bytes is stored inline.错误分析根据报错信息，mysql提示是行的数据过大，应该将一些字段类型声明为TEXT或者BLOB，再或者将ROW_FORMAT(行格式)设置为DYNAMIC或者COMPRESSED。根据这个信息，我们查看一下mysql数据库的一些变量参数信息： # 查看所有表的状态 show table status; +--------+--------+---------+------------+------+----------------+-------------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | +--------+--------+---------+------------+------+----------------+-------------+ | t_test | InnoDB | 10 | Dynamic | 0 | 0 | 16384 | +--------+--------+---------+------------+------+----------------+-------------+ # 查看当前数据库innodb引擎的文件格式 show variables like &#39;%innodb_file_format%&#39;; +--------------------------+-----------+ | Variable_name | Value | +--------------------------+-----------+ | innodb_file_format | Barracuda | | innodb_file_format_check | ON | | innodb_file_format_max | Barracuda | +--------------------------+-----------+ mysql的innodb引擎存储blob/text类型字段的行为，取决于三个因素：字段大小、整行(row)大小、innodb行格式。 innodb引擎支持的文件格式包括Antelope(羚羊)、Barracuda(梭子鱼): Antelope提供Redundant（冗长）、Compact（紧凑）文件格式 Barracuda除此之外提供Dynamic(动态)和 Compressed(压缩) Antelope格式的innodb引擎会尽可能地将整行数据存储在一个innodb page上，并且一个InnoDB page存储多行数据(至少是2行)，一个innodb page大约是16k，所以行大小限制为(16k - page header- page trailer) / 2。如果行中有可变长度字段(blob/text/varchar)，并且整行大小超过行大小限制，InnoDB会将字段其余数据页外存储(off-page)。这种情况下(Redundant或Compact)，每个可变长度字段(blob/text/varchar)的前768字节存储在innodb page内的行中，其余部分存储在页外。 导致innodb的1118错误的原因：1、多个可变长度字段；2、每个字段的值超过768(不是定义的字段大小，而是字段值的大小)；3、innodb引擎不是在定义表的时候判断，而是每次插入操作的时候判断。 Barracuda格式的innodb引擎，当ROW_FORMAT设置为DYNAMIC只使用一个20字节的指针作为可变长度类型，并且优先选择较小的字段存储在innodb page上。并且可以给blob增加前缀索引(prefix index)，将前缀索引建立在page外的blob上而不是page内。ROW_FORMAT设置为COMPRESSED时，innodb引擎的对可变长度字段的存储策略类似，并且总是压缩不在page内的数据，即使没有设置KEY_BLOCK_SIZE，也没有启用正常数据和索引的压缩。 innodb在存储blob时，page内部和外部的blob其实时不共享的。每个blob在页外都有16k分配，即使blob只有1个字节大小。如果每行有多个blob，可能会导致数据库效率比较低。所以最好是一行只定义一个blob来组合数据，并且压缩改数据，text类型同理 解决方案 解决方案1 – Dynamic将innodb引擎的文件格式设置为Barracuda，并且将行格式设置为DYNAMIC。 SET GLOBAL innodb_file_format=Barracuda; ALTER TABLE [tableName] ENGINE=InnoDB ROW_FORMAT=DYNAMIC; 解决方案2 – Compressed将innodb引擎的文件格式设置为Barracuda，将行格式设置为COMPRESSED，并且设置缓冲池索引块大小。一般压缩效果明显，压缩率在30%-40%左右，但是会影响存储效率。 SET GLOBAL innodb_file_format=Barracuda; ALTER TABLE [tableName] ENGINE=InnoDB ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8， 解决方案3 – 单表一文件每张表一个文件，不建议使用。对于单行多可变长度字段的表，效果可以，但是对于其他表浪费存储空间。 innodb_file_format=Barracuda innodb_file_per_table=1]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-常用命令整理]]></title>
    <url>%2F2018%2F08%2F13%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[1.基本信息查看# 查看docker的版本号，包括客户端、服务端、依赖的Go等 $ docker version # 查看系统(docker)层面信息，包括管理的images, containers数等 $ docker info 2.镜像使用2.1 搜索镜像# 在docker index中搜索image $ docker search &lt;image&gt; 2.2 下载镜像# 从docker registry server 中下拉image $ docker pull &lt;image&gt; 2.3 查看镜像$ docker images： # 列出images $ docker images -a # 列出所有的images（包含历史） $ docker rmi &lt;image ID&gt;： # 删除一个或多个image 2.4 使用镜像创建容器$ docker run -i -t sauloal/ubuntu14.04 # 创建一个容器，让其中运行 bash 应用，退出后容器关闭 $ docker run -i -t sauloal/ubuntu14.04 /bin/bash #创建一个名称centos_aways的容器，自动重启，--restart参数：always始终重启；on-failure退出状态非0时重启；默认为，no不重启 $ docker run -itd --name centos_aways --restart=always centos 2.5 删除为none的镜像Dockerfile 代码更新频繁，自然docker build构建同名镜像也频繁的很，产生了众多名为none的无用镜像。分别执行以下三行可清除: $ docker ps -a | grep &quot;Exited&quot; | awk &#39;{print $1 }&#39;|xargs docker stop $ docker ps -a | grep &quot;Exited&quot; | awk &#39;{print $1 }&#39;|xargs docker rm $ docker images|grep none|awk &#39;{print $3 }&#39;|xargs docker rmi 3.容器使用3.1 查看容器$ docker ps ：列出当前所有正在运行的container $ docker ps -l ：列出最近一次启动的container $ docker ps -a ：列出所有的container（包含历史，即运行过的container） $ docker ps -q ：列出最近一次运行的container ID 3.2 启动容器#：开启/停止/重启container $ docker start/stop/restart &lt;container&gt; #：再次运行某个container （包括历史container） $ docker start [container_id] 3.3 进入容器$ docker exec -it [container_id] /bin/bash #：映射 HOST 端口到容器，方便外部访问容器内服务，host_port 可以省略，省略表示把 container_port 映射到一个动态端口。 $ docker run -i -t -p &lt;host_port:contain_port&gt; 3.4 删除容器#：删除一个或多个container $ docker rm &lt;container...&gt; #：删除所有的container $ docker rm `docker ps -a -q` #：同上, 删除所有的container $ docker ps -a -q | xargs docker rm # 停止所有容器，删除所有容器 $ docker kill $(docker ps -q) $ docker rm $(docker ps -a -q) 3.5 查看容器IP 进入容器内部后cat /etc/hosts 使用命令docker inspect &lt;container id&gt; # 或 docker inspect -f &#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; container_name_or_id 获取所有容器名称及其IP $ docker inspect --format='{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq) workdock_nginx_1 - 192.168.0.8172.31.0.3 workdock_php-fpm_1 - 192.168.0.7 workdock_workspace_1 - 192.168.0.6172.31.0.2 workdock_redis_1 - 192.168.0.5 workdock_mysql_1 - 192.168.0.2 workdock_mongo_1 - 192.168.0.4 workdock_docker-in-docker_1 - 192.168.0.3]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bug-MacBook brew yaf error unknown type name HASHKIT_API]]></title>
    <url>%2F2018%2F07%2F31%2Fbrew-yaf-error%2F</url>
    <content type="text"><![CDATA[问题：在 mac 系统中安装 PHP yaf 扩展时，总是失败；报错：error: unknown type name ‘HASHKIT_API’ \h:\W \u$ brew install php70-yaf ==&gt; Installing php70-yaf from homebrew/php ==&gt; Downloading https://github.com/laruence/yaf/archive/yaf-3.0.3.tar.gz Already downloaded: /Users/liuqh/Library/Caches/Homebrew/php70-yaf-3.0.3.tar.gz ==&gt; /usr/local/opt/php70/bin/phpize ==&gt; ./configure --prefix=/usr/local/Cellar/php70-yaf/3.0.3 --with-php-config=/usr/local/opt/php70/bin/php-config ==&gt; make Last 15 lines from /Users/liuqh/Library/Logs/Homebrew/php70-yaf/03.make: /usr/local/include/string.h:56:1: error: unknown type name &#39;HASHKIT_API&#39; HASHKIT_API ^ /usr/local/include/string.h:57:1: error: expected identifier or &#39;(&#39; const char *hashkit_string_c_str(const hashkit_string_st* self); ^ 6 errors generated. make: *** [yaf_bootstrap.lo] Error 1 make: *** Waiting for unfinished jobs.... 6 errors generated. make: *** [yaf.lo] Error 1 6 errors generated. make: *** [yaf_application.lo] Error 1 6 errors generated. make: *** [yaf_dispatcher.lo] Error 1 ====&gt; 解决方法：找到/usr/local/include/string.h 注释调和’HASHKIT_API有关的代码； /*=============================20180314 解决yaf 装不上的问题，注释 #HASHKIT_API void hashkit_string_free(hashkit_string_st *ptr); #HASHKIT_API size_t hashkit_string_length(const hashkit_string_st *self); #HASHKIT_API const char *hashkit_string_c_str(const hashkit_string_st* self); #================================================================ */ 补充：以上的解决方法有问题，虽然 phpinfo 能显示 yaf 扩展；但是实际使用中会报错； &gt;&gt;&gt; nginx 报错： 2018/03/16 12:01:44 [error] 4965#0: *25 kevent() reported about an closed connection (54: Connection reset by peer) while reading response header from upstream, client: 127.0.0.1, server: 127.0.0.1, request: &quot;GET /test/lqh/test?XDEBUG_SESSION_START=19833 HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;www.cloudins.com&quot; &gt;&gt;&gt;php-fpm报错: [16-Mar-2018 12:21:27] NOTICE: fpm is running, pid 6593 [16-Mar-2018 12:21:27] NOTICE: ready to handle connections [16-Mar-2018 12:22:01] WARNING: [pool www] child 6594 exited on signal 11 (SIGSEGV) after 34.532384 seconds from start [16-Mar-2018 12:22:01] NOTICE: [pool www] child 6602 started [16-Mar-2018 14:10:02] NOTICE: Finishing ... [16-Mar-2018 14:10:02] NOTICE: exiting, bye-bye! 后来发现不只是安装yaf会保这个错，安装一些其他的服务也会报这个错， 解决方法：把/usr/local/include 临时改为 :/usr/local/include_bak 结论： 这些错误信息各种 google，都没有对应的解决方案，只是遇到同样问题的人； 后来最后的解决方法是从同事电脑 （MacBook Pro）brew安装好的包直接引入; 我的电脑是（MacBook），个人猜测是电脑系统（/usr/local/include）中文件的问题，因为我发现MacBook Pro该目录中没有这些文件；]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程、线程、协程]]></title>
    <url>%2F2018%2F07%2F13%2F%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 进程和线程介绍1.1 进程和线程的介绍1.1.1 进程进程是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位，每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全 1.1.2 线程线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 1.1.3 协程协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 1.1.4 进程和线程的关系 一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行 一个程序至少有一个进程，一个进程至少有一个线程 1.2 区别1.2.1 进程与线程比较 地址空间: 线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 资源拥有: 进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 基本单位: 线程是CPU调度的基本单位,进程是系统进行资源分配和调度的基本单位 并发执行: 二者均可并发执行 层级关系: 一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行 执行过程: 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 为了加深理解，做个简单的比喻：进程=火车，线程=车厢 线程在进程下行进（单纯的车厢无法运行） 一个进程可以包含多个线程（一辆火车可以有多个车厢） 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） 同一进程下不同线程间数据容易共享（A车厢换到B车厢很容易） 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源） 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢与前一节产生断裂，将影响后面的所有车厢） 进程可以拓展到多机，进程最适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上） 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁” 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－”信号量” 1.2.2 协程与线程进行比较 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。 线程进程都是同步机制，而协程则是异步 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态 1.2.3 其他介绍资料 进程与线程的一个简单解释(阮一峰) 漫画：什么是协程？]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-查看容器日志]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1.如何找出docker容器日志文件？ 在linux上，容器日志一般存放在/var/lib/docker/containers/container_id/下面， 以json.log结尾的文件 # 查看各个容器的日志文件大小 ls -lh $(find /var/lib/docker/containers/ -name *-json.log) 2.如何清理日志如果docker容器正在运行，那么使用rm -rf 方式删除日志后，通过df -h会发现磁盘空间并没有释放。 原因： 在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用 # 正确操作 cat /dev/null &gt; *-json.log # 或者rm删除后,重启docker 清理脚本： #!/bin/sh echo &quot;==================== start clean docker containers logs ==========================&quot; logs=$(find /var/lib/docker/containers/ -name *-json.log) for log in $logs do echo &quot;clean logs : $log&quot; cat /dev/null &gt; $log done echo &quot;==================== end clean docker containers logs ==========================&quot; 3.设置Docker容器日志大小通过配置容器docker-compose的max-size选项来实现 3.1 针对单容器设置如nginx: nginx: image: nginx:1.12.1 restart: always logging: driver: &quot;json-file&quot; options: max-size: &quot;5g&quot; .... 重启nginx容器之后，其日志文件的大小就被限制在5GB，再也不用担心了。 3.2 全局设置新建/etc/docker/daemon.json，若有就不用新建了。添加log-dirver和log-opts参数如下: { &quot;registry-mirrors&quot;: [&quot;https://ud17re9w.mirror.aliyuncs.com&quot;], &quot;log-driver&quot;:&quot;json-file&quot;, &quot;log-opts&quot;: {&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;3&quot;} } max-size=500m，意味着一个容器日志大小上限是500M， max-file=3，意味着一个容器有三个日志，分别是id+.json、id+1.json、id+2.json。 3.3 重启docker守护进程# systemctl daemon-reload # systemctl restart docker]]></content>
      <categories>
        <category>容器管理</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-性能优化神器之Explain使用]]></title>
    <url>%2F2018%2F06%2F03%2Fmysql-explan%2F</url>
    <content type="text"><![CDATA[1.什么是explain?MySQL提供了一个explain命令,这个命令可以查看一个SQL语句的执行计划、有没有使用上了索引、有没有做全表扫描、以及查询的类型等。 2.使用示例mysql&gt; EXPLAIN (SELECT * from hs_user WHERE uid in (1,2)) UNION (SELECT * from hs_user WHERE uid in (3,4,5)); +------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+ | 1 | PRIMARY | hs_user | range | PRIMARY | PRIMARY | 50 | NULL | 2 | Using where | | 2 | UNION | hs_user | range | PRIMARY | PRIMARY | 50 | NULL | 3 | Using where | | NULL | UNION RESULT | &lt;union1,2&gt; | ALL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+-------+---------------+---------+---------+------+------+-----------------+ 3 rows in set (0.01 sec) 3.explain输出字段 id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符. select_type: SELECT 查询的类型. table: 查询的是哪个表 type: join 类型 possible_keys: 此次查询中可能选用的索引 key: 此次查询中确切使用到的索引. key_len:表示索引中使用的字节数 ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值 extra: 额外的信息 4.id 查询的标识符SELECT查询的标识符. 每个SELECT都会自动分配一个唯一的标识符,id如果相同，可以认为是一个分组，从上往下顺序执行,id值越大，表示优先级越高，越先执行。 5.select_type: SELECT查询的类型. 6.table:表示查询涉及的表或衍生表7.type: 显示访问类型，是较为重要的一个指标。 从最好到最差依次是：system &gt;const &gt;eq_ref &gt;ref &gt;range &gt;index &gt;ALL。一般来说，得保证查询至少达到range级别，最好能达到ref。 8.possible_keys: 可能使用的索引显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。 9.key: 实际使用的索引实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中 10.key_len:表示索引中使用的字节数表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 11. ref: 哪个字段或常数与key一起被使用显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列表或常量被用于查找索引列上的值如下SQL会显示为常数 mysql&gt; EXPLAIN SELECT * from hs_user WHERE uid = 1; +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+ | 1 | SIMPLE | hs_user | const | PRIMARY | PRIMARY | 50 | const | 1 | NULL | +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+ 1 row in set (0.01 sec) 12. rows:扫描了多少行显示此查询一共扫描了多少行. 这个是一个估计值. 13.extra: 额外的信息 14.Explain的作用 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-通道]]></title>
    <url>%2F2018%2F05%2F08%2FGo-8.%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[1.为什么需要 channel？ 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。Go语言提倡使用通信的方法代替共享内存，这里通信的方法就是使用通道。 1.1 goroutine与channel的通信图 2. 通道的特性 道是一种特殊的类型 任何时候，同时只能有一个goroutine访问通道进行发送和获取数据 channle本质就是一个数据结构-队列 goroutine间通过通道就可以通信 通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序 channel 是线程安全，多个协程操作同一个channel时，不会发生资源竞争问题（竞态） 3. 创建通道3.1 创建无缓冲通道通道是引用类型，需要使用make进行创建 通道实例 := make(chan数据类型) 数据类型：通道内传输的元素类型。 通道实例：通过make创建的通道句柄。 使用格式 // 创建一个整型类型的通道 intch := make(chan int) // 创建一个空接口类型的通道，可以存放任意格式 interfacech := make(chan interface{}) // 创建Mystruct指针类型的通道，可以存放＊Equip type Mystruct struct{ /* 一些字段 */ ... } structch := make(chan ＊Mystruct) 3.2 创建有缓冲通道在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。 声明格式 通道实例 := make(chan通道类型, 缓冲大小) 通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。 缓冲大小：决定通道最多可以保存的元素数量。 通道实例：被创建出的通道实例。 使用示例 func main() { //创建可以存放 3 map 类型通道 intCh := make(chan int, 3) //数据发送到通道中 intCh &lt;- 34 intCh &lt;- 20 intCh &lt;- 10 /* 注意: 当我们给通道写入数据时，不能超过其容量, 否则报错:fatal error: all goroutines are asleep - deadlock! */ //intCh &lt;- 1 } 当我们给通道写入数据时，不能超过其容量,否则报错:fatal error: all goroutines are asleep - deadlock! 3.3 带缓冲通道阻塞条件带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为0的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞。 带缓冲通道被填满时，尝试再次发送数据时发生阻塞。 带缓冲通道为空时，尝试接收数据时发生阻塞。 3.4 为什么对通道要限制长度？我们知道通道（channel）是在两个goroutine间通信的桥梁。使用goroutine的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。 3.5 单向通道声明只能发送的通道类型为: chan &lt;- x，只能接收的通道类型为: x &lt;- chan ch := make(chan int) // 声明一个只能发送的通道类型，并赋值为ch var ch Send Only chan&lt;- int = ch //声明一个只能接收的通道类型，并赋值为ch var ch Recv Only &lt;-chan int = ch 4.发送数据通道创建后，就可以使用特殊的操作符“&lt;-”，向通道进行发送或者从通道接收数据。 4.1 使用方法func main() { //创建可以存放 3 map 类型通道 intCh := make(chan int, 3) //数据发送到通道中 intCh &lt;- 34 intCh &lt;- 20 intCh &lt;- 10 /* 注意: 当我们给管写入数据时，不能超过其容量, 否则报错:fatal error: all goroutines are asleep - deadlock! */ //intCh &lt;- 1 } 5. 接收数据5.1 阻塞接收数据阻塞模式接收数据时，将接收变量作为“&lt;-”操作符的左值，格式如下: data := &lt;-ch 执行该语句时将会阻塞，直到接收到数据并赋值给data变量 5.2 非阻塞接收数据使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下： data, ok := &lt;-ch data：表示接收到的数据。未接收到数据时，data为通道类型的零值。 ok：表示是否接收到数据。 非阻塞的通道接收方法可能造成高的CPU占用，因此使用非常少。如果需要实现接收超时检测，可以配合select和计时器channel进行。 5.3 接收任意数据，忽略接收的数据阻塞接收数据后，忽略从通道返回的数据，格式如下： &lt;-ch 执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在goroutine间阻塞收发实现并发同步。 使用示例 func main() { intCh := make(chan int) start := time.Now() testNum := 10 go func() { fmt.Println(&quot;start goroutine....&quot;) for i := 0; i &lt; 3; i++ { testNum += i time.Sleep(time.Second) } //数据写入通道 intCh &lt;- testNum fmt.Println(&quot;end goroutine....&quot;) }() //等待匿名函数执行完成 fmt.Println(&quot;wait goroutine...&quot;) //执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略 &lt;-intCh diff := time.Now().Sub(start) fmt.Printf(&quot;testNum: %d\n&quot;, testNum) fmt.Println(&quot;耗时: &quot;, diff) } 6. channel 使用的注意事项 channle的容量放满后，就不能再放入了 channel中只能存放指定的数据类型 空接口类型的通道能接收任意参数 interfaceCh := make(chan interface{}, 4) //发送字符串 interfaceCh &lt;- &quot;hello&quot; //发送整型 interfaceCh &lt;- 100 //发送切片 interfaceCh &lt;- []int{1, 2, 3, 4} /* range函数遍历每个从通道接收到的数据，因为queue再发送完3个数据之后就关闭了通道，所以这里我们range函数在接收到3个数据之后就结束了。 如果上面的queue通道不关闭，那么range函数就不会结束，从而在接收第4个数据的时候就阻塞了。 */ close(interfaceCh) for data := range interfaceCh { fmt.Println(data) } 发送将持续阻塞直到数据被接收 通过range函数遍历通道接收数据时，要再发送完数据到通道后，用Close()函数显示的关闭通道，否则range函数就不会结束 通道一次只能接收一个数据元素 7. 使用select多路复用在使用通道时，想同时接收多个通道的数据是一件困难的事情。通道在接收数据时，如果没有数据可以接收将会发生阻塞。 虽然可以使用如下模式进行遍历，但运行性能会非常差。 //运行性能会非常差 for{ // 尝试接收ch1通道 data, ok := &lt;-ch1 // 尝试接收ch2通道 data, ok := &lt;-ch2 // 接收后续通道 … } Go语言中提供了select关键字，可以同时响应多个通道的操作。select的每个case都会对应一个通道的收发过程。当收发完成时，就会触发case中响应的语句。多个操作在每次select中挑选一个进行响应。 7.1 声明格式格式如下： select{ case 操作1: //响应操作1 case 操作2: //响应操作2 … default: //没有操作情况 } case &lt;- ch: 代表接收任意数据 case d:= &lt;-ch: 接收变量 case ch &lt;- 120: 发送数据到通道 7.2 使用示例//生成通道int ch intCh := make(chan int, 10) for i := 1; i &lt; 10; i++ { intCh &lt;- i } //生成通道string ch strCh := make(chan string, 10) for i := 1; i &lt; 10; i++ { strCh &lt;- &quot;String:&quot; + fmt.Sprintf(&quot;%d&quot;, i) } /* 传统的方法在遍历管道时，如果不关闭会阻塞,从而导致deadlock，在实际开发中，可能我们不好确定什么关闭该管道, 可以使用 select 方式可以解决 */ //使用select for { select { case v := &lt;-intCh: fmt.Println(&quot;intCH: &quot;, v) case v := &lt;-strCh: fmt.Println(&quot;strCh: &quot;, v) default: fmt.Println(&quot;Noting!&quot;) return } }]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-并发使用]]></title>
    <url>%2F2018%2F05%2F07%2FGo-7.%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 并发和并行1.1 并发多线程程序在单核上运行，就是并发 1.1.1 并发的特点 多个任务作用在一个cpu 从微观角度看，在一个时间点上，只有一个任务在执行 1.2 并行多线程程序在多核上运行，就是并行 1.2.1 并行的特点 多个任务作用在多个cpu 从微观角度看，在一个时间点上，有多个任务在执行 2. Go 协程和 Go 主线程2.1 关系介绍 主线程是一个物理线程，直接作用在 cpu 上的。是重量级的，非常耗费 cpu 资源。 协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。 Go的协程机制是重要的特点，可以轻松的开启上万个协程。其它编程语言的并发机制是一般基于线程的，开启过多的线程，资源耗费大，这里就突显 Go在并发上的优势了 2.2 Go主进程和Go协程（goroutine）关系示意图 2.3 Go协程的特点 有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程 3. Go协程（Goroutine）的使用Go程序中使用go关键字为一个函数创建一个goroutine。一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数。 3.1 使用方式3.1.1 普通函数创建goroutine使用格式 go 函数名 ( 参数列表 ) 函数名：要调用的函数名。 参数列表：调用函数需要传入的参数。 使用go关键字创建goroutine时，被调用函数的返回值会被忽略。如果需要在goroutine中返回数据，则需要通过通道（channel）把数据从goroutine中作为返回值传出。 使用示例 package main import ( &quot;fmt&quot; &quot;time&quot; &quot;strconv&quot; ) func test() { var i =1 for { fmt.Println(&quot;&quot;+strconv.Itoa(i)) time.Sleep(time.Second) i++ } } func main() { // 为一个普通函数创建goroutine go test() //接收用户输入,知道按Enter键时 var input string //将用户输入内容写入input变量中，并返回，整个程序终止 fmt.Scanln(&amp;input) } 输出： 1 2 3 4 5 6 ... exit 所有goroutine在mian()函数结束时会一同结束 3.1.2 匿名函数创建goroutinego关键字后也可以为匿名函数或闭包启动goroutine 使用格式使用匿名函数或闭包创建goroutine时，除了将函数定义部分写在go的后面之外，还需要加上匿名函数的调用参数 go func( 参数列表 ){ 函数体 }( 调用参数列表 ) 参数列表：函数体内的参数变量列表。 函数体：匿名函数的代码。 调用参数列表：启动goroutine时，需要向匿名函数传递的调用参数 使用示例 package main import ( &quot;fmt&quot; &quot;time&quot; ) func main() { go func() { var i int for { fmt.Println(&quot;计时器:&quot;, i) time.Sleep(time.Second) i++ } }() var input string fmt.Scanln(&amp;input) } 3.2 并发运行性能调整3.2.1 设置运行的 cpu 数为了充分了利用多 cpu 的优势，在 Golang 程序中，可以通过runtime.GOMAXPROCS() 函数 设置运行的 cpu 数目 使用格式: runtime.GOMAXPROCS( 逻辑CPU) //逻辑CPU可以通过 runtime.NumCpu()函数获取 这里的逻辑CPU数量可以有如下几种数值: 逻辑CPU &lt; 1：不修改任何数值 逻辑CPU = 1：单核心执行 逻辑CPU &gt; 1：多核并发执行 注意事项: Go 1.5版本之前，默认使用的是单核心执行。从Go 1.5版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用CPU。 GOMAXPROCS同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-接口]]></title>
    <url>%2F2018%2F04%2F14%2FGo-6.%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Go 语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。但是 Go 语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性 1. 什么是interface(接口)简单地说，interface是一组method的组合，但是这些method不包含（实现）代码,我们通过interface来定义对象的一组行为。 接口里不能包含变量 2. 接口声明type Namer interface { Method1(参数列表1) 返回值列表1 Method2(参数列表2) 返回值列表 ... } 示例 // 变量名未忽略 type writer interface{ Write(p []byte) (n int, err error) } // 变量名被忽略 type writer interface{ Write([]byte) (int, error) } 3. 接口规范 接口类型名：方法的接口名,由方法名加 [e]r 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头。 方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略， Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想 4. 接口嵌套(接口继承) 在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。接口与接口嵌套组合而成了新接口，只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用 比如接口 File 包含了 ReadWrite 和 Lock 的所有方法，它还额外有一个 Close() 方法 type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Lock interface { Lock() Unlock() } type File interface { ReadWrite Lock Close() } 一个接口(比如 A 接口)可以继承多个别的接口(比如 B,C 接口)，这时如果要实现 A 接口，也必须将 B,C 接口的方法也全部实现 5. 接口实现如果一个类型实现了一个接口里的所有方法，那么这个类型就实现了这个接口 如下面示例，类型fileHandle 实现了DataWrite接口: type DataWrite interface { Write(data interface{}) error } type fileHandle struct { .... } func (f fileHandle)Write(data interface{}) error { fmt.Println(&quot;文件写入中....&quot;) return nil } 6.类型与接口的关系类型和接口之间有一对多和多对一的关系。 6.1 一对多一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 // 定义Writer接口 type Writer interface{ Write([]byte) int } // 定义Reader接口 type Reader interface{ Read() } // 定义一个File类型 type File struct { } // File类型 实现Writer接口 func (f File)Write(p []byte) int { return 0 } // File类型 定义Reader接口 func (f File)Read() { } 6.2 多对一一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。 示例分析 Service接口定义了两个方法：一个是开启服务的方法:Start()，一个是输出日志的方法:Log()。使用GameService结构体来实现Service，GameService结构只能实现Start()方法，Service接口中的Log()方法被日志器（Logger）实现了，将Logger嵌入到GameService中，则达成了GameService结构体实现Service接口，从而能最大程度地避免代码冗余，简化代码结构。 详细实现过程如下： 01 // 一个服务需要满足能够开启和写日志的功能 02 type Service interface { 03 Start() // 开启服务 04 Log(string) // 日志输出 05 } 06 07 // 日志器 08 type Logger struct { 09 } 10 11 // 实现Service的Log()方法 12 func (g ＊Logger) Log(l string) { 13 14 } 15 16 // 游戏服务 17 type GameService struct { 18 Logger // 嵌入日志器 19 } 20 21 // 实现Service的Start()方法 22 func (g ＊GameService) Start() { 23 } 代码说明如下： 第2行，定义服务接口，一个服务需要实现Start()方法和日志方法。 第8行，定义能输出日志的日志器结构。 第12行，为Logger添加Log()方法，同时实现Service的Log()方法。 第17行，定义GameService结构 第18行，在Game Service中嵌入Logger日志器，以实现日志功能。 第22行，Game Service的Start()方法实现了Service的Start()方法。 此时，实例化GameService，并将实例赋给Service，代码如下： var s Service = new(Game Service) s.Start() s.Log(&quot;hello&quot;) s就可以使用Start()方法和Log()方法，其中，Start()由GameService实现，Log()方法由Logger实现。 7. 接口和类型间转换Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。 7.1 类型断言的格式如果发生接口未实现时，将会把ok置为false，t置为T类型的0值。正常实现时，ok为true。这里ok可以被认为是：i接口是否实现T类型的结果。 类型断言的基本格式如下： t,ok := i.(T) i 代表接口变量。 T 代表转换的目标类型。 t 代表转换后的变量。 7.2 将接口转为其他接口实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。 代码示例 鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的Fly()和Walk()方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。将鸟和猪的实例创建后，被保存到interface{}类型的map中。interface{}类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的interface{}变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回false。 实现代码如下： 01 package main 02 03 import &quot;fmt&quot; 04 05 // 定义飞行动物接口 06 type Flyer interface { 07 Fly() 08 } 09 10 // 定义行走动物接口 11 type Walker interface { 12 Walk() 13 } 14 15 // 定义鸟类 16 type bird struct { 17 } 18 19 // 实现飞行动物接口 20 func (b ＊bird) Fly() { 21 fmt.Println(&quot;bird: fly&quot;) 22 } 23 24 // 为鸟添加Walk()方法，实现行走动物接口 25 func (b ＊bird) Walk() { 26 fmt.Println(&quot;bird: walk&quot;) 27 } 28 29 // 定义猪 30 type pig struct { 31 } 32 33 // 为猪添加Walk()方法，实现行走动物接口 34 func (p ＊pig) Walk() { 35 fmt.Println(&quot;pig: walk&quot;) 36 } 37 38 func main() { 39 40 // 创建动物的名字到实例的映射 41 animals := map[string]interface{}{ 42 &quot;bird&quot;: new(bird), 43 &quot;pig&quot;: new(pig), 44 } 45 46 // 遍历映射 47 for name, obj := range animals { 48 49 // 判断对象是否为飞行动物 50 f, isFlyer := obj.(Flyer) 51 // 判断对象是否为行走动物 52 w, isWalker := obj.(Walker) 53 54 fmt.Printf(&quot;name: %s is Flyer: %v is Walker: %v\n&quot;, name, is Flyer, is Walker) 55 56 // 如果是飞行动物则调用飞行动物接口 57 if isFlyer { 58 f.Fly() 59 } 60 61 // 如果是行走动物则调用行走动物接口 62 if isWalker { 63 w.Walk() 64 } 65 } 66 } 代码说明如下： 第6行定义了飞行动物的接口。 第11行定义了行走动物的接口。 第16和30行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。 第41行是一个map，映射对象名字和对象实例，实例是鸟和猪。 第47行开始遍历map，obj为interface{}接口类型。 第50行中，使用类型断言获得f，类型为Flyer及isFlyer的断言成功的判定。 第52行中，使用类型断言获得w，类型为Walker及isWalker的断言成功的判定。 第57和62行，根据飞行动物和行走动物两者 代码输出如下： name: pig is Flyer: false is Walker: true pig: walk name: bird is Flyer: true is Walker: true bird: fly bird: walk 8.空接口 — 能保存所有值的类型空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。 8.1 将值保存到空接口01 var any interface{} 02 03 any = 1 04 fmt.Println(any) 05 06 any = &quot;hello&quot; 07 fmt.Println(any) 08 09 any = false 10 fmt.Println(any) 代码输出如下： 1 hello false 第1行，声明any为interface{}类型的变量。 第3行，为any赋值一个整型1。 第4行，打印any的值，提供给fmt.Println的类型依然是interface{}。 第6行，为any赋值一个字符串hello。此时any内部保存了一个字符串。但类型依然是interface{}。 第9行，赋值布尔值。 8.2 从空接口获取值保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误 代码如下： 01 // 声明a变量，类型int，初始值为1 02 var a int = 1 03 04 // 声明i变量，类型为interface{}，初始值为a，此时i的值变为1 05 var i interface{} = a 06 07 // 声明b变量，尝试赋值i 08 var b int = i 第8行代码编译报错： cannot use i (type interface {}) as type int in assignment: need type assertion 编译器告诉我们，不能将i变量视为int类型赋值给b。在代码第5行中，将a的值赋值给i时，虽然i在赋值完成后的内部值为int，但i还是一个interface{}类型的变量。 为了让第8行的操作能够完成，编译器提示我们得使用type assertion，意思就是类型断言。 使用类型断言修改第8行代码如下： var b int = i.(int) 修改后，代码可以编译通过，并且b可以获得i变量保存的a变量的值：1。 8.3 空接口的值比较空接口在保存不同的值后，可以和其他变量值一样使用“==”进行比较操作。空接口的比较有以下几种特性。 8.3.1 类型不同的空接口间的比较结果不相同保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下： 01 // a保存整型 02 var a interface{} = 100 03 04 // b保存字符串 05 var b interface{} = &quot;hi&quot; 06 07 // 两个空接口不相等 08 fmt.Println(a == b) // 输出: false 8.3.2 不能比较空接口中的动态值当接口中保存有动态类型的值时，运行时将触发错误， 代码如下： 01 // c保存包含10的整型切片 02 var c interface{} = []int{10} 03 04 // d保存包含20的整型切片 05 var d interface{} = []int{20} 06 07 // 这里会发生崩溃 08 fmt.Println(c == d) 代码运行到第8行时发生崩溃： panic: runtime error: comparing uncomparable type []int 这是一个运行时错误，提示[]int是不可比较的类型。zhuoge 下面列出了几种类型及比较情况 类型 说明 map 宕机错误，不可比较 切片（[]T） 宕机错误，不可比较 通道（channel） 可比较，必须由一个make生成，也就是说同一个通道才会true，否则false 数组([容量]T) 可比较，编译期知道两个数组是否一致 结构体 可比较，可以逐个比较结构体的值 9.接口使用中的注意事项 接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例) package main import &quot;fmt&quot; type PeopleI interface { GetName() string } type Girl struct { Name string } func (g Girl) GetName() string { return g.Name } func main() { var p PeopleI var g Girl g.Name = &quot;小花&quot; p = g //指向一个实现了该接口的自定义类型的变量 fmt.Println(p.GetName()) } 接口中所有的方法都没有方法体,即都是没有实现的方法。 在 Go中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现 了该接口。 一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型 一个自定义类型可以实现多个接口 Go接口中不能有任何变量 interface类型默认是一个指针(引用类型)，如果没有对interface初始化就使用，那么会输出nil 空接口 interface{} 没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量 赋给空接口]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-方法]]></title>
    <url>%2F2018%2F04%2F11%2FGo-5.%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct 1.方法的声明Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收器（Receiver）。如果将特定类型理解为结构体或“类”时，接收器的概念就类似于其他语言中的this或者self。在Go语言中，接收器的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 1.1 声明格式func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } 接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是self、this之类的命名。例如，Socket类型的接收器变量应该命名为s，Connector类型的接收器变量应该命名为c等。 接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：格式与函数定义一致。 1.2 声明示例type people struct { Name, Like , Sex string Height, Weight float32 } func (p people) walk() { fmt.Println(p.Name + &quot; 在行走...&quot;) } func RunStruct() { var xiaomi people xiaomi.Name = &quot;小明&quot; xiaomi.Name = &quot;小明&quot; p := people{&quot;小明&quot;,&quot;跑步&quot;, &quot;男&quot;, 170.0, 62.6} p.walk() } func main() { RunStruct() //out: 小明 在行走... } 2.接收器分类2.1 指针类型的接收器理解指针类型的接收器指针类型的接收器由一个结构体的指针组成，由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。 在下面的例子，使用结构体定义一个属性（Property），为属性添加SetValue()方法以封装设置属性的过程，通过属性的Value()方法可以重新获得属性的数值。使用属性时，通过SetValue()方法的调用，可以达成修改属性值的效果。 01 package main 02 03 import &quot;fmt&quot; 04 05 // 定义属性结构 06 type Property struct { 07 value int // 属性值 08 } 09 10 // 设置属性值 11 func (p ＊Property) SetValue(v int) { 12 13 // 修改p的成员变量 14 p.value = v 15 } 16 17 // 取属性值 18 func (p ＊Property) GetValue() int { 19 return p.value 20 } 21 22 func main() { 23 24 // 实例化属性 25 p := new(Property) 26 27 // 设置值 28 p.SetValue(100) 29 30 // 打印值 31 fmt.Println(p.GetValue()) 32 // out: 100 33 } 代码说明如下： 第6行，定义一个属性结构，拥有一个整型的成员变量。 第11行，定义属性值的方法。 第14行，设置属性值方法的接收器类型为指针。因此可以修改成员值，即便退出方法，也有效。 第18行，定义获取值的方法。 第25行，实例化属性结构。 第28行，设置值。此时成员变量变为100。 第31行，获取成员变量。 2.2 非指针类型的接收器当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。点（Point）使用结构体描述时，为点添加Add()方法，这个方法不能修改Point的成员X、Y变量，而是在计算后返回新的Point对象。Point属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。 01 package main 02 03 import ( 04 &quot;fmt&quot; 05 ) 06 07 // 定义点结构 08 type Point struct { 09 X int 10 Y int 11 } 12 13 // 非指针接收器的加方法 14 func (p Point) Add(other Point) Point { 15 16 // 成员值与参数相加后返回新的结构 17 return Point{p.X + other.X, p.Y + other.Y} 18 } 19 20 func main() { 21 22 // 初始化点 23 p1 := Point{1, 1} 24 p2 := Point{2, 2} 25 26 // 与另外一个点相加 27 result := p1.Add(p2) 28 29 // 输出结果 30 fmt.Println(result) 31 // out: {3 3} 32 } 代码说明如下： 第8行，定义一个点结构，拥有X和Y两个整型分量。 第14行，为Point结构定义一个Add()方法。 第23和24行，初始化两个点p1和p2。 第27行，将p1和p2相加后返回结果。 第30行，打印结果。 由于例子中使用了非指针接收器，Add()方法变得类似于只读的方法，Add()方法内部不会对成员进行任何修改。 2.3 指针和非指针接收器的使用 小对象由于值复制时的速度较快，适合使用非指针接收器。 大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。 3. 嵌入结构体扩展类型结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为类型内嵌或匿名字段 类型内嵌的写法如下： 01 type Data struct { 02 int 03 float32 04 bool 05 } 06 07 ins := &amp;Data{ 08 int: 10, 09 float32: 3.14, 10 bool: true, 11 } 代码说明如下： 第2～4行定义结构体中的匿名字段，类型分别是整型、浮点、布尔。 第8～10行将实例化的Data中的字段赋初值。 类型内嵌其实仍然拥有自己的字段名，只是字段名就是其类型本身而已，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。结构体实例化后，如果匿名的字段类型为结构体，那么可以直接访问匿名结构体里的所有成员，这种方式被称为结构体内嵌。 3.1 结构内嵌特性Go语言的结构体内嵌有如下特性。 3.1.1 内嵌的结构体可以直接访问其成员变量嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。 3.1.2 内嵌结构体的字段名是它的类型名内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下： ... type people struct { Name, Sex string Height, Weight float32 } type boy struct { people Like string } func RunStruct() { var b1 boy b1.Height = 175 //详细的字段进行一层层访问 fmt.Println(b1.people.Height) } 一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。 3.2 使用组合描述对象特性Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。下面的代码使用Go语言的结构体内嵌实现对象特性组合，请参考代码6-10。代码6-10 人和鸟的特性（具体文件：…/chapter06/humanbird/humanbird.go） 01 package main 02 03 import &quot;fmt&quot; 04 05 // 可飞行的 06 type Flying struct{} 07 08 func (f ＊Flying) Fly() { 09 fmt.Println(&quot;can fly&quot;) 10 } 11 12 // 可行走的 13 type Walkable struct{} 14 15 func (f ＊Walkable) Walk() { 16 fmt.Println(&quot;can calk&quot;) 17 } 18 19 // 人类 20 type Human struct { 21 Walkable // 人类能行走 22 } 23 24 // 鸟类 25 type Bird struct { 26 Walkable // 鸟类能行走 27 Flying // 鸟类能飞行 28 } 29 30 func main() { 31 32 // 实例化鸟类 33 b := new(Bird) 34 fmt.Println(&quot;Bird: &quot;) 35 b.Fly() 36 b.Walk() 37 38 // 实例化人类 39 h := new(Human) 40 fmt.Println(&quot;Human: &quot;) 41 h.Walk() 42 43 } //运行结果 Bird: can fly can calk Human: can calk 代码说明如下： 第6行，声明可飞行结构（Flying）。 第8行，为可飞行结构添加飞行方法Fly()。 第13行，声明可行走结构（Walkable）。 第15行，为可行走结构添加行走方法Walk()。 第20行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备“可行走”特性 第25行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。 第33行，实例化鸟类结构。 第35和36行，调用鸟类可以使用的功能，如飞行和行走。 第39行，实例化人类结构。 第41行，调用人类能使用的功能，如行走。 4. 注意事项 对于一个具体类型T，部分方法的接收者是T，而且其他方法的接收者是*T。同时我们对类型T的变量直接调用接收者是*T的方法是合法的，编译器隐私的帮你完成了取址的操作。但是不能直接通过类型调用 type DataWrite interface { Write(data interface{}) error } type fileHandle struct { } func (f *fileHandle)Write(data interface{}) error { fmt.Println(&quot;文件写入中....&quot;) return nil } func RunInterface() { // 通过变量可以直接调用接收者是*T var f fileHandle var _ = f.Write(&quot;...&quot;) // 不能直接调用接收者是*T // var _ = fileHandle{}.Write(&quot;..&quot;) /* 此处代码会报错： ...: cannot call pointer method on fileHandle literal ...: cannot take the address of fileHandle literal */ }]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-结构体使用]]></title>
    <url>%2F2018%2F04%2F09%2FGo-4.%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[结构体（struct）是Go支持面向对象编程特性的基础 1.声明结构体结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。因此必须在定义结构体并实例化后才能使用结构体的字段。 实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。 1.1 基本语法type 结构体名称 struct { field type field type } 字段直接没有逗号（,） field: 从概念或叫法上称: 结构体字段、属性 type：一般是基本数据类型、数组,也可是引用类型 同类型变量可以写在一行type Human struct { name string age,sex,height int } 2.结构体实例化2.1 基本实例化形式（使用关键字: var）type Girl struct { Name string } func UseStruct() { //使用关键字var var g Girl g.Name = &quot;小芳&quot; fmt.Println(g) // 输出: {小芳 0 0 0} } 上述变量 g 为结构体的实例 2.2 创建指针类型的结构体（使用关键字: new）type Girl struct { Name string } func UseStruct() { // 使用new g1 := new(Girl) g1.Name = &quot;小芳&quot; fmt.Println(g1) // 输出: &amp;{小芳 0 0 0} } Girl类型被实例化后保存到g1变量中，g1的类型为*Girl，属于指针 经过new实例化的结构体实例在成员赋值上与基本实例化的写法一 2.3 取结构的地址实例化（使用: &amp;）在Go语言中，对结构体进行“&amp;”取地址操作时，视为对该类型进行一次new的实例化操作 type Girl struct { Name string } func UseStruct() { // 使用&amp; g2 := &amp;Girl{} g2.Name = &quot;小芳&quot; fmt.Println(g2) // 输出: &amp;{小芳 0 0 0} } 3. 初始化结构体字段用例3.1 递归填充type Family struct { name string child *Family } func UseStruct() { p := Family{ name: &quot;爷爷&quot;, child: &amp;Family{ name: &quot;爸爸&quot;, child: &amp;Family{ name: &quot;我&quot;, }, }, } fmt.Println(p.name) // 爷爷 fmt.Println(p.child.name) //爸爸 fmt.Println(p.child.child.name) // 我 } 3.2 多值初始化type Girl struct { Name string Age int Height int Weight float32 } func CreateStruct() { // 顺序填充 g1 := Girl{&quot;小花&quot;, 18, 170, 55.4} fmt.Println(g1) // {小花 18 170 55.4} // 指定字段填充 g := Girl{Name:&quot;小雨&quot;, Age:19} fmt.Println(g) // {小雨 19 0 0} } 3.3 匿名结构体初始化结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体 package main import &quot;fmt&quot; type Human struct { Name string Age, Sex int } type Girl struct { Human //匿名字段 Like string } func main() { p := Girl{Human{Name: &quot;小芳&quot;, Age: 18}, &quot;唱歌&quot;} fmt.Println(p) } 4. 带标签的结构体struct 的每个字段上，可以写上一个 tag, 该 tag可以通过反射机制获取，常见的使用场景就是序 列化和反序列化。 4.1 使用示例package main import ( &quot;reflect&quot; &quot;fmt&quot; ) type SchoolTag struct { Name string `school name` Address string `school address` Tel string `school tel` } func main() { schTag := SchoolTag{&quot;名牌大学&quot;, &quot;天朝1号&quot;, &quot;010-1234560&quot;} count := reflect.ValueOf(schTag).NumField() for i := 0; i &lt; count; i++ { fmt.Printf(&quot;%v\n&quot;,reflect.TypeOf(schTag).Field(i).Tag) } } 5. 结构体比较如果结构体的所有成员变量都可以比较，那么这个结构体就是可比较的。两个结构体的比较用 == 或者 != 其中== 按照顺序比较两个结构体变量的成员 package main import &quot;fmt&quot; type Point struct { X, Y int } func main() { p1 := Point{1,2} p2 := Point{1,3} //表达式1 fmt.Println(p1.X == p2.X &amp;&amp; p1.Y == p2.Y) //false //表达式2 fmt.Println(p1 == p2) //false } 表达式1和表达式2 是等价的 可比较的结构体都可以作为map的键类型 示例（统计某个链接的点击次数): package main import &quot;fmt&quot; type UrlCount struct { Controller, Action string } func main() { m := make(map[UrlCount]int) for i := 0; i &lt; 5; i++ { m[UrlCount{&quot;home&quot;, &quot;index&quot;}]++ } fmt.Println(m) // map[{home index}:5] } 6. 结构体特性 在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值) 结构体是值类型，默认为值拷贝 字段名必须唯一 结构体的所有字段在内存中是连续的 结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型) package main import &quot;fmt&quot; type A struct { X, Y int } type B struct { X, Y int } func main() { var a A var b B a = A(b) // 类型转换时，需要有完全相同的字段(名字、个数和类型) fmt.Printf(&quot;%T \n&quot;,a) fmt.Printf(&quot;%T \n&quot;,b) } 结构体进行 type 重新定义(相当于取别名)，Go 认为是新的数据类型，但是相互间可以强转 package main type Human struct { Name string Age int } type Boy Human func main() { var h Human var b Boy //这么写错误,原因:Go认为Boy是新的数据类型 // h == b //可以相互间强转 b = Boy(h) h = Human(b) } 7.结构体和结构体变量(实例)的区别和联系 结构体是自定义的数据类型，代表一类事物. 结构体变量(实例)是具体的，实际的，代表一个具体变量]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-函数使用]]></title>
    <url>%2F2018%2F04%2F08%2FGo-3.%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[函数使用 函数是Go语言里面的核心设计，它通过关键字func来声明，它的格式如下。 1. 函数声明func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) { //这里是处理逻辑代码 //返回多个值 return value1, value2 } 关键字func用来声明一个函数funcName。 函数可以有一个或者多个参数，每个参数后面带有类型，通过“,”分隔函数可以返回多个值。 返回值声明了两个变量output1和output2，如果你不想声明也可以，就保留两个类型声明。 如果只有一个返回值且不声明返回值变量，那么你可以省略“包括返回值”的括号 如果没有返回值，就直接省略最后的返回信息。 如果有返回值，那么必须在函数的外层添加return语句。 2. 接收变参的函数func funcName(input ...type) (output1 type1, output2 type2) { //这里是处理逻辑代码 //返回多个值 return output1 type1, output2 type2 } 注意，这些参数的类型全部是type。在函数体中，变量input是一个type的slice。 使用示例 package main import &quot;fmt&quot; func main() { result := joinStr(&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;) fmt.Println(result) // hello } func joinStr(input ...string) (strRes string) { for _, v := range input { strRes += v } return } 3. 参数传递 Go 默认使用按值传递参数,也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量。如果想要影响到原来的变量，则需要传指针。需要注意的是:切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显示的指出指针） 3.1 按值传递使用示例package main import &quot;fmt&quot; func main() { str := &quot;good morning&quot; updateStr(str) fmt.Println(str) // good morning } func updateStr(str string) string { str = &quot;good evening&quot; return str } 3.2 按引用使用示例package main import &quot;fmt&quot; func main() { str := &quot;good morning&quot; updateStr(&amp;str) fmt.Println(str) // good evening } func updateStr(str *string) string { *str = &quot;good evening&quot; return *str } 4.延迟语句（defer）的使用 Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些 defer 语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。 4.1 使用示例package main import ( &quot;fmt&quot; &quot;os&quot; &quot;io/ioutil&quot; ) func main() { filePath := &quot;/Users/liuqh/Desktop/test.json&quot; str := openFile(filePath) fmt.Println(str) //输出以下内容 //defer 被调用了 //文件里的内容 } func openFile(filePath string) string { //打开文件 file, err := os.Open(filePath) if err != nil { fmt.Println(&quot;open file err&quot;) } //利用defer 关闭文件 defer testDefer(file) content, err := ioutil.ReadAll(file) if err != nil { fmt.Println(&quot;read file err&quot;) } return string(content) } func testDefer(file *os.File) { fmt.Println(&quot;defer 被调用了&quot;) file.Close() } 4.2 函数中使用多个defer 如果有一个函数中有多个地方调用defer,那么defer采用后进先出(逆序执行) package main import ( &quot;fmt&quot; ) func main() { testDefer() // 5 4 3 2 1 } func testDefer() { for i := 1; i &lt; 6; i++ { defer fmt.Println(i) } } 5.函数作为值、类型 在Go语言中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值。 type typeName func(input1 inputType1,input2 inputType2[,...])(result1 resultType1 [, ...]) 5.1 使用示例package main import &quot;fmt&quot; type testInt func(int) bool func main() { numSlice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} odd := filter(numSlice, isOdd) event := filter(numSlice, isEvent) fmt.Println(odd) // [2 4 6 8] fmt.Println(event) // [1 3 5 7 9] } func isOdd(num int) bool { if num%2 == 0 { return true } return false } func isEvent(num int) bool { if num%2 == 0 { return false } return true } func filter(arg []int, funcName testInt) []int { var result []int for _, v := range arg { if funcName(v) { result = append(result, v) } } return result } 6.匿名函数既没有名称的函数 6.1 使用示例package main import &quot;fmt&quot; func main() { f := func(a,b int) int{ i := a + b return i } fmt.Println(f(1,4)) // 5 }]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-字符串操作]]></title>
    <url>%2F2018%2F04%2F06%2FGo%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在GO中字符串是用双引号(“”)或反引号()括起来，而且字符串不可变 1.修改字符串字符串不能修改，否则报错,如下代码:go var s string = &quot;hello word&quot; s[0] =`a` //报错 # command-line-arguments ...cannot assign to str[0]通过转[]byte类型修改字符串go var s string = &quot;hello word&quot; slice := []byte(s) slice[0] =&#39;H&#39; newStr := string(slice) fmt.Println(newStr)&gt; 此处的 slice[0] =’H’ 不能写成 slice[0] =”H”,否则会报错:cannot use “H” (type string) as type byte in assignment 2.字符串转[]byte 类型var s string = &quot;hello word&quot; sic := []byte(s) 3.字符串转整型n, err := strconv.Atoi(&quot;12&quot;) if err != nil { fmt.Println(&quot;转换失败&quot;) } fmt.Println(n) 4.字符串连接//字符串连接 a, b := &quot;hello&quot;, &quot; word&quot; c := a + b fmt.Println(c) 5.声明多行字符串str := ` hello, nice to meet you` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。 6.字符串拼接和分割使用函数:strings.Join 和 strings.Split//切片转 以x拼接成 字符串 fmt.Println(&quot;Join: &quot;, strings.Join([]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, &quot;-&quot;)) //输出：Join: a-b-c // 字符串 以x分割成 切片 fmt.Println(&quot;Split: &quot;, strings.Split(&quot;a-b-c-d-e&quot;, &quot;-&quot;)) //输出：Split: [a b c d e] // 去除字符串s中的空格符, 并按照空格(可以是一个或者多个空格)分割字符串, 返回slice func Fields(s string) []string str := &quot;nice to meet you&quot; slice := strings.Fields(str) // [nice to meet you]#### 7.字符串比较使用函数:strings.Comparego fmt.Println(strings.Compare(string(&quot;hello&quot;), string(&quot;haha&quot;))) // 1 fmt.Println(strings.Compare(string(&quot;hello&quot;), string(&quot;helloworld&quot;))) // -1 fmt.Println(strings.Compare(string(&quot;hello&quot;), string(&quot;hello&quot;))) //0 // Compare函数:源码 func Compare(a, b string) int { if a == b { return 0 } if a &lt; b { return -1 } return +1 }#### 8.字符串查找使用函数:strings.Contains、Index、LastIndex、Count // 判断给定字符串s中是否包含子串substr, 找到返回true, 找不到返回false func Contains(s, substr string) bool fmt.Println(strings.Contains(&quot;hello word&quot;, &quot;hell&quot;)) // true fmt.Println(strings.Contains(&quot;hello word&quot;, &quot;hella&quot;)) // false fmt.Println(strings.Contains(&quot;&quot;, &quot;&quot;)) // true // 在字符串s中查找sep第一次出现的位置, 返回位置值, 找不到返回-1 func Index(s, sep string) int // 在字符串s中查找sep最后一次出现的位置, 返回位置值, 找不到返回-1 func LastIndex(s, sep string) int fmt.Println(strings.Index(&quot;abcdefga&quot;, &quot;a&quot;)) //0 fmt.Println(strings.LastIndex(&quot;abcdefga&quot;, &quot;a&quot;))//7 // 统计给定子串sep的出现次数, sep为空时, 返回1 + 字符串的长度 func Count(s, sep string) int fmt.Println(strings.Count(&quot;hello&quot;, &quot;l&quot;))//2 fmt.Println(strings.Count(&quot;hello&quot;, &quot;&quot;))//6 9.字符串重复// 重复s字符串count次, 最后返回新生成的重复的字符串 func Repeat(s string, count int) string fmt.Println(strings.Repeat(&quot;hello&quot;, 2)) //hellohello 10.字符串大小写转换// 首字母大写 func Title(s string) string fmt.Println(strings.Title(&quot;hello&quot;)) //Hello // 所有字母转换为小写 func ToLower(s string) string fmt.Println(strings.ToLower(&quot;HELLO&quot;)) //hello // 所有字母转换为大写 func ToUpper(s string) string fmt.Println(strings.ToUpper(&quot;hello&quot;)) //HELLO 11.字符串前缀后缀 大小写敏感 // 判断字符串是否包含前缀prefix func HasPrefix(s, prefix string) bool fmt.Println(strings.HasPrefix(&quot;Golang&quot;, &quot;Go&quot;)) // true fmt.Println(strings.HasPrefix(&quot;Golang&quot;, &quot;go&quot;)) // false fmt.Println(strings.HasPrefix(&quot;Golang&quot;, &quot;a&quot;)) // false fmt.Println(strings.HasPrefix(&quot;Golang&quot;, &quot;&quot;)) // true // 判断字符串是否包含后缀suffix, func HasSuffix(s, suffix string) bool fmt.Println(strings.HasSuffix(&quot;Golang&quot;, &quot;ang&quot;)) // true fmt.Println(strings.HasSuffix(&quot;Golang&quot;, &quot;Ang&quot;)) // false fmt.Println(strings.HasSuffix(&quot;Golang&quot;, &quot;bng&quot;)) // false fmt.Println(strings.HasSuffix(&quot;Golang&quot;, &quot;&quot;)) // true 12.字符串删除// 删除在s字符串的头部和尾部中由cutset指定的字符, 并返回删除后的字符串 func Trim(s string, cutset string) string fmt.Println(strings.Trim(&quot;@hello word@&quot;,&quot;@&quot;)) // hello word 13.字符串替换// 在s字符串中, 把old字符串替换为new字符串，n表示替换的次数，小于0表示全部替换 func Replace(s, old, new string, n int) string fmt.Println(strings.Replace(&quot;hello word&quot;,&quot;o&quot;,&quot;@&quot;,1)) // hell@ word fmt.Println(strings.Replace(&quot;hello word&quot;,&quot;o&quot;,&quot;@&quot;,-1)) // hell@ w@rd]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-程序结构]]></title>
    <url>%2F2018%2F04%2F03%2FGo-1.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[程序结构 包声明 引入包 函数 变量 语句 &amp; 表达式 注释 以实际代码进行讲解: /* 这是包声明 */ package main /* 这是引入包 */ import &quot;fmt&quot; /* 这是函数 */ func main() { /* 这是变量 */ str := &quot;hello word&quot; /* 这是语句 */ fmt.Println(str) } 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包。 每个 Go 应用程序都包含一个名为 main 的包 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数。 如果有 init() 函数则会先执行init()函数 go语言中注释 单行用:// ，或者 /*…*/ func main() { // str := &quot;hello word&quot; fmt.Println(str) } go语言中一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号分号(;) 结尾 其他约定 大写字母开头的变量是可导出的，即其他包可以读取，是公用变量；小写字母开头的不可导出，是私有变量。 大写字母开头的函数也是一样，相当于class中带public关键词的公有函数；小写字母开头就是有private关键词的私有函数]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-基础篇-变量及数据类型]]></title>
    <url>%2F2018%2F04%2F03%2FGo-2.%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.变量声明1.1 使用var关键字 var 变量名 变量类型 = [变量值] //定义多个变量 var vname1,vname2,vname3 type //定义变量,并初始化 var vname1 int = 1 //同时初始化多个变量 var vname1,vname2,vname3 = v1,v2,v3 1.2 使用 :=//定义变量,并初始化 vname1 := 1 //同时初始化多个变量 vname1,vname2,vname3 := v1,v2,v3 // 示例: var a, b, c = 3, 4, &quot;foo&quot; 1.3 分组声明在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明 // 同时导入多个包 import ( &quot;fmt&quot; &quot;errors&quot; ) // 声明多个常量 const ( i = 100, pi = 3.14 prex = &quot;Go_&quot; ) // 声明多个变量 var ( a int, b string = &quot;hello&quot;, ) 1.4 特殊变量: _(下划线)任何赋予它的值都会被丢弃,Go语言对于已声明但未使用的变量会在编译阶段报错,可以通过其来丢弃 _, b := 1,2 1.5 make和new: new(T) 返回的是T的指针new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是T类型的指针 *T，该指针指向T的新分配的零值。 make 只能用于 slice，map，channel 三种类型:make(T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。 2.基础类型2.1 整数整数类型有无符号和带符号两种。Go语言同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。当前的gcc和gccgo编译器在32位和64位平台上都使用32位来表示int和uint，但未来在64位平台上可能增加到64位。Go语言里面也有直接定义好位数的类型：rune，int8，int16，int32，int64和byte，uint8，uint16，uint32，uint64。其中rune是int32的别称，byte是uint8的别称 2.2 浮点数浮点类型有float32 和 浮点类型有float64 两种，默认是float64 2.3 复数默认类型是complex128（64位实数＋64位虚数）。如果需要小一些的，也有complex64（32位实数＋32位虚数）。复数的形式为RE＋IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位 var c complex64 = 5 + 5i 2.4 布尔类型布尔值的类型为bool，值是true或false，默认为false 2.5 字符串字符串都是采用UTF-8字符集编码。字符串是用一对双引号（””）或反引号（）括起来定义,字符串不可变，可以用 + 操作符 连接两个字符串 // 单行字符串 s := &quot;hello word&quot; // 多行字符串 s := `这是一个段落， 此处的换行会原样输出。 ` 2.6 错误类型Go语言内置有一个error类型，专门用来处理错误信息，Go语言的package里面还专门有一个包errors来处理错误 err := errors.New(&quot;error:我自己定义的错误&quot;) if err != nil { fmt.Print(err) } 2.7 常量程序编译阶段就确定下来的值，而程序在运行时则无法改变该值。在Go语言程序中，常量可定义为数值、布尔值或字符串等类型。 语法: const 常量名 [常量类型] = 常量值 const PI float32 = 3.1415 const a = 100 const Prex = &quot;Go_&quot; iota 枚举 Go语言里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，每调用一次加1。，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。 const( x = iota // x == 0 y = iota // y == 1 z = iota // z == 2 w // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说 w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot; ) const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0 每遇到一个const关键字，iota就会重置 3.复合类型3.1 数组语法: var 数组变量名 [数组长度]T 说明： 1.数组变量名：数组声明及使用时的变量名。 2.元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整型数值。也就是说，元素数量不能含有到运行时才能确认大小的数值。 3. T可以是任意基本类型，包括T为数组本身。但类型为数组本身时，可以实现多维数组 示例： var arr [3]int //默认初始化0 var q [3]int = [3]int{1,2,3} q := [...]int{1,2,3} q := [...]int{90:-1}//key和value的赋值方式，下表90的值为-1，数组长度为91 如果在 数组的长度 位置出现的是“…”省略号，则表示数组的长度是根据初始化值的 个数来计算 3.2 切片创建slice主要两种：1.基于数组创建。2.直接创建 1.基础数组创建 arrVar := [4]int{1, 2, 3，4} sliceVar := arrVar[1:3] 数组arrVar和sliceVar里面的地址其实是一样的，也就是说如果你改变sliceVar里面的变量，那么arrVar里面的变量也会随之改变。 2.直接创建myslice1 := make([]int,5)//创建一个元素个数5的slice,cap也是5 myslice2 := make([]int,5,10)//创建一个元素个数5的slice，cap是10 myslice3 := []int{1,2,3,4}//创建一个元素个数为4的slice，cap是4 var slice []int //创建一个空的slice，cap和len都是0 可以使用内置的make()函数来创建。事实上还是会创建一个匿名的数组，只是不需要我们来定义。 3.3 map可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var myMap map[keyType]valueType //示例1 ages := map[string] int { &quot;tom&quot;: 21, &quot;anny&quot;: 18, } /* 使用 make 函数 */ myMap := make(map[keyType]valueType) //示例1相当于 ages := make(map[string]int) ages[&quot;tom&quot;] = 21 ages[&quot;anny&quot;] = 18 myMap是声明的变量名，keyType是对应的Key的类型，valueType是value的类型。 3.3 结构体 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。 /* 声明结构体 */ type 结构体名称 struct { 属性1 类型 属性2 类型 ... } /* 使用示例 */ type User struct { name string age int } user := new(User) user.name = &quot;tom&quot; user.age = 20 字段直接没有逗号, 结构体的初始化可以使用new关键词和var关键词，不同的是如果使用new，则返回类型是一个指针，使用var，则是结构体自身。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-使用中遇到的问题整理]]></title>
    <url>%2F2018%2F02%2F03%2Fquestion-for-docker%2F</url>
    <content type="text"><![CDATA[问题1&gt;E: Unable to fetch some archives, maybe run apt-get update or try with –fix-missing?具体报错： E: Fetched 1837 kB in 21s (84.9 kB/s) Failed to fetch http://security.debian.org/pool/updates/main/p/php5/php5-common_5.6.33+dfsg-0+deb8u1_amd64.deb 404 Not Found E: Failed to fetch http://security.debian.org/pool/updates/main/p/php5/php5-cli_5.6.33+dfsg-0+deb8u1_amd64.deb 404 Not Found E: Failed to fetch http://security.debian.org/pool/updates/main/p/php5/php-pear_5.6.33+dfsg-0+deb8u1_all.deb 404 Not Found E: Failed to fetch http://security.debian.org/pool/updates/main/p/php5/php5-readline_5.6.33+dfsg-0+deb8u1_amd64.deb 404 Not Found E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing? ERROR: Service &#39;php-fpm&#39; failed to build: The command &#39;/bin/sh -c if [ ${INSTALL_SOAP} = true ]; then rm /etc/apt/preferences.d/no-debian-php &amp;&amp; apt-get -y install libxml2-dev php-soap &amp;&amp; docker-php-ext-install soap ;fi&#39; returned a non-zero code: 100 在相应的扩展中添加「 apt-get update 」如下： 解决方案: ARG INSTALL_SOAP=false RUN if [ ${INSTALL_SOAP} = true ]; then \ rm /etc/apt/preferences.d/no-debian-php \ &amp;&amp; apt-get update -y \ &amp;&amp; apt-get -y install libxml2-dev php-soap \ &amp;&amp; docker-php-ext-install soap \ ;fi 问题2&gt;ERROR: Service ‘redis’ failed to build: OCI runtime create failed: container_linux.go:344: starting container process caused “process_linux.go:293: copying bootstrap data to pipe caused \”write init-p: broken pipe\””: unknown解决方案: 通过容器降级sudo yum downgrade -y containerd.io-1.2.2-3.el7 问题3&gt; Unable to find expected entry ‘main/binary-amd64/Packages’Unable to locate packageapt 需要换成国内源 Step 94/98 : RUN apt-get update &amp;&amp; apt-get install -y software-properties-common &amp;&amp; add-apt-repository -y ppa:alex-p/tesseract-ocr ---&gt; Running in 252ccd15262a Get:1 http://security.debian.org jessie/updates InRelease [44.9 kB] Ign http://deb.debian.org jessie InRelease Get:2 http://deb.debian.org jessie-updates InRelease [7340 B] Get:3 http://deb.debian.org jessie Release.gpg [2420 B] Get:4 http://deb.debian.org jessie Release [148 kB] Get:5 http://security.debian.org jessie/updates/main amd64 Packages [832 kB] Get:6 http://deb.debian.org jessie/main amd64 Packages [9098 kB] Get:7 http://security.debian.org jessie/updates/main amd64 Packages [832 kB] Fetched 10.1 MB in 10min 9s (16.6 kB/s) W: Failed to fetch http://deb.debian.org/debian/dists/jessie-updates/InRelease Unable to find expected entry &#39;main/binary-amd64/Packages&#39; in Release file (Wrong sources.list entry or malformed file) E: Some index files failed to download. They have been ignored, or old ones used instead. ERROR: Service &#39;php-fpm&#39; failed to build: The command &#39;/bin/sh -c apt-get update &amp;&amp; apt-get install -y software-properties-common &amp;&amp; add-apt-repository -y ppa:alex-p/tesseract-ocr&#39; returned a non-zero code: 100 解决方案:在对应的命令行前加上： RUN printf &quot; #deb包\n deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\n deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\n deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\n deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n ##测试版源\n deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse\n # 源码\n deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\n deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\n deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\n deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n ##测试版源\n deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse\n&quot; &gt; /etc/apt/sources.list 问题4&gt; docker: Error response from daemon: Cannot link toto /laradock_mysql_1, as it does not belong to the default network 查看网络NETWORK ID NAME DRIVER SCOPE c8dfb8a44422 bridge bridge local 0fe587efe71f chaincode-docker-devmode_default bridge local 3d3c9e4de651 e2e_default bridge local dce17f3c06ca ethereum-docker_default bridge local 0eca3f311ce7 host host local 57912953f3e5 laradock_backend bridge local 35be8b9a0f70 laradock_default bridge local d3e733ccb976 laradock_frontend bridge local d67e463037d2 none null local 原因分析:造成问题的原因是 Docker-Compose命名约定造成。 使用docker-compose时，您的网络名称是根据docker-compose“项目名称”决定的，该项目名称基于其所在目录的名称。您可以使用-project-name标志覆盖项目名称或 COMPOSE_PROJECT_NAME环境变量。 我的docker-compose.yml文件位于一个名为dock的目录中，这就是为什么docker-compose在创建正在运行的容器实例时选择了dock_default！ 解决方案:：run 命令后增加–net参数，根据docker-compose 网络 问题5 &gt; Centos7 Failed to get D-Bus connection: Operation not permitted原因分析: 大约在0.6版，privileged被引入docker。使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限 解决方案: # docker run -d --name centos7 --privileged=true centos:7 /usr/sbin/init]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-排序算法汇总]]></title>
    <url>%2F2018%2F01%2F12%2Fphp-sort%2F</url>
    <content type="text"><![CDATA[1.1 插入排序基本思想：每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序；直到待排序数据元素全部插入完为止. &lt;?php /* 示例： [初始关键字] [49] 38 65 97 76 13 27 49 J=2(38) [38 49] 65 97 76 13 27 49 J=3(65) [38 49 65] 97 76 13 27 49 J=4(97) [38 49 65 97] 76 13 27 49 J=5(76) [38 49 65 76 97] 13 27 49 J=6(13) [13 38 49 65 76 97] 27 49 J=7(27) [13 27 38 49 65 76 97] 49 J=8(49) [13 27 38 49 49 65 76 97] */ function insert_sort($arr) { $count = count($arr); //i=1 是从第二个开始与第一个比较 for ($i = 1; $i &lt; $count; $i++) { $tmp = $array[$i]; $j = $i - 1; while ($array[$j] &gt; $tmp) { //前面的值大于后面的值时，互调位置, //直到满足:$array[$j] &gt; $tmp $array[$j + 1] = $array[$j]; $array[$j] = $tmp; $j--; } } return $arr; } 1.2 选择排序基本思想：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 &lt;?php /* 初始关键字] [49 38 65 97 76 13 27 49] 第一趟排序后 13 ［38 65 97 76 49 27 49] 第二趟排序后 13 27 ［65 97 76 49 38 49] 第三趟排序后 13 27 38 [97 76 49 65 49] 第四趟排序后 13 27 38 49 [49 97 65 76] 第五趟排序后 13 27 38 49 49 [97 97 76] 第六趟排序后 13 27 38 49 49 76 [76 97] 第七趟排序后 13 27 38 49 49 76 76 [ 97] 最后排序结果 13 27 38 49 49 76 76 97 */ function select_sort($arr) { /* * 基本思想：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后， 直到全部待排序的数据元素排完 * */ $count = count($arr); for ($i = 0; $i &lt; $count; $i++) { $k = $i; for ($j = $i + 1; $j &lt; $count; $j++) { if ($arr[$k] &gt; $arr[$j]) { //每次找出最小的值，并把最小值的索引赋值给$k,然后索引 $k 与 $i 值比较， $k = $j; } } //当最小值索引 $k与$i不同时， 索引$k与$i值互换位置, if ($k != $i) { $tmp = $arr[$i]; $arr[$i] = $arr[$k]; $arr[$k] = $tmp; } } return $arr; } 1.3 冒泡排序基本思想：两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。 排序过程：设想被排序的数组R［1..N］垂直竖立，将每个数据元素看作有重量的气泡，根据轻气泡不能在重气泡之下的原则(正序)， 从下往上扫描数组R，凡扫描到违反本原则的轻气泡，就使其向上”漂浮”，如此反复进行，直至最后任何两个气泡都是轻者在上，重者在下为止。 &lt;?php /* 示例： 49 13 13 13 13 13 13 13 38 49 27 27 27 27 27 27 65 38 49 38 38 38 38 38 97 65 38 49 49 49 49 49 76 97 65 49 49 49 49 49 13 76 97 65 65 65 65 65 27 27 76 97 76 76 76 76 49 49 49 76 97 97 97 97 */ function bubble_sort($array){ $count = count($array); if ($count &lt;= 0) return false; for($i=0; $i&lt;$count; $i++){ for($j=$count-1; $j&gt;$i; $j--){ if ($array[$j]&lt;$array[$j-1]){ $tmp = $array[$j]; $array[$j] = $array[$j-1]; $array[$j-1] = $tmp; } } } return $array; } 1.4 快速排序基本思想：在当前无序区R[1..H]中任取一个数据元素作为比较的”基准”(不妨记为X)， 用此基准将当前无序区划分为左右两个较小的无序区：R[1..I-1]和R[I 1..H]，且左边的无序子区中数据元素均小于等于基准元素， 右边的无序子区中数据元素均大于等于基准元素，而基准X则位于最终排序的位置上，即R[1..I-1]≤X.Key≤RI 1..H， 当 R[1..I-1]和R[I 1..H]均非空时，分别对它们进行上述的划分过程，直至所有无序子区中的数据元素均已排序为止。 &lt;?php /* 初始关键字 [49 38 65 97 76 13 27 49］ 第一次交换后 ［27 38 65 97 76 13 49 49］ 第二次交换后 ［27 38 49 97 76 13 65 49］ J向左扫描，位置不变，第三次交换后 ［27 38 13 97 76 49 65 49］ I向右扫描，位置不变，第四次交换后 ［27 38 13 49 76 97 65 49］ J向左扫描 ［27 38 13 49 76 97 65 49］ （一次划分过程） 初始关键字 ［49 38 65 97 76 13 27 49］ 一趟排序之后 ［27 38 13］ 49 ［76 97 65 49］ 二趟排序之后 ［13］ 27 ［38］ 49 ［49 65］76 ［97］ 三趟排序之后 13 27 38 49 49 ［65］76 97 最后的排序结果 13 27 38 49 49 65 76 97 */ function quick_sort(&amp;$array) { //在当前无序区中任取一个数据元素作为比较的”基准”， 用此基准将当前无序区划分为左右两个较小的无序区 if (count($array) &gt; 1) { $standard = $array[0]; //左边的无序子区中数据元素均小于等于基准元素， 右边的无序子区中数据元素均大于等于基准元素 $left = []; $right = []; $_size = count($array); for ($i = 1; $i &lt; $_size; $i++) { if ($array[$i] &lt;= $standard) { $left[] = $array[$i]; } elseif ($array[$i] &gt; $standard) { $right[] = $array[$i]; } } $left = $this-&gt;quick_sort($left); $right = $this-&gt;quick_sort($right); return array_merge($left, array($standard), $right); } return $array; } 1.5 希尔排序基本思想：希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。 &lt;?php function shell_sort(&amp;$arr){ if(!is_array($arr))return;$n=count($arr); for($gap=floor($n/2);$gap&gt;0;$gap=floor($gap/=2)){ for($i=$gap;$i&lt;$n;++$i){ for($j=$i-$gap;$j&gt;=0&amp;&amp;$arr[$j+$gap]&lt;$arr[$j];$j-=$gap){ $temp=$arr[$j]; $arr[$j]=$arr[$j+$gap]; $arr[$j+$gap]=$temp; } } } } .]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[幂等性]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%B9%82%E7%AD%89%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.概念幂等性是数学概念，即 f(x)=f(f(x))。在计算机领域，则是意为 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。在调用接口时，总有一些特殊情况会导致接口进行重复的调用，如果不对这些情况做出处理，就可能导致脏数据，甚至是业务流程上的问题。 2.不满足幂等性的影响试想这样的一种场景：在电商平台上支付后，因为网络原因导致系统提示你支付失败，于是你又重新付款了一次，等完成后检查网银发现被系统扣了两次款，这是一种什么样的体验？ 造成上述问题的原因可能有很多: 比如第一次付款时实际支付成功，但是信息返回时网络中断导致系统误判； 比如第一次付款的确失败了，但第二次付款时发生意外，导致支付请求被重复发送等等。 在一次支付的过程中，每个环节都有可能会发生问题，我们要如何规避这类问题引发的分险？幂等性是解决这类问题的方案之一。 3.从哪几个方面保证幂等性幂等性的保证需要从两个方面下手: 1. 空间维度空间维度定义了接口幂等的范围；比如我是订单数据，范围就是不同的用户 id 和订单 id(相同订单 id 不能重复下单)，或者是商品(相同商品不能重复下单) 2. 时间维度时间维度则是定义了接口幂性的有效期。比如，订单需要保证永久性幂等，永远不能拥有相同的订单，部分业务只需要保证一段时间的幂等性。 4.具体保证幂等性方案如果想要保证幂等性，首先要知道什么场景下才会出现幂等性问题。常见场景如下: 接口的幂等性问题通常出现在修改操作或者增添操作上，而针对查询与删除操作，通常不会拥有此种问题 业务上要求一致性较高的场景。(比如支付、下订单、抢票等..) 4.1 select + insert解决永久性幂等问题的一种解决方案。就是在执行操作前，判断之前是否已经操作过了，比如下单之前检查是否具有相同的订单 ID 已经存在，这样就可以避免重复提交的问题。永久性幂等问题通常与业务逻辑具有强关联，所以校验通常放置在参数校验上。 @注意: 针对并发问题带来的脏数据的问题无法解决，需要通过下面几种方式来实现。 4.2 唯一索引这是最容易想到的方式。页面的数据通常只能被提交一次，多次提交可能会产生脏数据。比如，同一名称的商品只能被创建一次，为了防止创建多次，可以给商品名称添加唯一索引。当在添加一个已有名称的商品时，数据库插入操作就会因为唯一索引而引发异常，避免了脏数据的产生。类似的案例还有博客点赞，订单创建等场景。 唯一索引不仅可以解决并发下的脏数据问题，也可以解决永久性幂等的问题。 缺点: 无法适用分布式存储系统，需要维护数据库的唯一索引，多的情况下不容易管理 4.3 分布式锁如果是分布式系统，全局的唯一索引就很难构建，此时可以使用分布式锁的方式解决此类问题。我们可以在执行第操作时先获取分布式锁，做完操作后，再将分布式锁释放。这样可以解决高并发性下的幂等性问题。 @注意: 需要配合 select+insert 使用，如果不配合，无法解决表单重复提交的问题。 4.4 token 机制token 机制是一种比较常用的机制，核心原理在于给每个操作执行前，需要去服务中获取一个 token，执行操作时需要携带 token 进行操作。如果发现 token 存在，则使用 token，并将其置为已使用，并执行操作，执行完毕后并且会将 token 对应的执行结果存储起来。否则将会检查是否存在执行结果，直接取出。 比如下单操作需要一次进行添加订单、更改库存、更改优惠券三个操作。每个操作执行前都去使用 token 验证该操作是否已经执行，从而防止重复执行的问题。并且，缓存的结果也可以用于事务控制（如果下单失败，增加记录的库存和优惠券）。 缺点:使用 token 机制，那么就会意味着在需要保证幂等性的接口在被调用前，必须先调用接口获取 token 4.5 MVCC 机制MVCC(Multi-Version Concurrency Control) 多版本并发控制。在数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法进行更新，更新成功后版本号将会发生变化。 @注意: 每一个version只有一次执行成功的机会，一旦失败必须重新获取。 4.6 状态机幂等所谓状态机，就是任务或者业务在执行的过程中，拥有的状态以及状态的变更图。在执行某个操作前，需要先对当前状态进行验证，如果状态不是该有的状态，则拒绝操作。]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储单位]]></title>
    <url>%2F2017%2F11%2F20%2F%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[存储单位1B(Byte 字节)=8bit， 1KB (Kilobyte 千字节)=1024B， 1MB (Megabyte 兆字节 简称“兆”)=1024KB， 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB， 1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)， 1PB（Petabyte 千万亿字节 拍字节）=1024TB， 1EB（Exabyte 百亿亿字节 艾字节）=1024PB， 1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB, 1YB (Yottabyte 一亿亿亿字节 尧字节)= 1024 ZB, 1BB (Brontobyte 一千亿亿亿字节)= 1024 YB. 注：“兆”为百万级数量单位。 附：进制单位全称及译音 yotta, [尧]它, Y. 10^21, zetta, [泽]它, Z. 10^18, exa, [艾]可萨, E. 10^15, peta, [拍]它, P. 10^12, tera, [太]拉, T. 10^9, giga, [级]咖, G. 10^6, mega, [兆]，M. 10^3]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-字符串函数]]></title>
    <url>%2F2017%2F09%2F22%2Fphp-str-function%2F</url>
    <content type="text"><![CDATA[1.bin2hex - 函数把包含数据的二进制字符串转换为十六进制值&lt;?php $data=&#39;php is best&#39;; $hex = bin2hex($data); echo $hex ; // 输出: 7068702069732062657374 2.hex2bin — 转换十六进制字符串为二进制字符串&lt;?php $data=&#39;7068702069732062657374&#39;; $bin = hex2bin($data); echo $bin ; // 输出: php is best 3.implode — 将一个一维数组的值转化为字符串&lt;?php $data=[&#39;PHP&#39;,&#39;IS&#39;,&#39;BEST&#39;]; $d= implode(&#39;,&#39;,$data); var_dump($d); // 输出: string(11) &quot;PHP,IS,BEST&quot; 4.explode — 使用一个字符串分割另一个字符串&lt;?php $data=&#39;PHP,IS,BEST&#39;; $d= explode(&#39;,&#39;,$data); var_dump($d); /** 输出: array(3) { [0]=&gt; string(3) &quot;PHP&quot; [1]=&gt; string(2) &quot;IS&quot; [2]=&gt; string(4) &quot;BEST&quot; } */ 5.lcfirst — 将字符串的首字母转换为小写&lt;?php $data=&#39;PHP,IS,BEST&#39;; $d= lcfirst($data); var_dump($d); // 输出:string(11) &quot;pHP,IS,BEST&quot; 6.ucfirst — 将字符串的首字母转换为大写&lt;?php $data=&#39;php,is,best&#39;; $d= ucfirst($data); var_dump($d); //输出: string(11) &quot;Php,is,best&quot; 7.ucwords — 将字符串中每个单词的首字母转换为大写&lt;?php $data=&#39;php is best&#39;; $d= ucwords($data); var_dump($d); // 输出: string(11) &quot;Php Is Best&quot; 8.strtoupper — 将字符串转化为大写&lt;?php $data=&#39;php,is,best&#39;; $d= strtoupper($data); var_dump($d); // 输出: string(11) &quot;PHP,IS,BEST&quot; 9.strtolower — 将字符串转化为小写&lt;?php $data=&#39;PHP,IS,BEST&#39;; $d= strtolower($data); var_dump($d); // 输出: string(11) &quot;php,is,best&quot; 10.strlen — 获取字符串长度&lt;?php $data=&#39;php is best&#39;; $d= strlen($data); var_dump($d); // 输出:int(11) 11.strpos — 查找字符串首次出现的位置&lt;?php $data=&#39;php is best&#39;; $d= strpos($data,&#39;is&#39;); var_dump($d); // 输出:int(4) 12.strripos — 计算指定字符串在目标字符串中最后一次出现的位置(不区分大小写)&lt;?php $haystack = &#39;ababcd&#39;; $needle = &#39;aB&#39;; $pos= strripos($haystack, $needle); if ($pos === false) { echo &quot;未发现&quot;; } else { echo &quot;找到！&quot;; } // 输出:&quot;找到！&quot; 13.strrpos - 计算指定字符串在目标字符串中最后一次出现的位置&lt;?php $haystack = &#39;ababcd&#39;; $needle = &#39;aB&#39;; $pos = strripos($haystack, $needle); if ($pos === false) { echo &quot;未发现&quot;; } else { echo &quot;找到！&quot;; } // 输出:&quot;未发现&quot; 14.strstr - 查找字符串的首次出现语法: strstr ( string $haystack , mixed $needle [, bool $before_needle = FALSE ] ) : string 结果: 返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串。 注意: 函数区分大小写。如果想要不区分大小写，请使用 stristr()。 如果你仅仅想确定 needle 是否存在于 haystack 中，请使用速度更快、耗费内存更少的 strpos() 函数。 示例: &lt;?php $email = &#39;name@example.com&#39;; $domain = strstr($email, &#39;@&#39;); echo $domain; // 打印 @example.com $user = strstr($email, &#39;@&#39;, true); // 从 PHP 5.3.0 起 echo $user; // 打印 name 15.str_replace - 字符串替换语法: str_replace ( mixed $search , mixed $replace , mixed $subject [, int &amp;$count ] ) : mixed 结果: 将subject 中全部的 search 都被 replace 替换之后的结果。 示例: &lt;?php // 单字符串替换 $str=&#39;php is best&#39;; $a = str_replace(&#39;php&#39;, &#39;Go&#39;, $str); echo $a.PHP_EOL; // 输出: Go is best //批量替换 $phrase = &quot;You should eat fruits, vegetables, and fiber every day.&quot;; $healthy = array(&quot;fruits&quot;, &quot;vegetables&quot;, &quot;fiber&quot;); $yummy = array(&quot;pizza&quot;, &quot;beer&quot;, &quot;ice cream&quot;); $newphrase = str_replace($healthy, $yummy, $phrase); echo $newphrase; // 输出: You should eat pizza, beer, and ice cream every day. 16.str_repeat - 重复一个字符串语法: str_repeat ( string $input , int $multiplier ) : string 结果: 返回 input 重复 multiplier 次后的结果。 示例: &lt;?php echo str_repeat(&quot;*&quot;, 10); // 输出:********** 17.str_shuffle - 随机打乱一个字符串语法: str_shuffle ( string $str ) : string 结果: 返回打乱后的字符串。 示例: &lt;?php echo str_shuffle(&quot;123456&quot;); // 输出 36251 18.str_repeat - 重复一个字符串语法: str_repeat ( string $input , int $multiplier ) : string 结果: 返回 input 重复 multiplier 次后的结果。 示例: &lt;?php echo str_repeat(&quot;*&quot;, 10); // 输出:********** 20.ltrim — 删除字符串开头的空白字符（或其他字符）语法: ltrim ( string $str [, string $character_mask ] ) : string 示例: &lt;?php $str = &#39; Abc&#39;; // 删除开头空格 echo ltrim($str).PHP_EOL; $str2 = &#39;@Abc&#39;; // 删除开头指定字符串 echo ltrim($str2,&#39;@&#39;).PHP_EOL; /* 输出: Abc Abc / 21.rtrim — 删除字符串末端的空白字符（或者其他字符）语法: rtrim ( string $str [, string $character_mask ] ) : string 示例: &lt;?php $str = &#39;Abc &#39;; // 删除末尾空格 echo ltrim($str).PHP_EOL; $str2 = &#39;AbcE&#39;; // 删除末尾指定字符串(E) echo ltrim($str2,&#39;E&#39;).PHP_EOL; /* 输出: Abc Abc / 22.trim — 去除字符串首尾处的空白字符（或者其他字符）语法: trim ( string $str [, string $character_mask = &quot; \t\n\r\0\x0B&quot; ] ) : string 示例: &lt;?php $str = &#39; Abc &#39;; // 删除末尾空格 echo trim($str).PHP_EOL; $str2 = &#39;@ABC@&#39;; // 删除末尾指定字符串(E) echo trim($str2,&#39;@&#39;).PHP_EOL; /* 输出: Abc ABC / 23.substr_count — 计算字串出现的次数语法: substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] ) : int 结果: substr_count() 返回子字符串needle 在字符串 haystack 中出现的次数。注意 needle 区分大小写。 示例: &lt;?php $text = &#39;This is a test&#39;; echo substr_count($text, &#39;is&#39;).PHP_EOL; // 输出: 2 24.substr — 返回字符串的子串语法: substr ( string $string , int $start [, int $length ] ) : string 结果: 返回字符串 string 由 start 和 length 参数指定的子字符串。 注意start值: 如果start是非负数，返回的字符串将从string的start位置开始，从0开始计算 如果start是负数，返回的字符串将从string结尾处向前数第start个字符开始。 如果string的长度小于start将返回 FALSE。 示例: &lt;?php // $start 使用负数 $rest = substr(&quot;abcdef&quot;, -1); // 返回 &quot;f&quot; $rest = substr(&quot;abcdef&quot;, -2); // 返回 &quot;ef&quot; $rest = substr(&quot;abcdef&quot;, -3, 1); // 返回 &quot;d&quot; // $length 使用负数 $rest = substr(&quot;abcdef&quot;, 0, -1); // 返回 &quot;abcde&quot; $rest = substr(&quot;abcdef&quot;, 2, -1); // 返回 &quot;cde&quot; $rest = substr(&quot;abcdef&quot;, 4, -4); // 返回 &quot;&quot; $rest = substr(&quot;abcdef&quot;, -3, -1); // 返回 &quot;de&quot; 25.str_pad — 使用另一个字符串填充字符串为指定长度语法: str_pad ( string $input , int $pad_length [, string $pad_string = &quot; &quot; [, int $pad_type = STR_PAD_RIGHT ]] ) : string 结果: 该函数返回 input 被从左端、右端或者同时两端被填充到制定长度后的结果。如果可选的 pad_string 参数没有被指定，input 将被空格字符填充，否则它将被 pad_string 填充到指定长度。 示例: &lt;?php $input = &quot;Alien&quot;; echo str_pad($input, 10); // 输出 &quot;Alien &quot; echo str_pad($input, 10, &quot;-=&quot;, STR_PAD_LEFT); // 输出 &quot;-=-=-Alien&quot; echo str_pad($input, 10, &quot;_&quot;, STR_PAD_BOTH); // 输出 &quot;__Alien___&quot; echo str_pad($input, 6, &quot;___&quot;); // 输出 &quot;Alien_&quot; echo str_pad($input, 3, &quot;*&quot;); // 输出 &quot;Alien&quot; 查看更多字符串函数]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-魔术函数]]></title>
    <url>%2F2017%2F09%2F21%2Fphp-magic-function%2F</url>
    <content type="text"><![CDATA[1.__construct()，类的构造函数说明:php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 作用:通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 2.__destruct()，类的析构函数说明：析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等 作用:一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。 注意：析构函数不能带有任何参数。 3.__call()，在对象中调用一个不可访问方法时调用说明:该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 作用: 为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 示例: &lt;?php class Test { function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 当调用不存在的方法时，则自动调用了对象中的__call()方法 */ function __call($funName, $arguments) { // 输出调用不存在的方法名 echo &quot;你所调用的方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法时的参数列表 print_r($arguments); // 结束换行 echo &quot;)不存在！&lt;br&gt;\n&quot;; } } $test = new Test(); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法 $test-&gt;run(&quot;dog&quot;); $test-&gt;fly(&quot;小鸟&quot;, &quot;乌鸦&quot;); // 调用存在的方法 $test-&gt;say(); //输出 /* 你所调用的方法：run(参数：Array ( [0] =&gt; dog ) )不存在！ 你所调用的方法：fly(参数：Array ( [0] =&gt;小鸟 [1] =&gt; 乌鸦 ) )不存在！ Hello, world! */ 4.__callStatic()，用静态方式中调用一个不可访问方法时调用说明：此方法与上面所说的 call() 功能除了 callStatic() 是为静态方法准备的之外，其它都是一样的。 示例: &lt;?php class Test { function static say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 当调用不存在的静态方法时，触发此函数 */ function __callStatic($funName, $arguments) { // 输出调用不存在的方法名 echo &quot;你所调用的静态函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法时的参数列表 print_r($arguments); // 结束换行 echo &quot;)不存在！&lt;br&gt;\n&quot;; } } // 不存在的静态方法，则自动调用了对象中的__callStatic()方法 Test::run(&quot;dog&quot;); Test::fly(&quot;小鸟&quot;, &quot;乌鸦&quot;); // 调用存在的静态方法 Test::say(); //输出 /* 你所调用的静态函数：run(参数：Array ( [0] =&gt; dog ) )不存在！ 你所调用的静态函数：eat(参数：Array ( [0] =&gt; 小鸟 [1] =&gt; 乌鸦 ) )不存在！ Hello, world! */ 5.__get(),获得一个类的成员变量时调用说明: 在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 作用: 在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 示例: &lt;?php class Person { // 设置私有属性，外界不可直接访问 private $name; private $age; /** * 构造方法用来实例化对象属性 * * @param $name * @param $age */ function __construct($name, $age) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 在直接获取私有属性值时自动调用一次，以属性名作为参数传入并处理 * * @param $propertyName * @return string|int */ public function __get($propertyName) { if ($propertyName == &quot;age&quot;) { if ($this-&gt;age &gt; 20) { return $this-&gt;age - 10; } else { return $this-&gt;$propertyName; } } else { return $this-&gt;$propertyName; } } } // 实例化对象 $p = new Person(&quot;张美丽&quot;, 28); // 直接访问私有属性name，自动触发__get()方法 echo &quot;姓名：&quot; . $p-&gt;name . &quot;&lt;br&gt;&quot;; // 直接访问私有属性age，自动触发__get()方法 echo &quot;年龄：&quot; . $p-&gt;age . &quot;&lt;br&gt;&quot;; /* 输出: 姓名：张美丽 年龄：18 */ 注意: 如果把属性定义成是static的，那么通过__get()访问也会报错。原因是static的成员，是属于类本身的，不因为实例化而改变。 6.__set()，设置一个类的成员变量时调用说明: 给一个私有属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值 示例: &lt;?php class Test { private $name; /** * 当直接给私有属性赋值时，触发此方法。 * * @param $property * @param $value */ public function __set($property,$value) { if ($property == &#39;name&#39;) { $this-&gt;name = $value; } } public function getName(){ return $this-&gt;name; } } $test = new Test(); // 为私有属性赋值 $test-&gt;name =&#39;张三&#39;; echo &#39;名称: &#39; . $test-&gt;getName(); /** 输出: 名称: 张三 */ 7.__isset()，当对不可访问属性调用isset()或empty()时调用说明:当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用 说明: &lt;?php /** * MagicFunction.php * * Programmer : Mr.Liu * Created: 2020/3/13 18:07 * * */ class Person { public $sex; private $name; private $age; public function __construct($name = &quot;&quot;, $age = 18, $sex = &#39;男&#39;) { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __isset($content) { echo &quot;当在类外部使用isset()或empty()函数,判断私有成员{$content}时，会自动调用&quot;.PHP_EOL; echo isset($this-&gt;$content); } } $person = new Person(&quot;小明&quot;, 25); // 初始赋值 echo isset($person-&gt;sex).PHP_EOL; echo isset($person-&gt;name).PHP_EOL; echo empty($person-&gt;age).PHP_EOL; /** 输出: 1 当在类外部使用isset()或empty()函数,判断私有成员name时，会自动调用 1 当在类外部使用isset()或empty()函数,判断私有成员age时，会自动调用 11 */ 8.其他魔术函数， __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 原文来自: PHP之十六个魔术方法详解]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-数组函数]]></title>
    <url>%2F2017%2F09%2F20%2Fphp-array-function%2F</url>
    <content type="text"><![CDATA[1.改变1.1 array_chunk 分割功能: 将一个数组分割成多个语法: array_chunk( array $array , int $size [, bool $preserve_keys = false ] ) : array 说明: 将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。代码: &lt;?php $input_array = array(&quot;a&quot;=&gt;&quot;apple&quot;,&quot;b&quot;=&gt;&quot;blue&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;); print_r(array_chunk($input_array, 2)); //设为 TRUE，可以保留数组中原来的键名 print_r(array_chunk($input_array, 2,True)); 输出: Array ( [0] =&gt; Array ( [0] =&gt; apple [1] =&gt; blue ) [1] =&gt; Array ( [0] =&gt; c [1] =&gt; d ) [2] =&gt; Array ( [0] =&gt; e ) ) Array ( [0] =&gt; Array ( [a] =&gt; apple [b] =&gt; blue ) [1] =&gt; Array ( [0] =&gt; c [1] =&gt; d ) [2] =&gt; Array ( [2] =&gt; e ) ) 1.2 array_merge 合并功能: 合并一个或多个数组说明: 如果后面有键名相同的会覆盖掉前面的内容，键名为数字的会添加到后面语法: array_merge ( array $array1 [, array $... ] ) : array 代码: &lt;?php $array1 = array(&quot;color&quot;=&gt;&quot;red&quot;,2,4); $array2 = array(&quot;a&quot;,&quot;b&quot;,&quot;color&quot;=&gt;&quot;green&quot;,&quot;shape&quot;=&gt;&quot;trapezoid&quot;,4); $result = array_merge($array1,$array2); print_r($result); 输出: Array ( [color] =&gt; green [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; a [3] =&gt; b [shape] =&gt; trapezoid [4] =&gt; 4 ) 1.3 array_unique 去重功能: 移除数组中重复的值说明: 接受 array 作为输入并返回没有重复值的新数组。注意键名保留不变。array_unique() 先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第一个出现的键名会被保留。语法: array_unique ( array $array [, int $sort_flags = SORT_STRING ] ) : array 代码1: &lt;?php $input = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;red&quot;, &quot;b&quot; =&gt; &quot;green&quot;, &quot;blue&quot;, &quot;red&quot;); $result = array_unique($input); print_r($result); ?&gt; 输出: Array ( [a] =&gt; green [0] =&gt; red [1] =&gt; blue ) 代码2: &lt;?php $input = array(4, &quot;4&quot;, &quot;3&quot;, 4, 3, &quot;3&quot;); $result = array_unique($input); var_dump($result); ?&gt; 输出: array(2) { [0] =&gt; int(4) [2] =&gt; string(1) &quot;3&quot; } 输出: Array ( [0] =&gt; Tank [1] =&gt; Morpheus [2] =&gt; Cypher [3] =&gt; Trinity [4] =&gt; Neo ) 1.4 array_combine 创建功能: 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值语法: array_combine ( array $keys , array $values ) : array 说明: 返回一个 array，用来自 keys 数组的值作为键名，来自 values 数组的值作为相应的值。 代码: &lt;?php $a = array(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;); $b = array(&quot;一&quot;,&quot;二&quot;,&quot;三&quot;); $c = array_combine($a,$b); print_r($c); 输出: ( [one] =&gt; 一 [two] =&gt; 二 [three] =&gt; 三 ) 1.5 array_fill 创建功能: 用给定的值填充数组语法: array_fill ( int $start_index , int $num , mixed $value ) : array 说明: 用value参数的值将一个数组填充num个条目，键名由start_index 参数指定的开始。 代码: &lt;?php $a = array_fill(5, 6, &#39;banana&#39;); $b = array_fill(-2, 4, &#39;pear&#39;); print_r($a); print_r($b); ?&gt; 输出: Array ( [5] =&gt; banana [6] =&gt; banana [7] =&gt; banana [8] =&gt; banana [9] =&gt; banana [10] =&gt; banana ) Array ( [-2] =&gt; pear [0] =&gt; pear [1] =&gt; pear [2] =&gt; pear ) 1.6 array_fill_keys 创建功能: 使用指定的键和值填充数组语法: array_fill_keys ( array $keys , mixed $value ) : array 说明: 使用value参数的值作为值，使用 keys 数组的值作为键来填充一个数组。 代码: &lt;?php $keys = array(&#39;foo&#39;, 5, 10, &#39;bar&#39;); $a = array_fill_keys($keys, &#39;banana&#39;); print_r($a); ?&gt; ?&gt; 输出: Array ( [foo] =&gt; banana [5] =&gt; banana [10] =&gt; banana [bar] =&gt; banana ) 1.7 array_flip 交换功能: 交换数组中的键和值语法: array_flip ( array $array ) : array 说明: 返回一个反转后的array，例如 array 中的键名变成了值，而 array 中的值成了键名。 注意: array中的值需要能够作为合法的键名(integer或者string）。如果类型不对，将出现一个警告，并且有问题的键／值对将不会出现在结果里。 如果同一个值出现多次，则最后一个键名将作为它的值，其它键会被丢弃。 代码: &lt;?php $input = array(&quot;oranges&quot;, &quot;apples&quot;, &quot;pears&quot;); $flipped = array_flip($input); print_r($flipped); $input2 = array(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 1, &quot;c&quot; =&gt; 2); $flipped2 = array_flip($input2); print_r($flipped2); ?&gt; 输出: Array ( [oranges] =&gt; 0 [apples] =&gt; 1 [pears] =&gt; 2 ) Array ( [1] =&gt; b [2] =&gt; c ) 1.8 array_pad 新增功能: 以指定长度将一个值填充进数组语法: array_pad(array $array , int $size , mixed $value ) : array 说明: 返回array的一个拷贝，并用value将其填补到 size 指定的长度。如果 size 为正，则填补到数组的右侧，如果为负则从左侧开始填补。如果 size 的绝对值小于或等于 array 数组的长度则没有任何填补。 代码: &lt;?php $input = array(12, 10, 9); $result = array_pad($input, 5, 0); // result is array(12, 10, 9, 0, 0) $result = array_pad($input, -7, -1); // result is array(-1, -1, -1, -1, 12, 10, 9) $result = array_pad($input, 2, &quot;noop&quot;); // $input 数组不变 ?&gt; 1.9 array_push 新增功能: 将一个或多个单元压入数组的末尾（入栈）语法: array_push(array &amp;$array, mixed $value1 [, mixed $... ]) : int 说明: 将array当成一个栈，并将传入的变量压入array的末尾。array的长度将根据入栈变量的数目增加。 注意: 如果用array_push()来给数组增加一个单元，还不如用$array[]= ，因为这样没有调用函数的额外负担。 代码: &lt;?php $stack = array(&quot;orange&quot;, &quot;banana&quot;); array_push($stack, &quot;apple&quot;, &quot;raspberry&quot;); print_r($stack); ?&gt; 输出: Array ( [0] =&gt; orange [1] =&gt; banana [2] =&gt; apple [3] =&gt; raspberry ) 1.10 array_pop 删除功能: 弹出数组最后一个单元（出栈）语法: array_pop ( array &amp;$array ) : mixed 说明: 弹出并返回array数组的最后一个单元，并将数组array的长度减一。 代码: &lt;?php $stack = array(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;raspberry&quot;); $fruit = array_pop($stack); print_r($stack); print_r($fruit); ?&gt; 输出: Array ( [0] =&gt; orange [1] =&gt; banana [2] =&gt; apple ) raspberry 1.11 shuffle 打乱功能: 打乱数组说明: 本函数打乱（随机排列单元的顺序）一个数组。 它使用的是伪随机数产生器，并不适合密码学的场合语法: shuffle ( array &amp;$array ) : bool 代码: &lt;?php $input = array(&quot;Neo&quot;, &quot;Morpheus&quot;, &quot;Trinity&quot;, &quot;Cypher&quot;, &quot;Tank&quot;); shuffle($input); print_r($input); ?&gt; 1.12 array_replace 替换功能: 使用传递的数组替换第一个数组的元素语法: array_replace ( array $array1 [, array $... ] ) : array 说明: 使用后面数组元素相同key的值替换array1数组的值。 如果一个键存在于第一个数组同时也存在于第二个数组，它的值将被第二个数组中的值替换。 如果一个键存在于第二个数组，但是不存在于第一个数组，则会在第一个数组中创建这个元素。 如果一个键仅存在于第一个数组，它将保持不变。 如果传递了多个替换数组，它们将被按顺序依次处理，后面的数组将覆盖之前的值 代码: &lt;?php $base = array(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;raspberry&quot;); $replacements = array(0 =&gt; &quot;pineapple&quot;, 4 =&gt; &quot;cherry&quot;); $replacements2 = array(0 =&gt; &quot;grape&quot;); $basket = array_replace($base, $replacements, $replacements2); print_r($basket); ?&gt; 输出: Array ( [0] =&gt; grape [1] =&gt; banana [2] =&gt; apple [3] =&gt; raspberry [4] =&gt; cherry ) 1.13 array_shift 删除功能: 将数组开头的单元移出数组语法: array_shift ( array &amp;$array ) : mixed 说明: 将 array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。 代码: &lt;?php $stack = array(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;raspberry&quot;); $fruit = array_shift($stack); print_r($stack); print_r($fruit); ?&gt; 输出: Array ( [0] =&gt; banana [1] =&gt; apple [2] =&gt; raspberry ) orange 1.14 array_unshift 新增功能: 在数组开头插入一个或多个单元语法: array_unshift ( array &amp;$array [, mixed $... ] ) : int 说明: 将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变。 代码: &lt;?php $queue = array(&quot;orange&quot;, &quot;banana&quot;); array_unshift($queue, &quot;apple&quot;, &quot;raspberry&quot;); print_r($queue); ?&gt; 输出: Array ( [0] =&gt; apple [1] =&gt; raspberry [2] =&gt; orange [3] =&gt; banana ) 1.15 array_splice 删除&amp;替换功能: 去掉数组中的某一部分并用其它值取代语法: array_splice(array &amp;$input,int $offset [,int$length=count($input) [,mixed$replacement=array()]]) :array 说明: 把input数组中由offset和length指定的单元去掉，如果提供了replacement参数，则用其中的单元取代。 如果offset为正，则从input数组中该值指定的偏移量开始移除。 如果offset为负，则从input末尾倒数该值指定的偏移量开始移除。 如果省略length，则移除数组中从offset到结尾的所有部分。 如果指定了length并且为正值，则移除这么多单元。 如果指定了length并且为负值，则移除从offset到数组末尾倒数length为止中间所有的单元。 如果设置了length为零，不会移除单元。 如果给出了replacement数组，则被移除的单元被此数组中的单元替代。 注意: input中的数字键名不被保留。代码: &lt;?php $input = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;); array_splice($input, 2); // $input is now array(&quot;red&quot;, &quot;green&quot;) $input = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;); array_splice($input, 1, -1); // $input is now array(&quot;red&quot;, &quot;yellow&quot;) $input = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;); array_splice($input, 1, count($input), &quot;orange&quot;); // $input is now array(&quot;red&quot;, &quot;orange&quot;) $input = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;); array_splice($input, -1, 1, array(&quot;black&quot;, &quot;maroon&quot;)); // $input is now array(&quot;red&quot;, &quot;green&quot;, // &quot;blue&quot;, &quot;black&quot;, &quot;maroon&quot;) $input = array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;); array_splice($input, 3, 0, &quot;purple&quot;); // $input is now array(&quot;red&quot;, &quot;green&quot;, // &quot;blue&quot;, &quot;purple&quot;, &quot;yellow&quot;); ?&gt; 2.访问2.1 array_column 指定列功能: 返回数组中指定的一列语法: array_column ( array $input , mixed $column_key [, mixed $index_key = null ] ) : array 说明: 返回input数组中键值为column_key的列，如果指定了可选参数index_key，那么input数组中的这一列的值将作为返回数组中对应值的键。 代码: 不传$index_key时 &lt;?php $records = array( array( &#39;id&#39; =&gt; 2135, &#39;first_name&#39; =&gt; &#39;John&#39;, &#39;last_name&#39; =&gt; &#39;Doe&#39;, ), array( &#39;id&#39; =&gt; 3245, &#39;first_name&#39; =&gt; &#39;Sally&#39;, &#39;last_name&#39; =&gt; &#39;Smith&#39;, ), array( &#39;id&#39; =&gt; 5342, &#39;first_name&#39; =&gt; &#39;Jane&#39;, &#39;last_name&#39; =&gt; &#39;Jones&#39;, ), array( &#39;id&#39; =&gt; 5623, &#39;first_name&#39; =&gt; &#39;Peter&#39;, &#39;last_name&#39; =&gt; &#39;Doe&#39;, ) ); $first_names = array_column($records, &#39;first_name&#39;); print_r($first_names); ?&gt; 输出: Array ( [0] =&gt; John [1] =&gt; Sally [2] =&gt; Jane [3] =&gt; Peter ) 传$index_key时 $last_names = array_column($records, &#39;last_name&#39;, &#39;id&#39;); print_r($last_names); 输出: Array ( [2135] =&gt; Doe [3245] =&gt; Smith [5342] =&gt; Jones [5623] =&gt; Doe ) 2.2 array_keys 所有key功能: 返回数组中部分的或所有的键名语法: array_keys ( array $array [, mixed $search_value = null [, bool $strict = false ]] ) : array 说明: 返回input数组中的数字或者字符串的键名。 如果指定了可选参数 search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。 代码: &lt;?php // 所有key $array = array(0 =&gt; 100, &quot;color&quot; =&gt; &quot;red&quot;); print_r(array_keys($array)); // 指定value的key $array = array(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;blue&quot;); print_r(array_keys($array, &quot;blue&quot;)); $array = array(&quot;color&quot; =&gt; array(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;), &quot;size&quot; =&gt; array(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)); print_r(array_keys($array)); ?&gt; 输出: Array ( [0] =&gt; 0 [1] =&gt; color ) Array ( [0] =&gt; 0 [1] =&gt; 3 [2] =&gt; 4 ) Array ( [0] =&gt; color [1] =&gt; size ) 2.3 array_key_first 首个key功能: 返回数组中的第一个key注意: 需要PHP版本:PHP7.3+语法: array_key_first ( array $array ) : mixed 代码: &lt;?php $array = [&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 3]; $firstKey = array_key_first($array); var_dump($firstKey); ?&gt; 输出: string(1) &quot;a&quot; 2.4 array_key_last 末尾key功能: 返回数组中的第一个key注意: 需要PHP版本:PHP7.3+语法: array_key_last ( array $array ) : mixed 代码: &lt;?php $array = [&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 3]; $firstKey = array_key_last($array); var_dump($firstKey); ?&gt; 输出: string(1) &quot;c&quot; 2.5 array_rand 随机取出功能: 从数组中随机取出一个或多个单元说明: 从数组中取出一个或多个随机的单元，并返回随机条目的一个或多个键。 它使用了伪随机数产生算法，所以不适合密码学场景语法: array_rand ( array $array [, int $num = 1 ] ) : mixed 代码: &lt;?php $input = array(&quot;Neo&quot;, &quot;Morpheus&quot;, &quot;Trinity&quot;, &quot;Cypher&quot;, &quot;Tank&quot;); $rand_keys = array_rand($input, 2); print_r($rand_keys); ?&gt; 输出: Array ( [0] =&gt; 0 [1] =&gt; 3 ) 2.6 array_reverse 反转功能: 返回单元顺序相反的数组语法: array_reverse ( array $array [, bool $preserve_keys = FALSE ] ) : array 说明: 接受数组 array 作为输入并返回一个单元为相反顺序的新数组。 如果$preserve_keys设置为TRUE会保留数字的键。 非数字的键则不受这个设置的影响，总是会被保留 代码: &lt;?php $input = array(&quot;php&quot;, 4.0, array(&quot;green&quot;, &quot;red&quot;)); $reversed = array_reverse($input); $preserved = array_reverse($input, true); print_r($reversed); print_r($preserved); ?&gt; 输出: Array ( [0] =&gt; Array ( [0] =&gt; green [1] =&gt; red ) [1] =&gt; 4 [2] =&gt; php ) Array ( [2] =&gt; Array ( [0] =&gt; green [1] =&gt; red ) [1] =&gt; 4 [0] =&gt; php ) 2.7 array_search 条件查找功能: 在数组中搜索给定的值，如果成功则返回首个相应的键名语法: array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) : mixed 说明: 如果$strict为TRUE，则array_search() 将在 haystack 中检查完全相同的元素(===) 如果找到了needle则返回它的键，否则返回 FALSE。 代码: &lt;?php $array = array(0 =&gt; &#39;blue&#39;, 1 =&gt; &#39;red&#39;, 2 =&gt; &#39;green&#39;, 3 =&gt; &#39;red&#39;, 4=&gt;5); $key1 = array_search(&#39;green&#39;, $array); $key2 = array_search(&#39;red&#39;, $array); $key3 = array_search(&#39;5&#39;, $array,true); var_dump($key1,$key2,$key3); ?&gt; 输出: int(2) int(1) bool(false) 2.8 array_slice 取出一段功能: 从数组中取出一段语法: array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] ) : array 说明: 注意array_slice()默认会重新排序并重置数组的数字索引。你可以通过将 preserve_keys 设为 TRUE 来改变此行为 如果给出了length并且为正，则序列中将具有这么多的单元。 如果给出了length并且为负，则序列将终止在距离数组末端这么远的地方。 如果省略，则序列将从offset开始一直到array的末端。 代码: &lt;?php $input = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;); $output = array_slice($input, 2); // returns &quot;c&quot;, &quot;d&quot;, and &quot;e&quot; $output = array_slice($input, -2, 1); // returns &quot;d&quot; $output = array_slice($input, 0, 3); // returns &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; // note the differences in the array keys print_r(array_slice($input, 2, -1)); print_r(array_slice($input, 2, -1, true)); ?&gt; 输出: Array ( [0] =&gt; c [1] =&gt; d ) Array ( [2] =&gt; c [3] =&gt; d ) 2.9 array_values 所有值功能: 返回数组中所有的值语法: array_values ( array $array ) : array 说明: 返回input数组中所有的值并给其建立数字索引 代码: &lt;?php $array = array(&quot;size&quot; =&gt; &quot;XL&quot;, &quot;color&quot; =&gt; &quot;gold&quot;); print_r(array_values($array)); ?&gt; 输出: Array ( [0] =&gt; XL [1] =&gt; gold ) 3.排序3.1 arsort 对值:逆向排序功能: 对数组进行逆向排序并保持索引关系语法: arsort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组进行排序，数组的索引保持和单元的关联。 代码: $fruits = array(&quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;); arsort($fruits); print_r($fruits); 输出: Array ( [a] =&gt; orange [d] =&gt; lemon [b] =&gt; banana [c] =&gt; apple ) 3.2 asort 对值:正向排序功能: 对数组进行排序并保持索引关系语法: asort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组进行排序，数组的索引保持和单元的关联。主要用于对那些单元顺序很重要的结合数组进行排序。 代码: $fruits = array(&quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;); asort($fruits); print_r($fruits); 输出: Array ( [c] =&gt; apple [b] =&gt; banana [d] =&gt; lemon [a] =&gt; orange ) 3.3 rsort 对值:逆向排序功能: 对数组进行逆向排序，不保留索引关系语法: rsort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组进行逆向排序（最高到最低）。 代码: $fruits = array(&quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;); rsort($fruits); print_r($fruits); 输出: Array ( [0] =&gt; orange [1] =&gt; lemon [2] =&gt; banana [3] =&gt; apple ) 3.4 sort 对值:正向排序功能: 对数组进行正向排序，不保留索引关系语法: sort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组进行逆向排序（最高到最低）。 代码: $fruits = array(&quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;); sort($fruits); print_r($fruits); 输出: Array ( [0] =&gt; apple [1] =&gt; banana [2] =&gt; lemon [3] =&gt; orange ) 3.5 ksort 对key:正向排序功能: 对数组按照键名正向排序语法: ksort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组按照键名正向排序，保留键名到数据的关联。主要用于结合数组。 代码: $fruits = array(&quot;d&quot;=&gt;&quot;lemon&quot;, &quot;a&quot;=&gt;&quot;orange&quot;, &quot;b&quot;=&gt;&quot;banana&quot;, &quot;c&quot;=&gt;&quot;apple&quot;); ksort($fruits); print_r($fruits); 输出: Array ( [a] =&gt; orange [b] =&gt; banana [c] =&gt; apple [d] =&gt; lemon ) 3.6 krsort 对key:逆向排序功能: 对数组按照键名逆向排序语法: krsort ( array &amp;$array [, int $sort_flags = SORT_REGULAR ] ) : bool 说明: 对数组按照键名逆向排序，保留键名到数据的关联。主要用于结合数组。 代码: $fruits = array(&quot;d&quot;=&gt;&quot;lemon&quot;, &quot;a&quot;=&gt;&quot;orange&quot;, &quot;b&quot;=&gt;&quot;banana&quot;, &quot;c&quot;=&gt;&quot;apple&quot;); krsort($fruits); print_r($fruits); 输出: Array ( [d] =&gt; lemon [c] =&gt; apple [b] =&gt; banana [a] =&gt; orange ) 3.7 array_multisort 多维数组排序功能: 返回数组中所有的值语法: array_multisort ( array &amp;$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $... ]]] ) : bool 说明: 可以用来一次对多个数组进行排序，或者根据某一维或多维对多维数组进行排序。 关联（string）键名保持不变，但数字键名会被重新索引 array1_sort_order:参数要排列的顺序,SORT_ASC升序,SORT_DESC倒序,默认 SORT_ASC array1_sort_flags: SORT_REGULAR - 将项目按照通常方法比较（不修改类型） SORT_NUMERIC - 按照数字大小比较 SORT_STRING - 按照字符串比较 1. 一维数组排序代码: $a=array(&quot;Dog&quot;,&quot;Cat&quot;,&quot;Horse&quot;,&quot;Bear&quot;,&quot;Zebra&quot;); array_multisort($a); print_r($a); 输出: Array ( [0] =&gt; Bear [1] =&gt; Cat [2] =&gt; Dog [3] =&gt; Horse [4] =&gt; Zebra ) 2. 多个一维数组排序代码: $ar1 = array(10, 100, 100, 0); $ar2 = array(1, 3, 2, 4); array_multisort($ar1, $ar2); var_dump($ar1); var_dump($ar2); 说明: 可以把$ar1和$ar2的数据可以看成一个表 如下： $ar1 $ar2 10 1 100 3 100 2 0 4 $ar1和$ar2分别为列名，然后像sql语句一样 排序即可 select * from table order by $ar1 asc ,$ar2 asc 输出: array(4) { [0]=&gt; int(0) [1]=&gt; int(10) [2]=&gt; int(100) [3]=&gt; int(100) } array(4) { [0]=&gt; int(4) [1]=&gt; int(1) [2]=&gt; int(2) [3]=&gt; int(3) } 3.多维数组排序原数据: &lt;?php $data[] = array(&#39;volume&#39; =&gt; 67, &#39;edition&#39; =&gt; 2); $data[] = array(&#39;volume&#39; =&gt; 86, &#39;edition&#39; =&gt; 1); $data[] = array(&#39;volume&#39; =&gt; 85, &#39;edition&#39; =&gt; 6); $data[] = array(&#39;volume&#39; =&gt; 98, &#39;edition&#39; =&gt; 2); $data[] = array(&#39;volume&#39; =&gt; 86, &#39;edition&#39; =&gt; 6); $data[] = array(&#39;volume&#39; =&gt; 67, &#39;edition&#39; =&gt; 7); 需求:将把 volume 降序排列，把 edition 升序排列。 代码: &lt;?php // 取得列的列表 foreach ($data as $key =&gt; $row) { $volume[$key] = $row[&#39;volume&#39;]; $edition[$key] = $row[&#39;edition&#39;]; } // 将数据根据 volume 降序排列，根据 edition 升序排列 // 把 $data 作为最后一个参数，以通用键排序 array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data); print_r($data); ?&gt; 输出: Array ( [0] =&gt; Array ( [volume] =&gt; 98 [edition] =&gt; 2 ) [1] =&gt; Array ( [volume] =&gt; 86 [edition] =&gt; 1 ) [2] =&gt; Array ( [volume] =&gt; 86 [edition] =&gt; 6 ) [3] =&gt; Array ( [volume] =&gt; 85 [edition] =&gt; 6 ) [4] =&gt; Array ( [volume] =&gt; 67 [edition] =&gt; 2 ) [5] =&gt; Array ( [volume] =&gt; 67 [edition] =&gt; 7 ) ) 4.判断4.1 array_key_exists key是否存在功能: 检查数组里是否有指定的键名或索引语法: array_key_exists(mixed $key , array $array) : bool 说明: 数组里有键key时，返回TRUE。 key可以是任何能作为数组索引的值。 仅仅搜索第一维的键。 多维数组里嵌套的键不会被搜索到。 key_exists函数和此函数功能一样 代码: &lt;?php $search_array = array(&#39;first&#39; =&gt; 1, &#39;second&#39; =&gt; 4); if (array_key_exists(&#39;first&#39;, $search_array)) { echo &quot;key first 存在!&quot;; } else { echo &quot;key first 不存在!&quot;; } 输出: key first 存在! array_key_exists()与isset()对比 isset() 对于数组中为 NULL 的值不会返回 TRUE，而 array_key_exists() 会。 &lt;?php $search_array = array(&#39;first&#39; =&gt; null, &#39;second&#39; =&gt; 4); // returns false isset($search_array[&#39;first&#39;]); // returns true array_key_exists(&#39;first&#39;, $search_array); 4.2 in_array 值是否存在功能: 检查数组中是否存在某个值,如果找到 则返回TRUE，否则返回 FALSE。语法: in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool 说明: needle:待搜索的值。 haystack:待搜索的数组。 strict: 如果第三个参数strict的值为TRUE则会严格匹配类型(===) 代码: &lt;?php // 非严格类型检查 $os = array(&quot;Mac&quot;, &quot;NT&quot;, &quot;Irix&quot;, &quot;Linux&quot;,&quot;1&quot;); if (in_array(&quot;Irix&quot;, $os)) { echo &quot;Got Irix&quot;; } // 严格类型检查 if (in_array(1, $os,true)) { echo &quot;存在数字 1&quot;; } else { echo &quot;不存在数字 1&quot;; } 输出: Got Irix 不存在数字 1 5.计算5.1 array_count_values 统计值出现次数功能: 统计数组中所有的值。语法: array_count_values ( array $array ) : array 说明:结果返回一个数组:数组的键是array里单元的值； 数组的值是array单元的值出现的次数。 代码: &lt;?php $array = array(1, &quot;hello&quot;, 1, &quot;world&quot;, &quot;hello&quot;); print_r(array_count_values($array)); 输出: Array ( [1] =&gt; 2 [hello] =&gt; 2 [world] =&gt; 1 ) 5.2 array_diff_assoc 数组值的差集功能: 带索引检查计算数组的差集。(比较value和key)语法: array_diff_assoc ( array $array1 , array $array2 [, array $... ] ) : array 说明:array_diff_assoc()返回一个数组，该数组包括了所有在array1中但是不在任何其它参数数组中的值。注意和array_diff()不同的是键名也用于比较。代码: &lt;?php $array1 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;b&quot; =&gt; &quot;brown&quot;, &quot;c&quot; =&gt; &quot;blue&quot;, &quot;red&quot;); $array2 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;); $result = array_diff_assoc($array1, $array2); print_r($result); 输出: Array ( [b] =&gt; brown [c] =&gt; blue [0] =&gt; red ) 分析:上面的例子中可以看到键值对 “a” =&gt; “green” 在两个数组中都有，因此不在结果中的输出。与此不同，键值对 0 =&gt; “red” 出现在输出中是因为第二个参数中的 “red” 的键名是 1。 5.3 array_diff_key 数组key的差集功能: 使用键名比较计算数组的差集。语法: array_diff_key(array $array1 ,array $array2 [, array $... ] ) : array 说明:array_diff_key()返回一个数组，该数组包括了所有出现在array1中但是未出现在任何其它参数数组中的键名的值。代码: &lt;?php $array1 = array(&#39;blue&#39; =&gt; 1, &#39;red&#39; =&gt; 2, &#39;green&#39; =&gt; 3, &#39;purple&#39; =&gt; 4,&#39;0&#39;=&gt;&#39;test&#39;); $array2 = array(&#39;green&#39; =&gt; 5, &#39;blue&#39; =&gt; 6, &#39;yellow&#39; =&gt; 7, &#39;cyan&#39; =&gt; 8 ,&#39;test&#39;); print_r(array_diff_key($array1, $array2)); 输出: Array ( [red] =&gt; 2 [purple] =&gt; 4 ) 注意:在 key =&gt; value 对中的两个键名仅在 (string) $key1 === (string) $key2 时被认为相等。换句话说，执行的是严格类型检查，因此字符串的表达必须完全一样。 5.4 array_diff 数组差集功能: 计算数组的差集。(比较key)语法: array_diff(array $array1 , array $array2 [, array $... ] ) : array 说明:对比array1和其他一个或者多个数组，返回在array1中但是不在其他array里的值。代码: &lt;?php $array1 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;red&quot;); $array2 = array(&quot;b&quot; =&gt; &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;); $result = array_diff($array1, $array2); print_r($result); 输出: Array ( [1] =&gt; blue ) 5.5 array_intersect_assoc 数组值的交集功能: 带索引检查计算数组的交集。(比较value和key)语法: array_intersect_assoc(array $array1 , array $array2 [, array $... ] ):array 说明:返回一个数组，该数组包含了所有在array1中也同时出现在所有其它参数数组中的值。注意和array_intersect()不同的是键名也用于比较。代码: &lt;?php $array1 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;b&quot; =&gt; &quot;brown&quot;, &quot;c&quot; =&gt; &quot;blue&quot;, &quot;red&quot;); $array2 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;b&quot; =&gt; &quot;yellow&quot;, &quot;blue&quot;, &quot;red&quot;); $result_array = array_intersect_assoc($array1, $array2); print_r($result_array); 输出: Array ( [a] =&gt; green ) 5.6 array_intersect 数组值的交集功能: 计算数组的交集。(只比较value)语法: array_intersect(array $array1 ,array $array2 [, array $... ] ) : array 说明:返回一个数组，该数组包含了所有在array1中也同时出现在所有其它参数数组中的值。注意键名保留不变。代码: &lt;?php $array1 = array(&quot;a&quot; =&gt; &quot;green&quot;, &quot;red&quot;, &quot;blue&quot;); $array2 = array(&quot;b&quot; =&gt; &quot;green&quot;, &quot;yellow&quot;, &quot;red&quot;); $result = array_intersect($array1, $array2); print_r($result); 输出: Array ( [a] =&gt; green [0] =&gt; red ) 5.7 array_intersect_key 数组key的交集功能: 使用键名比较计算数组的交集。(只比较key)语法: array_intersect_key(array $array1 ,array $array2 [, array $... ] ):array 说明:返回一个数组，该数组包含了所有出现在array1中并同时出现在所有其它参数数组中的键名的值。代码: &lt;?php $array1 = array(&#39;blue&#39; =&gt; 1, &#39;red&#39; =&gt; 2, &#39;green&#39; =&gt; 3, &#39;purple&#39; =&gt; 4); $array2 = array(&#39;green&#39; =&gt; 5, &#39;blue&#39; =&gt; 6, &#39;yellow&#39; =&gt; 7, &#39;cyan&#39; =&gt; 8); print_r(array_intersect_key($array1, $array2)); 输出: Array ( [blue] =&gt; 1 [green] =&gt; 3 ) 5.8 array_product 值的乘积功能: 计算数组中所有值的乘积语法: array_product(array $array ) : number 说明:以整数或浮点数返回一个数组中所有值的乘积。代码: &lt;?php $a = array(2, 4, 6, 8); echo &quot;array_product(a) = &quot; . array_product($a) . &quot;\n&quot;; echo &quot;array_product(array()) = &quot; . array_product(array()) . &quot;\n&quot;; 输出: array_product(a) = 384 array_product(array()) = 1 5.9 array_sum 值求和功能: 对数组中所有值求和语法: array_sum ( array $array ) : number 说明:将数组中的所有值相加，并返回结果。代码: &lt;?php $a = array(2, 4, 6, 8); echo &quot;sum(a) = &quot; . array_sum($a) . &quot;\n&quot;; $b = array(&quot;a&quot; =&gt; 1.2, &quot;b&quot; =&gt; 2.3, &quot;c&quot; =&gt; 3.4); echo &quot;sum(b) = &quot; . array_sum($b) . &quot;\n&quot;; 输出: sum(a) = 20 sum(b) = 6.9 6. 递归6.1 array_merge_recursive 合并功能: 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。说明: 如果输入的数组中有相同的字符串键名，则这些值会被合并到一个数组中去，这将递归下去，因此如果一个值本身是一个数组，本函数将按照相应的条目把它合并为另一个数组。需要注意的是，如果数组具有相同的数值键名，后一个值将不会覆盖原来的值，而是附加到后面。语法: array_merge_recursive ( array $array1 [, array $... ] ) : array 代码: &lt;?php $ar1 = array(&quot;color&quot; =&gt; array(&quot;favorite&quot; =&gt; &quot;red&quot;), 5); $ar2 = array(10, &quot;color&quot; =&gt; array(&quot;favorite&quot; =&gt; &quot;green&quot;, &quot;blue&quot;)); $result = array_merge_recursive($ar1, $ar2); print_r($result); ?&gt; 输出: Array ( [color] =&gt; Array ( [favorite] =&gt; Array ( [0] =&gt; red [1] =&gt; green ) [0] =&gt; blue ) [0] =&gt; 5 [1] =&gt; 10 ) 6.2 array_replace_recursive 替换功能: 使用传递的数组递归替换第一个数组的元素语法: array_replace_recursive(array $array1 [, array $... ] ) : array 说明: 使用后面数组元素的值替换数组 array1 的值 如果一个键存在于第一个数组同时也存在于第二个数组，它的值将被第二个数组中的值替换 如果一个键存在于第二个数组，但是不存在于第一个数组，则会在第一个数组中创建这个元素。 如果一个键仅存在于第一个数组，它将保持不变。 如果传递了多个替换数组，它们将被按顺序依次处理，后面的数组将覆盖之前的值 代码: &lt;?php $base = array(&#39;citrus&#39; =&gt; array( &quot;orange&quot;) , &#39;berries&#39; =&gt; array(&quot;blackberry&quot;, &quot;raspberry&quot;), ); $replacements = array(&#39;citrus&#39; =&gt; array(&#39;pineapple&#39;), &#39;berries&#39; =&gt; array(&#39;blueberry&#39;)); $basket = array_replace_recursive($base, $replacements); print_r($basket); ?&gt; 输出: Array ( [citrus] =&gt; Array ( [0] =&gt; pineapple ) [berries] =&gt; Array ( [0] =&gt; blueberry [1] =&gt; raspberry ) ) 6.3 array_map 遍历功能: 为数组的每个元素应用回调函数语法: array_map(callable $callback ,array $array1 [, array $... ] ):array 说明:返回数组，是为array1每个元素应用callback函数之后的数组。 callback函数形参的数量和传给array_map()数组数量，两者必须一样。 代码: &lt;?php function cube($n) { return($n * $n * $n); } $a = array(1, 2, 3, 4, 5); $b = array_map(&quot;cube&quot;, $a); print_r($b); // 匿名函数 $a = array(1, 2, 3, 4, 5); $sign = 10; $b2 = array_map(function (&amp;$value) use ($sign){ return $value * $sign; },$a); print_r($b2); ?&gt; 输出: Array ( [0] =&gt; 1 [1] =&gt; 8 [2] =&gt; 27 [3] =&gt; 64 [4] =&gt; 125 ) // 匿名函数输出 Array ( [0] =&gt; 10 [1] =&gt; 20 [2] =&gt; 30 [3] =&gt; 40 [4] =&gt; 50 ) 6.4 array_walk 遍历功能: 使用用户自定义函数对数组中的每个元素做回调处理语法: array_walk(array &amp;$array,callable $callback [, mixed $userdata = NULL ]):bool 说明: 如果提供了可选参数userdata，将被作为第三个参数传递给callback funcname callback 接受两个参数。array参数的值作为第一个，键名作为第二个。 只有array的值才可以被改变，用户不应在回调函数中改变该数组本身的结构。例如增加/删除单元，unset 单元等等 代码: &lt;?php $fruits = array(&quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;); function test_alter(&amp;$item1, $key, $prefix) { $item1 = &quot;$prefix: $item1&quot;; } function test_print($item2, $key) { echo &quot;$key. $item2&lt;br /&gt;\n&quot;; } echo &quot;Before ...:\n&quot;; array_walk($fruits, &#39;test_print&#39;); array_walk($fruits, &#39;test_alter&#39;, &#39;fruit&#39;); echo &quot;... and after:\n&quot;; array_walk($fruits, &#39;test_print&#39;); // 匿名函数调用 $a = array(1, 2, 3, 4, 5, 8); $sign = 10; array_walk($a,function (&amp;$val,$key,$sign){ if ($key &gt; 2){ $val *= $sign; } },$sign); print_r($a); ?&gt; 输出: Before ...: d. lemon a. orange b. banana c. apple ... and after: d. fruit: lemon a. fruit: orange b. fruit: banana c. fruit: apple // 匿名函数调用输出 Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 40 [4] =&gt; 50 [5] =&gt; 80 ) 6.5 array_walk_recursive 遍历功能: 对数组中的每个成员递归地应用用户函数，(本函数会递归到更深层的数组中去)语法: array_walk_recursive(array &amp;$array ,callable $callback [, mixed $userdata = NULL ]):bool 说明: 如果提供了可选参数userdata，将被作为第三个参数传递给callback funcname callback 接受两个参数。array参数的值作为第一个，键名作为第二个。 代码: &lt;?php $sweet = array(&#39;a&#39; =&gt; &#39;apple&#39;, &#39;b&#39; =&gt; &#39;banana&#39;); $fruits = array(&#39;sweet&#39; =&gt; $sweet, &#39;sour&#39; =&gt; &#39;lemon&#39;); function test_print($item, $key) { echo &quot;$key holds $item\n&quot;; } array_walk_recursive($fruits, &#39;test_print&#39;); // 匿名函数使用 $sweet = array(&#39;a&#39; =&gt; &#39;apple&#39;, &#39;b&#39; =&gt; &#39;banana&#39;); $fruits = array(&#39;sweet&#39; =&gt; $sweet, &#39;sour&#39; =&gt; &#39;lemon&#39;); $str = &#39;===&gt;&#39;; array_walk_recursive($fruits,function ($val,$key,$str){ echo &quot;$key $str $val \n&quot;; },$str); ?&gt; 输出: a holds apple b holds banana sour holds lemon // 匿名函数调用输出 a ===&gt; apple b ===&gt; banana sour ===&gt; lemon 7. 赋值与变量7.1 list 给一组变量赋值功能: 把数组中的值赋给一组变量语法: list(mixed $var1 [, mixed $... ] ):array 说明: 像array()一样，这不是真正的函数，而是语言结构。 list()可以在单次操作内就为一组变量赋值。 在PHP7.1.0之前的版本，list()仅能用于数字索引的数组，并假定数字索引从0开始。 PHP5里，list()从最右边的参数开始赋值； PHP7里，list()从最左边的参数开始赋值 常用例代码: &lt;?php $info = array(&#39;coffee&#39;, &#39;brown&#39;, &#39;caffeine&#39;); // 列出所有变量 list($drink, $color, $power) = $info; echo &quot;$drink is $color and $power makes it special.\n&quot;; // 列出他们的其中一个 list($drink, , $power) = $info; echo &quot;$drink has $power.\n&quot;; // 或者让我们跳到仅第三个 list( , , $power) = $info; echo &quot;I need $power!\n&quot;; // list() 不能对字符串起作用 list($bar) = &quot;abcde&quot;; var_dump($bar); // NULL ?&gt; 嵌套的list代码: list($a, list($b, $c)) = array(1, array(2, 3)); var_dump($a, $b, $c); 输出: int(1) int(2) int(3) 7.2 compact 创建功能: 建立一个数组，包括变量名和它们的值说明: 对每个参数，compact() 在当前的符号表中查找该变量名并将它添加到输出的数组中，变量名成为键名而变量的内容成为该键的值。简单说，它做的事和 extract() 正好相反。返回将所有变量添加进去后的数组。语法: compact ( mixed $varname1 [, mixed $... ] ) : array 代码: &lt;?php $city = &quot;San Francisco&quot;; $state = &quot;CA&quot;; $event = &quot;SIGGRAPH&quot;; $location_vars = array(&quot;city&quot;, &quot;state&quot;); $result = compact(&quot;event&quot;, &quot;nothing_here&quot;, $location_vars); print_r($result); ?&gt; 输出: Array ( [event] =&gt; SIGGRAPH [city] =&gt; San Francisco [state] =&gt; CA ) 7.3 extract 导出为变量功能: 从数组中将变量导入到当前的符号表说明: array:一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量，并受到 flags 和 prefix 参数的影响。 flags EXTR_OVERWRITE : 如果有冲突，覆盖已有的变量 EXTR_SKIP: 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME: 如果有冲突，在变量名前加上前缀prefix。 EXTR_PREFIX_ALL: 给所有变量名加上前缀 prefix。查看更多 语法: extract(array &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]]):int 代码: &lt;?php /* 假定 $var_array 是 wddx_deserialize 返回的数组*/ $size = &quot;large&quot;; $var_array = array(&quot;color&quot; =&gt; &quot;blue&quot;, &quot;size&quot; =&gt; &quot;medium&quot;, &quot;shape&quot; =&gt; &quot;sphere&quot;); extract($var_array, EXTR_PREFIX_SAME, &quot;wddx&quot;); echo &quot;$color, $size, $shape, $wddx_size\n&quot;; ?&gt; 输出: blue, large, sphere, medium $size 没有被覆盖，因为指定了 EXTR_PREFIX_SAME，这使得 $wddx_size 被建立。如果指定了 EXTR_SKIP，则 $wddx_size 也不会被建立。]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQ-面试题]]></title>
    <url>%2F2017%2F09%2F19%2FMQ-%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.为什么要用消息队列?解耦、异步、削峰 解耦: A系统调用B系统、C系统，传统的调用是直接调用，但是当B系统说我不需要你提供数据了，这时候A需要改代码，Ｃ系统说我不需要某个字段了，这时候Ａ也要改代码，如果又多了一个D系统，A又要写代码。为了实现解耦，引入消息队列，Ａ将产生的数据丢到消息队列中，哪个系统需要 哪个系统就去取； 异步: A系统调用B系统，B系统由于某个需要调用第三方接口超时，导致A系统响应速度慢，而B系统的好坏又不会影响业务逻辑，所以可以改为A异步调用B，A将消息丢到消息队列中，B系统订阅消息，实现A的快速响应； 削峰: 当大量流量请求到系统A时，由于数据库的处理能力有限，造成数据库连接异常。使用消息队列，大量请求先丢到消息队列中，系统A使用按批拉数据的方式，批量处理数据，生产中，高峰期短暂的消息积压是允许的。 2.使用消息队列有什么缺点? 系统复杂性增加：加了消息队列，需要保证消息不会重复消费，需要保证消息的可靠性，需要保证消息队列的高可用 系统的可用性降低：如果消息队列挂了，那么系统也会受到影响 3.为什么选用RocketMQ；RocketMQ和ActiveMQ的区别?RocketMQ模型简单、接口易用，在阿里大规模使用，社区活跃，单机吞吐量10万级，可用性非常高，消息理论上不会丢失； ActiveMQ严格遵循JMS规范，可持久化到内存、文件、数据库，可用性高主要是主从，多语言支持，消失丢失率低； RocketMQ持久化到磁盘文件，可用性非常高，支持分布式，只支持Java，消息理论上不会丢失； 4.MQ能否保证消息必达，即消息的可靠性？为了降低消息丢失的概率，MQ需要进行超时和重传，以下是MQ的工作流程 MQ-client-sender 发送消息给MQ-server MQ-server接收到消息后，发送ACK消息给发送方 MQ-client-sender 接收到 ACK消息后，则消息已经投递成功 MQ-server 将消息发送给 MQ-client-receiver MQ-client-receiver 得到消息处理业务逻辑 MQ-client-receiver 回复 ACK消息给 MQ-server MQ-server收到 ACK消息，将已消费的消息删除 注意点: 如果上述 步骤2消息丢失或者超时，MQ-client-sender 内的 timer 会重发消息，直到收到 ACK消息，如果重试N次后还未收到，则回调发送失败。需要注意的是，这个过程中 MQ-server 可能会收到同一条消息的多次重发。对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是： 全局唯一 MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽 如果上述步骤6 消息丢失或者超时，MQ-server 内的 timer 会重发消息，直到 MQ-server 收到ACK消息并且将已消费的消息删除，这个过程也可能会重发多次，MQ-client-receiver 也可能会收到同一条消息的多次重发。需要强调的是，MQ-client-receiver 回ACK给 MQ-server，是消息消费业务方的主动调用行为，不能由 MQ-client-sender 自动发起，因为MQ系统不知道消费方什么时候真正消费成功。为了保证业务幂等性，业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是： 对于同一个业务场景，全局唯一 由业务消息发送方生成，业务相关，对MQ透明 由业务消息消费方负责判重，以保证幂等 4.为什么会造成重复消费？其实无论是哪种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发出的确认消息形式不同，例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offet的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。 造成重复消费的原因:因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 5.如何保证消息不被重复消费？这个问题针对业务场景来答，分以下三种情况 如果你拿到这个消息做数据库的insert操作，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。 如果你拿到这个消息做redis的set的操作，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。 如果上面两种情况还不行，准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis.那消费者开始消费前，先去redis中查询有没有消费记录即可。 6.如何保证消费的可靠性传输？其实这个可靠性传输，指的就是不能弄丢数据，每种MQ都要从三个角度来分析： 生产者弄丢数据 消息队列弄丢数据 消费者弄丢数据 1.生产者弄丢数据从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()） 然而，这种方式有个缺点：吞吐量下降。因为，按照经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 2.消息队列丢数据处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢，安装下面这两步即可 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 3.消费者丢数据消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rabbitMQ会立即将消息删除，这种情况下，如果消费者出现异常而未能处理消息，就会丢失该消息。 至于解决方案，采用手动确认消息即可。 7.如何保证消息的顺序性？针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。 8.消息队列积压怎么办？消息队列积压的影响:- 当消费者出现异常，很容易引起队列积压，如果一秒钟1000个消息，那么一个小时就是几千万的消息积压，是非常可怕的事情，但是生产线上又有可能会出现；- 当消息积压来不及处理，rabbitMQ如果设置了消息过期时间，那么就有可能由于积压无法及时处理而过期，这消息就被丢失了；解决方法如下: 不建议在生产环境使用数据过期策略，一是数据是否丢失无法控制，二是一旦积压就很有可能丢失；建议数据的处理都有代码来控制； 当出现消息积压时，做法就是临时扩大consumer个数，让消息快速消费，一般都是通过业务逻辑的手段来完成 其他参考链接 面试：分布式之消息队列要点复习 消息中间件—RabbitMQ（集群原理与搭建篇)]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-面试题整理]]></title>
    <url>%2F2017%2F09%2F18%2Fredis-view-question%2F</url>
    <content type="text"><![CDATA[1.Redis与Memcached的区别与比较 Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。 redis的速度比memcached快很多 Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。 2.Redis与Memcached的选择使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis； 3.使用redis有哪些好处？ 速度快:，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 支持丰富数据类型:，支持string，list，set，sorted set，hash 支持事务: redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。 丰富的特性: 可用于缓存，消息，按key设置过期时间，过期后将会自动删除 4.Redis为什么是单线程的？多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。 5.Redis单点吞吐量单点TPS达到8万/秒，QPS达到10万/秒，补充下TPS和QPS的概念 QPS(应用系统每秒钟最大能接受的用户访问量): 每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。 TPS(每秒钟最大能处理的请求数): 每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。 6.Redis有哪几种数据淘汰策略？在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。淘汰策略如下几种: volatile-lru: 从已设置过期的数据集中挑选最近最少使用的淘汰 volatile-ttl: 从已设置过期的数据集中挑选将要过期的数据淘汰 volatile-random: 从已设置过期的数据集中任意挑选数据淘汰 allkeys-lru: 从数据集中挑选最近最少使用的数据淘汰 allkeys-random: 从数据集中任意挑选数据淘汰 noenviction: 禁止淘汰数据 redis淘汰数据时还会同步到aof 7.Redis的并发竞争问题如何解决?Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法： 1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。 2.服务器角度，利用setnx实现锁。 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。 8.Redis常见性能问题和解决方案: Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 尽量避免在压力很大的主库上增加从库 9.Redis有哪些数据结构？字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。 10.Redis大量数据插入例如，如果我们需要生成一个10亿的`keyN -&gt; ValueN’的大数据集，我们会创建一个如下的redis命令集的文件(data.txt)： SET Key0 Value0 SET Key1 Value1 ... SET KeyN ValueN 一旦创建了这个文件，其余的就是让Redis尽可能快的执行。在以前我们会用如下的netcat命令执行： (cat data.txt; sleep 10) | nc localhost 6379 &gt; /dev/null 然而这并不是一个非常可靠的方式，因为用netcat进行大规模插入时不能检查错误。从Redis 2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。使用pipe mode模式的执行命令如下： cat data.txt | redis-cli --pipe 输出如下信息： All data transferred. Waiting for the last reply... Last reply received from server. errors: 0, replies: 1000000 pipe mode的工作原理是什么？难点是保证redis-cli在pipe mode模式下执行和netcat一样快的同时，如何能理解服务器发送的最后一个回复。这是通过以下方式获得： redis-cli –pipe试着尽可能快的发送数据到服务器。 读取数据的同时，解析它。 一旦没有更多的数据输入，它就会发送一个特殊的ECHO命令，后面跟着20个随机的字符。我们相信可以通过匹配回复相同的20个字符是同一个命令的行为。 一旦这个特殊命令发出，收到的答复就开始匹配这20个字符，当匹配时，就可以成功退出了。 同时，在分析回复的时候，我们会采用计数器的方法计数，以便在最后能够告诉我们大量插入数据的数据量。 11.Redis中的管道有什么用？一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 12.怎么理解Redis事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 13.为什么要做Redis分区？分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 14.你知道有哪些Redis分区实现方案？ 客户端分区: 就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区: 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点 15.Redis的内存用完了会发生什么？如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-面试题整理]]></title>
    <url>%2F2017%2F09%2F17%2Fphp-interView-question%2F</url>
    <content type="text"><![CDATA[1、基础1.1 cookie与session的区别 存储位置：session存储于服务器，cookie存储于客户端 安全性：session安全性比cookie高 存放的形式：Session是以对象的形式保存在服务器，Cookie以字符串的形式保存在客户端 用途：Cookies适合做保存用户的个人设置,爱好等,Session适合做客户的身份验证 session为’会话服务’，在使用时需要开启服务，cookie不需要开启，可以直接用 1.2 禁用 cookie 后 session 还能用吗?可以,通过URL传值或者隐藏表单传递Session ID (常用)。 Session和cookie的工作流程： 你第一次访问网站时， 服务端脚本中开启了session_start();， 服务器会生成一个不重复的 SESSIONID 的文件session_id();，比如在/var/lib/php/session目录 并将返回(Response)如下的HTTP头 Set-Cookie:PHPSESSIONID=xxxxxxx 客户端接收到Set-Cookie的头，将PHPSESSIONID写入cookie 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端 服务器识别PHPSESSIONID这个cookie，然后去session目录查找对应session文件， 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 1.3 表单中get与post提交方法的区别参数接收： get：通过url参数传递进行接收, post：是实体数据,可以通过表单提交大量信息. 1.4 数据库中的事务是什么 事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消 1.5 echo(),print(),print_r()的区别 echo是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用) print() 只能打印出简单类型变量的值(如int,string) print_r() 可以打印出复杂类型变量的值(如数组,对象) echo 输出一个或者多个字符串 1.6 用PHP写出显示客户端IP与服务器IP的代码# 打印客户端IP $_SERVER[&quot;REMOTE_ADDR&quot;] # 打印服务器IP $_SERVER[&quot;SERVER_ADDR&quot;] 1.7 include和require的区别是什么? require:是无条件包含也就是如果一个流程里加入require,无论条件成立与否都会先执行require include:有返回值，而require没有(可能因为如此require的速度比include快) 注意:包含文件不存在或者语法错误的时候,require是致命的,include不是 1.8 Trait是什么?Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题 单个Trait使用方法： &lt;?php trait ezcReflectionReturnInfo { function getReturnType() { /*1*/ } function getReturnDescription() { /*2*/ } } class ezcReflectionMethod extends ReflectionMethod { use ezcReflectionReturnInfo; /* ... */ } class ezcReflectionFunction extends ReflectionFunction { use ezcReflectionReturnInfo; /* ... */ } ?&gt; 多个Trait使用方法 &lt;?php trait Hello { public function sayHello() { echo &#39;Hello &#39;; } } trait World { public function sayWorld() { echo &#39;World&#39;; } } class MyHelloWorld { use Hello, World; public function sayExclamationMark() { echo &#39;!&#39;; } } $o = new MyHelloWorld(); $o-&gt;sayHello(); $o-&gt;sayWorld(); $o-&gt;sayExclamationMark(); ?&gt; 1.9 php7和php5区别1.PHP7.0 比PHP5.6性能提升了两倍。1). 变量存储字节减小，减少内存占用，提升变量操作速度 2). 改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率 3). 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率 2.PHP7.0全面一致支持64位。 3.PHP7.0之前出现的致命错误，都改成了抛出异常。 4.增加了空结合操作符（？？）。效果相当于三元运算符。 5.PHP7.0新增了函数的返回类型声明。 6.PHP7.0新增了标量类型声明。PHP 7 中的函数的形参类型声明可以是标量。在 PHP 5 中只可以是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。 7.新增加了匿名类。 PHP 5.3 开始有了匿名函数，现在又新增了匿名类； 8.PHP7.0之后溢移除了一些老的不再支持的SAPI(服务器端应用编程端口)和扩展。 ereg mssql mysql sybase_ct 9.define 现在可以定义常量数组。 1.10 谈谈对mvc的认识模型(model),视图(view),控制器(controller); 由模型发出要实现的功能到控制器,控制器接收组织功能传递给视图; 1.11 请说明php中传值与传引用的区别。什么时候传值什么时候传引用? 按值传递：函数范围内对值的任何改变在函数外部都会被忽略 按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改 优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处 1.12 从一个标准url 里取出文件的扩展名例如: http://www.sina.com.cn/abc/de/fg.php?id=1 需要取出php 或.php $url=&#39;http://www.sina.com.cn/abc/de/fg.php?id=1&#39;; $pathInfo = pathinfo($url); if(strpos($pathInfo[&#39;extension&#39;],&#39;?&#39;)){ $tmp = explode(&#39;?&#39;,$pathInfo[&#39;extension&#39;]); $extend = $tmp[0]; } else{ $extend = $pathInfo[&#39;extension&#39;]; } var_dump($pathInfo,$tmp,$extend); /** * 输出: array(4) { [&quot;dirname&quot;]=&gt; string(29) &quot;http://www.sina.com.cn/abc/de&quot; [&quot;basename&quot;]=&gt; string(11) &quot;fg.php?id=1&quot; [&quot;extension&quot;]=&gt; string(8) &quot;php?id=1&quot; [&quot;filename&quot;]=&gt; string(2) &quot;fg&quot; } array(2) { [0]=&gt; string(3) &quot;php&quot; [1]=&gt; string(4) &quot;id=1&quot; } string(3) &quot;php&quot; */ 1.13 字符串反转function strrev($str){ $len = mb_strlen($str); $tmp=[]; for ($i=0;$i&lt;$len;$i++){ $tmp[] = mb_substr($str,$i,1); } krsort($tmp); return implode(&#39;&#39;,$tmp); } var_dump(strrev(&#39;我是一个PHP程序员！&#39;)); // 输出: string(27) &quot;！员序程PHP个一是我&quot; strrev函数对英文很好用,直接可以实现字符串翻转,但是面对中文会出现乱码 1.14 在HTTP 1.0中，状态码401 的含义是? 如果返回 “找不到文件” 的提示，则可用header函数，其语句为?答：401表示未授权; header(&quot;HTTP/1.0 404 Not Found&quot;); 1.15 isset、empty和is_null的区别? isset 判断变量是否已存在，如果变量存在则返回 TRUE，否则返回 FALSE。 empty 判断变量是否为空，如果变量是非空或非零的值，则empty() 返回 FALSE。换句话说，”” 、0 、”0”、NULL 、FALSE 、array() 、var $var; 以及没有任何属性的对象都将被认为是空的，如果变量为空，则返回TRUE。 is_null 判断变量是否为NULL 1.16 单引号’与双引号”区别 php里的单引号把内容当成纯文本，不会经过服务器翻译。而双引号则与此相反。里面的内容会经过服务器处理(process)； $foo=&quot;data&quot;; echo &#39;$foo&#39;; //单引号输出$foo echo &quot;$foo&quot;; //双引号输出data 1.17 如果理解OOP？OOP(object oriented programming)，即面向对象编程，其中两个最重要的概念就是类和对象，类只是具备了某些功能和属性的抽象模型，而实际应用中需要一个一个实体，也就是需要对类进行实例化，类在实例化之后就是对象。 OOP具有三大特点： 封装性： 将一个类的使用和实现分开,只保留部分接口和方法供外部使用，所以开发人员只需要关注这个类如何使用，而不用去关心其具体的实现过程。 继承性： 子类自动继承其父级类中的属性和方法,并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。 php只支持单继承，也就是说一个子类只能有一个父类。 多态性： 继承了来自父级类中的属性和方法，并对其中部分方法进行重写,于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。 1.18 接口和抽象类的区别是什么？ 抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。 抽象类是通过关键字 abstract 来声明的。 抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法， 抽象方法没有方法体，该方法天生就是要被子类重写的。 抽象方法的格式为：abstract function abstractMethod(); 因为php中只支持单继承，如果想实现多重继承，就要使用接口。也就是说子类可以实现多个接口。 接口是通过interface关键字来声明的，接口中的成员常量和方法都是public的，方法可以不写关键字public， 接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。 抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。 子类继承抽象类使用extends，子类实现接口使用implements。 1.19 常见 HTTP 状态码，分别代表什么含义 200:请求成功 206:部分内容 服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具，都是使用此类响应实现断点续传，或者将一个大文档分解为多个下载段同时下载。 301:永久重定向 302:临时重定向 400:错误请求 401:未经授权 403:禁止访问 404:文件未找到 500:内部服务器错误 502:无效网关 1.20 计算两个日期相隔多少年，多少月，多少天，多少小时，多少分钟，多少秒&lt;?php /** * function：计算两个日期相隔多少年，多少月，多少天，多少小时，多少分钟，多少秒 * param string $date1[格式如：2011-11-5] * param string $date2[格式如：2012-12-01] * return array array(&#39;年&#39;,&#39;月&#39;,&#39;日&#39;); */ function diffDate($date1,$date2) { $datetime1 = new \DateTime($date1); $datetime2 = new \DateTime($date2); $interval = $datetime1-&gt;diff($datetime2); $time[&#39;y&#39;] = $interval-&gt;format(&#39;%Y&#39;); $time[&#39;m&#39;] = $interval-&gt;format(&#39;%m&#39;); $time[&#39;d&#39;] = $interval-&gt;format(&#39;%d&#39;); $time[&#39;h&#39;] = $interval-&gt;format(&#39;%H&#39;); $time[&#39;i&#39;] = $interval-&gt;format(&#39;%i&#39;); $time[&#39;s&#39;] = $interval-&gt;format(&#39;%s&#39;); return $time; } # 使用实例 $sss = diffDate(&#39;2018-12-25 12:30:30&#39;, &#39;2018-12-26 15:00:00&#39;); print_r($sss); 输出结果： Array ( [y] =&gt; 00 [m] =&gt; 0 [d] =&gt; 1 [h] =&gt; 02 [i] =&gt; 29 [s] =&gt; 30 ) 1.21 长连接、短连接的区别和使用涵义说明: 长连接：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。 短连接：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S通信。 使用时机: 长连接使用场景:长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，频繁的socket创建也是对资源的浪费。 短连接使用场景:web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。 1.22 如何防止盗链？ 不定期更名文件或者目录 加入水印 限制引用页原理:服务器获取用户提交信息的网站地址，然后和真正的服务端的地址相比较， 如果一致则表明是站内提交，或者为自己信任的站点提交，否则视为盗链。实现时可以使用HTTP_REFERER 和htaccess 文件(需要启用mod_Rewrite)，结合正则表达式去匹配用户的每一个访问请求。 文件伪装文件伪装是目前用得最多的一种反盗链技术，一般会结合服务器端动态脚本 (PHP/JSP/ASP)。实际上用户请求的文件地址，只是一个经过伪装的脚本文件，这个脚本文件会对用户的请求作认证,一般会检查 Session，Cookie 或HTTP_REFERER 作为判断是否为盗链的依据。而真实的文件实际隐藏在用户不能够访问的地方，只有用户通过验证以后才会返回给用户 加密认证这种反盗链方式，先从客户端获取用户信息，然后根据这个信息和用户请求的文件名 字一起加密成字符串(Session ID)作为身份验证。只有当认证成功以后，服务端才会把用户需要的文件传送给客户。一般我们会把加密的Session ID 作为URL 参数的一部分传递给服务器，由于这个Session ID 和用户的信息挂钩，所以别人就算是盗取了链接，该Session ID 也无法通过身份认证，从而达到反盗链的目的。这种方式对于分布式盗链非常有效。 随机附加码每次,在页面里生成一个附加码,并存在数据库里,和对应的图片相关,访问图片时和此附加码对比,相同则输出图片,否则输出404图片 查看阿里云防盗链方案 1.23.for与foreach哪个更快?foreach 的效率要比 for 高很多，也许有很大的一个原因是 for 要进行很多次条件判断。所以以后能用 foreach 的地方就用 foreach ，可以提高1倍的效率。如果循环内要调用函数，用 array_walk 最好，它的效率要比 for 高出1倍，要比 foreach 高出43%的效率。 1.24.strlen()与mb_strlen的作用与区别在PHP中，strlen与mb_strlen是求字符串长度的函数. strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。 mbstrlen函数可以较好地解决这个问题。mbstrlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串$str长度，可以用 mbstrlen($str,’UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mbinternal_encoding()函数得到。 需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了mbstring扩展，否则会出现未定义函 数的问题。 1.25.foo()与@foo()有什么分别？ foo(): 会执行这个函式，任何解译错误、语法错误、执行错误都会在页面上显示出来。 @foo(): 在执行这个函式时，会隐藏所有上述的错误讯息。 很多应用程式都使用 @mysql_connect() 和 @mysql_query 来隐藏 mysql 的错误讯息，我认为这是很严重的失误，因为错误不该被隐藏，你必须妥善处理它们，可能的话解决它们。 1.26.GD函式库用来做什么？gd库是php处理图形的扩展库，gd库提供了一系列用来处理图片的API，使用GD库可以处理图片，或者生成图片。 在网站上GD库通常用来生成缩略图或者用来对图片加水印或者对网站数据生成报表。 1.27.在PHP中error_reporting这个函数有什么作用？打开或者关闭错误报告 error_reporting(0):关闭错误报告 error_reporting(E_ERROR | E_WARNING | E_PARSE):报告 runtime 错误 error_reporting(E_ALL):报告所有错误 ini_set(“error_reporting”, E_ALL):等同 error_reporting(E_ALL) error_reporting(E_ALL &amp; ~E_NOTICE):报告 E_NOTICE 之外的所有错误 1.28.构造方法、析构方法是如何定义的？构造方法: 在实例化一个对象的同时自动执行的成员方法，作用就是初始化对象。php5之前，一个跟类名完全相同的方法是构造方法，php5之后魔术方法__construct()就是构造方法。如果类中没有定义构造方法，那么php会自动生成一个，这个自动生成的构造方法没有任何参数，没有任何操作。构造方法的格式如下： function __construct(){} 析构方法:作用和构造方法正好相反，是对象被销毁时被自动调用的，作用是释放内存。 function __destruct(){} 因为php具有垃圾回收机制，能自动清除不再使用的对象，释放内存，一般情况下可以不手动创建析构方法。 1.29.文件上传应该注意哪些细节？1.首现要在php.ini中开启文件上传；2.在php.ini中有一个允许上传的最大值，默认是2MB。必要的时候可以更改；3.上传表单一定要记住在form标签中写上enctype=”multipart/form-data”；4.要注意上传文件的大小、文件类型是否符合要求，上传后存放的路径是否存在。 1.30.PHP数据类型有哪些?php支持8种原始数据类型。如下: 四种标量类型（布尔型boolean，整型interger，浮点型float/double , 字符串string） 两种复合类型(数组array ， 对象object) 两种特殊类型（资源resource，NULL） 1.31.你是如何认识ajax的？ajax是asynchronous javascript and xml的缩写，是javascript、xml、css、DOM等多个技术的组合。Ajax的工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了。所以ajax技术实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时也从而降低了网络流量，增强了客户体验的友好程度。Ajax的优点 减轻了服务器端负担，将一部分以前由服务器负担的工作转移到客户端执行，利用客户端闲置的资源进行处理； 在只局部刷新的情况下更新页面，增加了页面反应速度，使用户体验更友好。 Ajax的缺点 不利于seo推广优化，因为搜索引擎无法直接访问到ajax请求的内容。 2、进阶2.1 yield 是什么，说个使用场景 yield是生成器函数的核心关键字， 使用场景：协程可以用在，异步网络 IO 的时候，使其成为非阻塞的， 使用示例: &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); function readTxt() { # code... $handle = fopen(&quot;./test.txt&quot;, &#39;rb&#39;); while (feof($handle)===false) { # code... yield fgets($handle); } fclose($handle); } foreach (readTxt() as $key =&gt; $value) { # code... echo $value.&#39;&lt;br/&gt;&#39;; } 使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，每次被加载到内存中的文字只有一行，大大的减小了内存的使用 在PHP中使用协程实现多任务调度 2.2 session共享方案 搭建redis集群或者memcached集群，用集群自带的同步方法来帮我们在不同的主机中同步session，这样就相当于把原来的一份session变成了N分session，session的同步就依赖于NoSql集群的同步了。 单独设置一个session服务器，负载服务器得到一个sessionid过后，去session服务器获得会话状态，然后根据状态来响应用户请求，如果会话状态为空，则在session服务器中设置一个会话状态，然后返回给用户一个sessionid。 2.3 php7.2 为什么弃用__autoload自动加载的原理，就是在我们new一个class的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的__autoload($class_name)方法，我们new的这个class_name 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要new class_name的各种判断和划分就去require对应的路径类文件，从而实现自动加载。 弃用原因:PHP不允许函数重名，所以一个项目中仅能出现一个__autoload函数。自己写的代码保证只有一个__autoload函数虽然有点难但也能做到，要是第三方库也定义了__autoload，那就很头疼了。__autoload的后继者是spl_autoload_register函数 2.4 Zval结构 PHP5 Zval结构struct _zval_struct { union { long lval; double dval; struct { char *val; int len; } str; HashTable *ht; zend_object_value obj; zend_ast *ast; } value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; }; PHP5 Zval结构存在的问题: 整个结构体的大小是(在64位系统)24个字节, 而zval.value联合体中zend_object_value是最大的长板, 它导致整个value需要16个字节。 结构体中的每一个字段都有明确的定义, 没有预留任何的自定义字段,在存储一些和zval相关的信息的时候，不得不采用其他方式来扩充zval PHP的zval大部分都是按值传递,但有俩个例外(对象和资源),它们永远都是按引用传递，这样就造成一个问题, 对象和资源在除了zval中的引用计数以外, 还需要一个全局的引用计数, 这样才能保证内存可以回收。在PHP5的时代, 以对象为例, 它有俩套引用计数, 一个是zval中的, 另外一个是obj自身的计数。非此之外，需要多次读取内存, 才能获取到真正的objec对象本身 PHP5的时代调用MAKE_STD_ZVAL会在堆内存上分配一个临时变量 PHP7 Zval结构struct _zval_struct { union { zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct { uint32_t w1; uint32_t w2; } ww; } value; union { struct { ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ } v; uint32_t type_info; } u1; union { uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ } u2; }; PHP7对Zval结构优化: 整个结构体内部都是联合体，这个新的zval在64位环境下,现在只需要16个字节(2个指针size), 它主要分为俩个部分, value和扩充字段, 而扩充字段又分为u1和u2俩个部分, 其中u1是type info, u2是各种辅助字段. 在PHP7中，移除了MAKE_STD_ZVAL/ALLOC_ZVAL宏, 不再支持存堆内存上申请zval. 函数内部使用的zval要么来自外面输入, 要么使用在栈上分配的临时zval. 抽象的来说, PHP7中的zval, 已经变成了一个值指针, 要么保存着原始值, 要么保存着指向一个保存原始值的指针. 也就是说现在的zval相当于PHP5的时候的zval. 只不过相比于zval, 直接存储zval, 我们可以省掉一次指针解引用, 从而提高缓存友好性. 深入理解PHP7内核之zval 2.5 PHP内存管理机制与垃圾回收机制PHP的内存管理机制:预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。 存储变量名，存在符号表。 变量值存储在内存空间。 在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。 PHP垃圾回收机制: PHP5.2及之前版本: PHP会根据引用计数refcount值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。 PHP5.3及之后版本: 如果发现一个 zval 容器中的 refcount 在增加，说明不是垃圾； 如果发现一个 zval 容器中的 refcount 在减少，如果减到了0，直接当做垃圾回收； 如果发现一个 zval 容器中的 refcount 在减少，并没有减到0，PHP 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象； 当缓冲区达到了临界值，PHP 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。 2.6 HTTP Keep-Alive的作用作用: Keep-Alive使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。 缺点: 对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。 解决: Keep-Alive: timeout=5, max=100 # timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout） # max是最多一百次请求，强制断掉连接。 # 就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。 3、数据库3.1 Mysql的存储引擎,MyISAM和InnoDB的区别。 MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快. InnoDB不支持FULLTEXT(全文索引) 类型的索引. InnoDB 中不保存表的具体行数. 也就是说执行 ：select count(*) from table时， InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可. 对于AUTO_INCREMENT(递增)类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 Load Table From Master 操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用. MyISAM支持表锁，InnoDB支持行锁。 3.2 delete drop truncate区别 truncate 和 delete只删除数据，不删除表结构 ,drop删除表结构，并且释放所占的空间。 删除数据的速度，一般来说: drop&gt; truncate &gt; delete delete属于DML语言，需要事务管理，commit之后才能生效。drop和truncate属于DDL语言，操作立刻生效，不可回滚 使用场合： 1.当你不再需要该表时， 用drop; 2.当你仍要保留该表，但要删除所有记录时， 用truncate; 3.当你要删除部分记录时（always with a where clause), 用 delete. 对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器 3.3 优化MYSQL数据库的方法 选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM 使用连接（JOIN）来代替子查询 a.删除没有任何订单客户: DELETE FROM customerinfo WHERE customerid NOT in(SELECT customerid FROM orderinfo) b.提取所有没有订单客户: SELECT FROM customerinfo WHERE customerid NOT in(SELECT customerid FROM orderinfo) c.提高b的速度优化: SELECT FROM customerinfo LEFT JOIN orderid customerinfo.customerid=orderinfo.customerid WHERE orderinfo.customerid IS NULL 使用联合(UNION)来代替手动创建的临时表SELECT name FROM `nametest` UNION SELECT username FROM `nametest2` 事务处理 保证数据完整性,例如添加和修改同时,两者成立则都执行,一者失败都失败。 锁定表,优化事务处理 我们用一个 SELECT 语句取出初始数据，通过一些计算，用 UPDATE 语句将新值更新到表中。包含有 WRITE 关键字的 LOCK TABLE 语句可以保证在 UNLOCK TABLES 命令被执行之前，不会有其它的访问来对 inventory 进行插入、更新或者删除的操作. mysql_query(&quot;LOCK TABLE customerinfo READ, orderinfo WRITE&quot;); mysql_query(&quot;SELECT customerid FROM `customerinfo` where id=&quot;.$id); mysql_query(&quot;UPDATE `orderinfo` SET ordertitle=&#39;$title&#39; where customerid=&quot;.$id); mysql_query(&quot;UNLOCK TABLES&quot;); 建立索引索引类型,请看3.7 优化查询语句 避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 避免全表扫描，首先应考虑在where及order by涉及的列上建立索引 避免在 where子句中对字段进行null值判断，会引起全表扫描 如：select id from test where num is null 因此字段都应设置为NOT NULL，将来查询的时候就不用去比较NULL值 避免在where子句中使用or来连接条件，会引起全表扫描如：select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描 避免在 where 子句中对字段进行表达式操作 如：select id from t where num/2=100 应改为： select id from t where num =100*2 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，一个表的索引数最好不要超过6个。 任何地方都不要使用 select * from t ，用具体的字段列表代替”*”，不要返回用不到的任何字段。 通过explain查询和分析SQL的执行计划 3.4 mysql_fetch_row() 和 mysql_fetch_array() 有什么分别？ mysql_fetch_row() 返回的结果集是索引数组。 mysql_fetch_assoc() 返回的结果集是关联数组 mysql_fetch_array() 既可以返回索引数组也可以返回关联数组， 取决于它的第二个参数 MYSQL_BOTH MYSQL_NUM MYSQL_ASSOC 默认为MYSQL_BOTH 3.5 php访问数据库有哪几步? 1.连接数据库服务器： mysql_connect(&#39;数据库服务器的主机名或ip&#39;,&#39;数据库服务器的用户名&#39;,&#39;数据库服务器的密码&#39;); 2.选择数据库： mysql_select_db(数据库名); 3.设置从数据库提取数据的字符集： mysql_query(&quot;set names utf8&quot;); 4.执行sql语句： mysql_query(sql语句); 5.关闭结果集，释放资源： mysql_free_result($result); 6.关闭与数据库服务器的连接： mysql_close($link); 3.6 表设计三大范式 1．第一范式(原子性):所有字段值都是不可分解的原子值 2．第二范式(在第一范式的基础上):确保表中的每列都和主键相关，即一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中 3．第三范式(在第二范式的基础上):确保每列都和主键列直接关联,而不是间接相关 3.7 索引类型 普通索引(index): # 创建: CREATE INDEX &lt;索引名&gt; ON tablename (索引字段) # 修改: ALTER TABLE tablename ADD INDEX [索引名] (索引字段) # 创表指定索引: CREATE TABLE tablename([...],INDEX[索引名](索引字段)) 唯一索引(unique):在普通索引的基础上，会进行排除重复值 # 创建: CREATE UNIQUE &lt;索引名&gt; ON tablename (索引字段) # 修改: ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段) # 创表指定索引: CREATE TABLE tablename([...],UNIQUE[索引名](索引字段)) 主键(primary key):和唯一索引的区别在于一个表里只能有一个主键索引，但是唯一索引可以有多个 # 它是唯一索引,一般在创建表是建立,语法： CREATA TABLE tablename ([...],PRIMARY KEY[索引字段]) 联合索引: # 语法： ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 ) 全文索引 (fulltext)版本支持 MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引； MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引; 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。 创建全文索引 # 创建表时创建全文索引 CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;用户ID&#39;, `phone` char(11) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;手机号&#39;, `name` varchar(30) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户名&#39;, `address` text NOT NULL COMMENT &#39;地址&#39;, PRIMARY KEY (`id`), FULLTEXT KEY address_fulltext(address) # 创建全文索引列 ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;用户帐号表&#39;; # 在已存在的表上创建全文索引 CREATE fulltext index name_fulltext on `user`(address); # 通过SQL语句 ALTER TABLE 创建全文索引 alter table `user` add FULLTEXT index name_fulltext(address); 使用全文索引和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如 SELECT * from `user` WHERE MATCH(`address`) against(&#39;碧园春小区&#39;) match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。 普通索引／唯一索引／主键索引 哪个速度更快？速度是一样的快，因为三者都是采用btree二叉树算法进行查找。 3.8 索引算法 BTREE算法 Innodb和MyISAM默认的索引是BTREE索引采用二叉树算法，左边的树枝小于根节点关键词，右边大于根节点，两边的树的深度不大于1，从而降低时间复杂度。 HASH算法 Mermory默认的索引是Hash索引Hash索引只能用于HASH值比较，例如=,&lt;&gt; 操作符，不像BTREE索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTREE索引。 为什么不默认采用HASH索引呢？ HASH只能用在=和&lt;&gt;上，所以功能受限，所以默认采用BTREE。 3.9 insert 和 replace的区别replace into 跟 insert 功能类似，不同点在于：replace into 首先尝试插入数据到表中， 1. 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。 要注意的是：插入数据的表必须有主键或者是唯一索引！否则的话，replace into 会直接插入数据，这将导致表中出现重复的数据。 MySQL replace into 有三种形式： replace into tbl_name(col_name, ...) values(...) replace into tbl_name(col_name, ...) select ... replace into tbl_name set col_name=value, ... 前两种形式用的多些。其中 “into” 关键字可以省略，不过最好加上 “into”，这样意思更加直观。另外，对于那些没有给予值的列，MySQL 将自动为这些列赋上默认值 3.10 数据库操作事务的四大特性3.10.1 事务操作数据库的四大特性(ACID) 原子性 (Atomicity):就是事务的所包含的所有操作，要么全部成功，要么全部失败回滚。 一致性 (Consistency):简单来说就是在事务执行前和执行后，必须保持数据的一致。 隔离性 (Isolation):一个事务执行的过程当中，不能被其他的事务干扰。 比如有事务A和事务B，相对于A来说，B想要执行，要么在我执行之前执行，要么在我执行完毕之后，你再开始执行. 持久性 (Durability):事务被提交之后，他就被永久的存储到了数据库当中. 3.10.2 不考虑事务的隔离性所引发的问题 脏读:一个事务读取到了一个未提交的事务的数据。 不可重复读:在读取数据库的某条数据的时候返回了不同的值，造成这个结果的原因是因为我们在查询了一次之后准备进行第二次查询的这个间隔之间，对我们要进行查询的这条数据进行了修改操作，从而导致两次读取的数据不一致。 脏读和不可重复读的区别:脏读是一个事务读取到了一个未提交事务的脏数据，而不可重复读是一个数据读取了一个已经提交了的事务的数据。 虚读(幻读)出现幻读不是对一条数据的操作而产生的问题，而是操作多条数据产生的问题，例如：事务A想要对一张表中的某一字段的值进行修改，假设有一个字段的值全部为1，事务A现在想要将1全部修改为2，在提交事务之后，事务B接着又进行了一个操作，在这张表中添加了一个字段，值全部为1。那么这时候操作事务A的用户在查看的时候，会发现还有一行数据没有进行修改，其实这是事务B在他查看之前添加的。 幻读和不可重复读都是读取了一个已经提交的事务，而脏读是读取了一个未提交的事务。不同的是不可重复读查询的是同一条数据，而虚读查询的是批量数据。 3.11 事务的四种隔离级别 Serializable (序列化)：可避免脏读、不可重读读、幻读的发生 Repeatable-read (可重复读)：可避免脏读、不可重复读的发生。 Read-committed (读已提交)：可避免脏读的发生。 Read-uncommitted (读未提交)：最低级别，任何情况都无法保证。以上四种的隔离级别最高的Serializable，最低的是Read uncommitted，级别越高，虽然安全级别越高，但是执行的效率就越低，MySQL中默认的隔离级别是:Repeatable read(可重复读)，oracle默认的隔离级别是：Read committed(读已提交)。 这里需要注意的是，mysql支持以上四种隔离级别，但是oracle只支持Serializable(串行化)和Read committed(读已提交)这两种隔离级别。 MySQL中查看当前的事务隔离界别select @@tx_isolation 设置mysql的隔离级别set tx_isolation=&#39;read-uncommitted&#39; 记住:设置数据库的隔离级别一定要是在开启事务之前！ 隔离级别的设置只对当前的链接有效。对于MySQL窗口来说，一个窗口就是一个链接，当前设置的事务隔离级别只对当前的窗口有效。 3.12 CHAR和VARCHAR的区别3.12.1 存储方式 当值存储在CHAR字段中时，剩余的字符将用空格填充; 例如，一个字段是 name char(5)，并且您要存储只是”tom”，则实际值将存储为”tom “ 与CHAR不同，VARCHAR只占用基于存储的数据的空间 varchar类型的实际长度是它的值的实际长度+1，这一个(也可能是两)字节用于保存实际使用了多大的长度 char的存储方式是：英文字符占1个字节，汉字占用2个字节；varchar的存储方式是：英文和汉字都占用2个字节，两者的存储数据都非unicode的字符数据 3.12.2 数据检索 如果CHAR字段的数据较短时，会经过空格填充，所以查询出来的结果需删除尾随空格。 3.12.3 存储上限 char(n)，n最大255。 varchar(n)，n最大65535，另外，按照字符集，不能超过65525字节。这65535字节不能全用来存数据，因为有1-2字节要用来存占用长度，255字节以下用1字节存储长度，255字节以上用2字节存储长度。 text，上限65535字节，再多也能存，因为还有mediumtext上限2^24-3字节大概16m，longtext上限2^32-4字节大概4G。 3.12.4 性能对比 按照查询速度： char最快， varchar次之，text最慢 char，定长，基本没有碎片，索引速度极快。 varchar，不定长，索引速度没有char快。理论上可以添加全部索引，但是数据长度太大时索引也会截取数据前面的一部分。 text，不定长，速度慢，索引只能是前缀索引。 3.12.5 不同存储引擎对 CHAR 和 VARCHAR 的使用 MyISAM 存储引擎:建议使用固定长度的数据列代替可变长度的数据列。 MEMORY 存储引擎:目前都使用固定长度的数据行存储，因此无论使用 CHAR 或 VARCHAR 列都没有关系。两者都是作为 CHAR 类型处理。 InnoDB 存储引擎:建议使用 VARCHAR 类型。对于 InnoDB 数据表，内部的行存储格式没有区分固定长度和可变长度列(所有数据行都使用指向数据列值的头指针)，因此在 本质上，使用固定长度的 CHAR 列不一定比使用可变长度 VARCHAR 列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于 CHAR 平均占用的空间多于 VARCHAR，因此使 用 VARCHAR 来最小化需要处理的数据行的存储总量和磁盘 I/O 是比较好的。 3.13 NOW() 和CURRENT_DATE() 有什么区别 NOW() 命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE() 仅显示当前年份，月份和日期。 3.14 BLOB和TEXT有什么区别 二者之间的主要差别是 BLOB 能用来保存二进制数据（比如照片），而TEXT只能保存字符数据 TEXT值是大小写不敏感的 BLOB值进行排序和比较时区分大小写 3.15 如何理解超键、候选键、主键、外键 主键(Primary Key)：对数据库表中的每一行数据进行唯一标识。 任意两行的主键值都不同 包含主键值的列从不修改或更新 主键值不能重用 使用PRIMARY KEY进行标识 外键(foreign key)：是表中的一列，其值必须在另一个表的主键中。 超键(Super Key)：在关系中能惟一标识元组(数据库中的一条记录)的属性集称为关系模式的超键。 比如一张学生信息表，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。 候选键(Candidate Key)：不含有多余属性的超键称为候选键。也就是在候选键中，若要再删除属性，就不能唯一标识元组了。 如：学生表中的候选键为：（学号）、（身份证号）。 3.16 什么是存储过程？存储过程是一些预编译的SQL语句。 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全。 3.17 什么是视图？以及视图的使用场景有哪些？ 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异 3.18 数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁: 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁: 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 3.19 什么是触发器，MySQL中都有哪些触发器？触发器是指一段代码，当触发某个事件时，自动执行这些代码。在MySQL数据库中有如下六种触发器: Before Insert After Insert Before Update After Update Before Delete After Delete 4、缓存4.1 Memcache和Redis区别 数据类型：都是k/v数据库，但memcache只支持string，redis除了string，还支持list，set，hash等数据 持久化：memcache不支持内存持久化，redis支持。 内存管理：memcache内存用完时，会删除用得最少的缓存；redis内存用完时，会把最少的缓存交换到磁盘里。 4.2 如何提高memcache的缓存命中率 合理组合缓存 Key，保证Key最大复用率。 合理设置过期时间，减少因为缓存数据过期后被穿透 5、服务器5.1 Apache与Nginx的优缺点比较1、nginx相对于apache的优点：轻量级，比apache 占用更少的内存及资源。高度模块化的设计，编写模块相对简单抗并发，nginx处理请求是异步非阻塞，多个连接（万级别）可以对应一个进程，而apache 则是阻塞型的，是同步多进程模型，一个连接对应一个进程，在高并发下nginx 能保持低资源低消耗高性能。nginx处理静态文件好，Nginx 静态处理性能比 Apache 高 3倍以上2、apache 相对于nginx 的优点：apache 的rewrite 比nginx 的rewrite 强大 ，模块非常多，基本想到的都可以找到 ，比较稳定，少bug ，nginx的bug相对较多3：Nginx比Apache快的原因：这得益于Nginx使用了最新的epoll（Linux 2.6内核）和kqueue（freebsd）网络I/O模型，而Apache则使用的是传统的select模型。 目前Linux下能够承受高并发访问的 Squid、Memcached都采用的是epoll网络I/O模型。 处理大量的连接的读写，Apache所采用的select网络I/O模型非常低效。 5.2 fastcgi、cgi、php-fpm fastcgi和cgi的区别在web服务器方面在对数据进行处理的进程方面:a. cgi fork一个新的进程进行处理读取参数，处理数据，然后就结束生命期。b. fastcgi 用tcp方式跟远程机子上的进程或本地进程建立连接要开启tcp端口，进入循环，等待数据的到来，处理数据。 php-fpm的作用那PHP-FPM又是什么呢？它是一个实现了Fastcgi协议的程序,用来管理Fastcgi起的进程的,即能够调度php-cgi进程的程序。现已在PHP内核中就集成了PHP-FPM，使用--enalbe-fpm这个编译参数即可。另外，修改了php.ini配置文件后，没办法平滑重启，需要重启php-fpm才可。此时新fork的worker会用新的配置，已经存在的worker继续处理完手上的活 举个例子: 服务端现在有个10万个字单词， 客户每次会发来一个字符串，问以这个字符串为前缀的单词有多少个。 那么可以写一个程序，这个程序会建一棵trie树，然后每次用户请求过来时可以直接到这个trie去查找。 但是如果以cgi的方式的话，这次请求结束后这课trie也就没了，等下次再启动该进程时，又要新建一棵trie树，这样的效率就太低下了。 而用fastcgi的方式的话，这课trie树在进程启动时建立，以后就可以直接在trie树上查询指定的前缀了 5.3 为什么使用独立文件服务器？ 从服务器本身来说，单台的话会加大机器IO负载,多台(负载均衡)的话涉及到文件同步的问题 浏览器对一个域名下的并发是有数量限制的，独立域名的文件服务器会加快响应 防止域名污染，请求图片的时候是不用带上cookie 6、算法6.1 写一个函数，算出两个文件的相对路径 function countOppose(){ $arr1 = explode(&#39;/&#39;, $pathA); $arr2 = explode(&#39;/&#39;, $pathB); // 获取相同路径的部分 $intersection = array_intersect_assoc($arr1, $arr2); $depth =count($intersection); // 将path2的/ 转为 ../，path1获取后面的部分，然后合拼 // 计算前缀 if (count($arr2) - $depth - 1 &gt; 0) { $prefix = array_fill(0, count($arr2) - $depth - 1, &#39;..&#39;); } else { $prefix = array(&#39;.&#39;); } $tmp = array_merge($prefix, array_slice($arr1, $depth)); $relativePath = implode(&#39;/&#39;, $tmp); return $relativePath; } 6.2 php排序算法汇总6.3 遍历一个文件夹下的所有文件和子文件夹 function childForDir($dir) { $files = []; if (!is_dir($dir)) { return $dir; } $handle = opendir($dir); if (!$handle) { return false; } //取出.和.. readdir($handle); readdir($handle); //遍历剩余的文件和目录 while ($file = readdir($handle)) { if (is_dir($file)) { $files[$file] = $this-&gt;childForDir($file); } else { $files[] = $dir . &#39;/&#39; . $file; } } closedir($handle); return $files; } 6.4 猴子选大王 一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。 &lt;?php function monkeyKingNum($allNum, $m){ $arr = range(1,$allNum); $num = 1; while(count($arr) &gt; 1){ foreach ($arr as $key =&gt; $value) { if($num == $m){ unset($arr[$key]); $num = 1; }else{ $num++; } } } $monkeyKingNum = array_values($arr)[0]; return $monkeyKingNum; } monkeyKingNum(10,10); 6.5 二分查找二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好;其缺点是要求待查表为有序表，且插入删除困难。 因此，折半查找方法适用于不经常变动而查找频繁的有序列表。 &lt;?php /** * @param $data //待查找的元素数组 * @param $min //开始元素的下标 * @param $max //结束元素的下标 * @param $k //待查找的元素 * @return bool */ function binarySearch($data,$min,$max,$k){ if ($min &lt;= $max){ //计算中间的元素下标 $mid = intval(($min +$max)/2); if ($data[$mid] == $k){ //如果相等,则找到 return $mid; } else if ($k &lt; $data[$mid]){ //元素下标在前面一部分 return binarySearch($data, $min, $mid-1, $k); } else { //元素下标在后面一部分 return binarySearch($data, $mid+1, $max, $k); } } return false; } 7、设计模式7.1单例模式（三私一公） 单例模式的用途,是对系统资源的节省, 可以避免重复实例化,而PHP每次执行完都会从内存中清理掉所有的资源. 因而PHP中的单例实际每次运行都是需要重新实例化的, 这样就失去了单例重复实例化的意义了. 单单从这个方面来说, PHP的单例的确有点让各位失望. 但是php的应用主要在于数据库应用, 所以一个应用中会存在大量的数据库操作, 在使用面向对象的方式开发时(废话), 如果使用单例模式, 则可以避免大量的new 操作消耗的资源。 class Test{ //私有化后在类内部保存对象并且防止外部访问到 private static $obj=null; //私有化后防止在外部创建新的对象 private function __construct() { } //公有并且静态方法在类外面可以通过类名直接访问 public static function getInstance(){ if(self::$obj==null) self::$obj=new self(); return self::$obj; } //私有化克隆执行的方法,防止在外部被克隆 private function __clone(){ } } 7.2工厂模式工厂模式具体可分为四类：简单工厂，工厂方法，抽象工厂、静态工厂； 简单工厂模式:静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同,返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。。 示例代码： &lt;?php //简单工厂模式 class Cat { function __construct() { echo &quot;I am Cat class &lt;br&gt;&quot;; } } class Dog { function __construct() { echo &quot;I am Dog class &lt;br&gt;&quot;; } } class Factory { public static function CreateAnimal($name){ if ($name == &#39;cat&#39;) { return new Cat(); } elseif ($name == &#39;dog&#39;) { return new Dog(); } } } $cat = Factory::CreateAnimal(&#39;cat&#39;); $dog = Factory::CreateAnimal(&#39;dog&#39;); ?&gt; IUser 接口定义用户对象应执行什么操作。IUser 的实现称为 User，UserFactory 工厂类则创建 IUser 对象 工厂方法，查看详情 抽象工厂，查看详情 静态工厂，查看详情 7.3 建造者模式（生成器模式）又名：生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。例如，一辆汽车由轮子，发动机以及其他零件组成，对于普通人而言，我们使用的只是一辆完整的车，这时，我们需要加入一个构造者，让他帮我们把这些组件按序组装成为一辆完整的车 Builder：抽象构造者类，为创建一个Product对象的各个部件指定抽象接口。 ConcreteBuilder：具体构造者类，实现Builder的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示。提供一个检索产品的接口 Director：指挥者，构造一个使用Builder接口的对象。 Product：表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。 示例代码： &lt;?php abstract class Builder { protected $car; abstract public function buildPartA(); abstract public function buildPartB(); abstract public function buildPartC(); abstract public function getResult(); } class CarBuilder extends Builder { function __construct() { $this-&gt;car = new Car(); } public function buildPartA(){ $this-&gt;car-&gt;setPartA(&#39;发动机&#39;); } public function buildPartB(){ $this-&gt;car-&gt;setPartB(&#39;轮子&#39;); } public function buildPartC(){ $this-&gt;car-&gt;setPartC(&#39;其他零件&#39;); } public function getResult(){ return $this-&gt;car; } } class Car { protected $partA; protected $partB; protected $partC; public function setPartA($str){ $this-&gt;partA = $str; } public function setPartB($str){ $this-&gt;partB = $str; } public function setPartC($str){ $this-&gt;partC = $str; } public function show() { echo &quot;这辆车由：&quot;.$this-&gt;partA.&#39;,&#39;.$this-&gt;partB.&#39;,和&#39;.$this-&gt;partC.&#39;组成&#39;; } } class Director { public $myBuilder; public function startBuild() { $this-&gt;myBuilder-&gt;buildPartA(); $this-&gt;myBuilder-&gt;buildPartB(); $this-&gt;myBuilder-&gt;buildPartC(); return $this-&gt;myBuilder-&gt;getResult(); } public function setBuilder(Builder $builder) { $this-&gt;myBuilder = $builder; } } $carBuilder = new CarBuilder(); $director = new Director(); $director-&gt;setBuilder($carBuilder); $newCar = $director-&gt;startBuild(); $newCar-&gt;show(); 8、数据结构8.1 堆、栈、队列的区别 堆堆中主要存放用new构造的对象和数组优势：可以动态的分配内存的大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的。缺点：由于要在运行时动态分配内存，存取速度比较慢 栈栈中主要存放一些基本类型的变量和对象引用类型。优势：存取速度比较快，仅次于寄存器，栈数据可以共享。缺点：栈中的数据大小和生存周期必须是确定的，缺乏灵活性。 队列设计程序中常用的一种数据结构，采用”先进先出”的存储结构，类似于队列。数据元素只能从队尾进入，从队首取出。在此队列中，数据元素可以随意增减，但是数据元素的次序不会更改。每次都是取出队首的元素，后面的元素会整体向前移动一位。队列遍历数据的速度要快的多 8.2 什么是哈希表？哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希表hashtable(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位 附加1、扩展1. 写个函数来解决多线程同时写一个文件的问题。function write(){ //打开文件 $file = fopen(&#39;flock.text&#39;,&#39;w+&#39;); if(!$file){ return &#39;the file not exist!&#39;; } //获取锁 if (flock(file,LOCK_EX)){ //todo fwrite(file,&#39;do some things&#39;); //释放锁 flock(file,LOCK_UN); } else { return &#39;the file is write...&#39;; } //关闭文件 fclose(file); } 2. 什么是写时复制 写时复制（Copy on Write，也缩写为COW)的应用场景非常多， 比如Linux中对进程复制中内存使用的优化，在各种编程语言中，如C++的STL等等中均有类似的应用。 COW是常用的优化手段，可以归类于：资源延迟分配。只有在真正需要使用资源时才占用资源， 写时复制通常能减少资源的占用。 在开始之前，我们可以先看一段简单的代码： &lt;?php //例一 $foo = 1; $bar = $foo; echo $foo + $bar; ?&gt; 执行这段代码，会打印出数字2。从内存的角度来分析一下这段代码”可能”是这样执行的： 分配一块内存给foo变量，里面存储一个1； 再分配一块内存给bar变量，也存一个1，最后计算出结果输出。 事实上，我们发现foo和bar变量因为值相同，完全可以使用同一块内存，这样，内存的使用就节省了一个1， 并且，还省去了分配内存和管理内存地址的计算开销。 没错，很多涉及到内存管理的系统，都实现了这种相同值共享内存的策略：写时复制 详情参考 3. echo (int) ( (0.1+0.7) * 10 ); 输出是多少？为什么?输出的结果为：7 关于浮点数精度的警告 显然简单的十进制分数如同 0.1 或 0.7 不能在不丢失一点点精度的情况下转换为内部二进制的格式，这就会造成混乱的结果。例如，floor((0.1+0.7)*10) 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9。 注意：永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等 附加2、面试题链接 https://github.com/hookover/php-engineer-interview-questions https://www.kancloud.cn/pingfan_/php_interview/916716 https://www.kancloud.cn/i281151/php_questions/174233 https://www.kancloud.cn/tp5girl/interview/329075 https://github.com/wudi/PHP-Interview-Best-Practices-in-China https://my.oschina.net/anyeshe/blog/1550238 https://www.jianshu.com/p/ac5cad6d64a8 https://www.zhaoyafei.cn/content.html?id=150846575347 https://www.cnblogs.com/zyf-zhaoyafei/p/4828358.html https://segmentfault.com/a/1190000010262869#articleHeader9]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则使用]]></title>
    <url>%2F2017%2F06%2F27%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[匹配语法规则 特殊字符 限定符 匹配组 正则表达式中/i,/g,/ig,/gi,/m的区别和含义/i (忽略大小写) /g (全文查找出现的所有匹配字符) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 应用实例 匹配两个字符串A与B中间的字符串包含A与B：表达式: A.*?B 示例: Abaidu.comB 结果: Awww.apizl.comB 匹配两个字符串A与B中间的字符串包含A但是不包含B：表达式: A.*?(?=B) 示例: Awww.apizl.comB 结果: Awww.apizl.com 匹配两个字符串A与B中间的字符串且不包含A与B：表达式: (?&lt;=A).*?(?=B) 示例: Awww.baidu.comB 结果: www.baidu.com 校验数字的表达式 1. 数字：^[0-9]*$ 2. n位的数字：^\d{n}$ 3. 至少n位的数字：^\d{n,}$ 4. m-n位的数字：^\d{m,n}$ 5. 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 12. 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符的表达式1.汉字：^[\u4e00-\u9fa5]{0,}$ 2.英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3.长度为3-20的所有字符：^.{3,20}$ 4.由26个英文字母组成的字符串：^[A-Za-z]+$ 5.由26个大写英文字母组成的字符串：^[A-Z]+$ 6.由26个小写英文字母组成的字符串：^[a-z]+$ 7.由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8.由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 9.中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 10.中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 11.可以输入含有^%&amp;&#39;,;=?$\&quot;等字符：[^%&amp;&#39;,;=?$\x22]+ 12.禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 4. 手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d{9}$) 5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 7. 18位身份证号码(数字、字母x结尾)：^((\d{18})|([0-9x]{18})|([0-9X]{18}))$ 8. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 9. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 10. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 11. 日期格式：^\d{4}-\d{1,2}-\d{1,2} 12. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 13. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14. 钱的输入格式： 15. 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 16. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19. 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]{2})?$ 20. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 21. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 22. 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 23. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 25. 中文字符的正则表达式：[\u4e00-\u9fa5] 26. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 27. 空白行的正则表达式：\n\s*\r (可以用来删除空白行) 28. HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 29. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 31. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 32. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 33. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) (由@飞龙三少 提供,感谢共享) 所有的超链接的href和链接文字 &lt;a.+?href=\&quot;(.+?)\&quot;.*&gt;(.+)&lt;/a&gt; 单独href ： &lt;a.+?href=\&quot;(.+?)\&quot;.*&gt; 单独连接文字：&gt;(.+)&lt;/a&gt;]]></content>
      <categories>
        <category>正则表达</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git-批量上线脚本]]></title>
    <url>%2F2017%2F05%2F21%2Fgit%E6%89%B9%E9%87%8F%E4%B8%8A%E7%BA%BF%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[online.sh上线执行的脚本 #!/bin/sh pssh -h ./demo.list -l root -P &quot;cd /xxx/xxx/demo &amp;&amp; git pull&quot; demo.list该文件下指的是上线哪些服务器的列表 root@xxxx.xx.xx.01 root@xxxx.xx.xx.02 root@xxxx.xx.xx.03 root@xxxx.xx.xx.04]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx-反向代理]]></title>
    <url>%2F2017%2F04%2F17%2FNginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[关键词匹配location ~ ^/TEST/ { rewrite /TEST/(.*)$ /$1 break; proxy_next_upstream http_502 http_504 error timeout invalid_header; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://ip:port; expires 3d; } 域名转发server { listen 80; server_name 域名; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://ip:port; } } 转发到多台upstream baidunode { server xxx:port weight=10 max_fails=3 fail_timeout=30s; server xxx:port weight=10 max_fails=3 fail_timeout=30s; } location / { add_header Cache-Control no-cache; proxy_set_header Host local.baidu.com; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://baidunode; proxy_connect_timeout 30s; }]]></content>
      <categories>
        <category>服务使用</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Linux docker 搭建禅道]]></title>
    <url>%2F2017%2F01%2F14%2FLinux-docker-chandao%2F</url>
    <content type="text"><![CDATA[一、下载地址禅道开源版(点击下载) 默认配置信息: 数据库 用户名：root 默认密码： 123456。 # 运行时，可以设置 MYSQL_ROOT_PASSWORD变量来更改密码。 可挂载目录 /app/zentaopms:该目录为禅道目录，里面包含禅道代码及附件上传目录。 /var/lib/mysql:该目录为数据库的数据目录。 二、安装使用注意：需要关闭下selinux 1、构建镜像 下载安装包，解压缩。 进入docker_zentao目录，执行命令 docker build -t [镜像名称] [Dockerfile所在目录] docker build -t zentao ./ 2、运行镜像 docker run --name [容器名称] -p [主机端口]:80 -v [主机代码目录]:/app/zentaopms -v [主机数据目录]:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=[数据库密码] -d [镜像名]:latest 例如创建 /data/www /data/data 目录。 执行命令： docker run --name zentao -p 80:80 -v /data/www:/app/zentaopms -v /data/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d zentao:latest 运行成功 3、安装禅道 浏览器访问 http://ip，显示禅道安装页面，安装禅道。 原文参考]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-相关的问题]]></title>
    <url>%2F2016%2F11%2F23%2Fquestion-for-git%2F</url>
    <content type="text"><![CDATA[Q1 解决git pull/push每次都需要输入密码问题解决办法: 进入你的项目目录，输入： git config --global credential.helper store Q2 git无法pull仓库refusing to merge unrelated histories解决方法: git pull origin master --allow-unrelated-histories Q3 error: cannot lock ref refs/remotes/origin..报错: error: cannot lock ref &#39;refs/remotes/origin/分支名&#39;: ref refs/remotes/origin/分支名... is at 19070aed6873f8d58f35e4631272b59f13927a1c but expected 8a5b3bda0778070bd6b92123556475c9484e04b8 解决方法: # rm .git/refs/remotes/origin/分支名 # git fetch Q4 warning: 远程 HEAD 指向一个不存在的引用，无法检出解决方法： 原因是.git目录下.git/refs/heads不存在HEAD指向的文件，这个时候可以用git show-ref命令查看 获得如下打印： 5fa0b60252ca2c10fa3c2e12780d351c047c802d refs/remotes/origin/branch_qc_origin 5fa0b60252ca2c10fa3c2e12780d351c047c802d refs/tags/XXXXXXXXXXXX 48dee3a5f7b9cac98349e949275c652e02b0b67e refs/tags/PXXXXV0.0.0B01-bringup 505a9bb0c6d815e6db561f7cb7ed0e20cd73ddde refs/tags/PXXXX_02550_201309260427 e2b211a3c9d8dabec9fe1018b4f7db5c953832ea refs/tags/PXXXX_bsp_02550_201309260422 0848e8b7922c78dbb364aa0e7c1b8375d16a70a3 refs/tags/branch_PXXXX_02550_201309190102 7384803be7c8866393b96ebaaa7e1b2b119654e7 refs/tags/branch_PXXXX_02550_201309200102 480f444dd26bb238aeaacf15da748ad861ea9378 refs/tags/branch_PXXXX_02550_201309210102 …… 可以看出，全部是标签tag，并没有类似refs/head/branch_name 继续执行命令： git branch //输入出空 git branch -a //输出 remotes/origin/branch_qc_origin git checkout remotes/origin/branch_qc_origin // ① checkout的是git branch -a输出的内容 这样通过ll命令查看，Contacts代码下载到工作目录了 接着创建分支： git checkout -b remotes/origin/branch_qc_origin // ② 创建分支 git branch //可以看到输出*remotes/origin/branch_qc_origin了，不再为空 git branch -m remotes/origin/branch_qc_origin master // ③ 重命名分支叫master git show-ref命令查看也能看到head了 至此，问题得到解决。 Q5 gitLab:[remote rejected] master -&gt; master (pre-receive hook declined)原因: 项目中对应的分支，设置成了已保护，无法push ssh克隆下的地址有问题，具体什么问题还不清楚，对应的方案使用http 报错: remote: GitLab: You are not allowed to push code to protected branches on this project. To ssh://git.xxx.com:22138/ms-group/mm-test.git ! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to &#39;ssh://git@git.xxx.com:22138/ms-group/mm-test.git&#39; 解决方法： 第一步:查看gitlab中对应的项目是否设置保护分支; 第二步: 上面确认设置后，依旧报错，改用下面方法 Q6 git add后只增加了文件夹，但是没有文件。使用git status查看，没有任何提交，后手动删除重新copy了文件，再次使用git status： modified: vendor/phpgangsta/googleauthenticator/PHPGangsta/GoogleAuthenticator.php (modified content) git add后只增加了文件夹，但是没有文件。手动Add: git vendor/phpgangsta/googleauthenticator/PHPGangsta/GoogleAuthenticator.php 报出错误信息： fatal: Pathspec &#39;xxx&#39; is in submodule 解决方法: 发现vendor/phpgangsta/googleauthenticator/PHPGangsta/下 有.git文件 所以使用下面命令： git rm -rf --cached vendor/phpgangsta/googleauthenticator/PHPGangsta git add vendor/phpgangsta/* 然后正常提交。]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写时复制]]></title>
    <url>%2F2016%2F10%2F20%2F%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[写时复制 写时复制（Copy on Write，也缩写为COW)的应用场景非常多， 比如Linux中对进程复制中内存使用的优化，在各种编程语言中，如C++的STL等等中均有类似的应用。 COW是常用的优化手段，可以归类于：资源延迟分配。只有在真正需要使用资源时才占用资源， 写时复制通常能减少资源的占用。 在开始之前，我们可以先看一段简单的代码： &lt;?php //例一 $foo = 1; $bar = $foo; echo $foo + $bar; ?&gt; 执行这段代码，会打印出数字2。从内存的角度来分析一下这段代码“可能”是这样执行的： 分配一块内存给foo变量，里面存储一个1； 再分配一块内存给bar变量，也存一个1，最后计算出结果输出。 事实上，我们发现foo和bar变量因为值相同，完全可以使用同一块内存，这样，内存的使用就节省了一个1， 并且，还省去了分配内存和管理内存地址的计算开销。 没错，很多涉及到内存管理的系统，都实现了这种相同值共享内存的策略：写时复制 详情参考]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPS/QPS/PV/UV]]></title>
    <url>%2F2016%2F08%2F16%2F%E8%A1%8C%E4%B8%9A%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[TPS Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS） TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。 QPS 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。 对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 PV (page view) - 页面浏览量或点击量 页面浏览量或点击量，是衡量一个网站或网页用户访问量。具体的说，PV值就是所有访问者在24小时（0点到24点）内看了某个网站多少个页面或某个网页多少次。PV是指页面刷新的次数，每一次页面刷新，就算做一次PV流量 UV (unique visitor)- 独立访客数 指访问某个站点或点击某个网页的不同IP地址的人数。在同一天内，UV只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。UV提供了一定时间内不同观众数量的统计指标，而没有反应出网站的全面活动 什么是QPS，TPS，吞吐量]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他术语]]></title>
    <url>%2F2016%2F08%2F15%2F%E5%85%B6%E4%BB%96%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[盗链盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面(如广告)，直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。 内存溢出(out of memory)指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露(memory leak)指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 内存泄露会最终会导致内存溢出]]></content>
      <categories>
        <category>行业术语</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务-RabbitMQ安装方法总结]]></title>
    <url>%2F2016%2F08%2F03%2Frabbit-mq-install%2F</url>
    <content type="text"><![CDATA[具体安装如下： 一：安装Erlang： # rpm --import http://binaries.erlang-solutions.com/debian/erlang_solutions.asc # cd /etc/yum.repos.d/ # wget http://binaries.erlang-solutions.com/rpm/centos/erlang_solutions.repo # yum install esl-erlang 二：安装esl-erlang-compat：# cd /tmp/ # wget https://raw.github.com/jasonmcintosh/esl-erlang-compat/master/rpmbuild/RPMS/noarch/esl-erlang-compat-R14B-1.el6.noarch.rpm # yum install esl-erlang-compat-R14B-1.el6.noarch.rpm 三：安装RabbitMQ # cd /tmp # wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.2/rabbitmq-server-3.6.2-1.noarch.rpm # yum install rabbitmq-server-3.6.2-1.noarch.rpm 到此，RabbitMQ基本安装完成了。 四：RabbitMQ页面监控系统RabbitMQ提供了一个web的监控页面系统，这个系统是以Plugin的方式进行调用的。在Documentation下的Server下的Management是关于配置这个插件的。地址：http://www.rabbitmq.com/management.html这个管理插件是包含在RabbitMQ发行包里的，所以只需激活即可。 命令： # rabbitmq-plugins enable rabbitmq_management 五：配置登陆用户# rabbitmqctl add_user leyue leyue100 # rabbitmqctl set_user_tags leyue administrator # rabbitmqctl set_permissions -p / leyue &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 浏览器地址栏输入：http://localhost:15672 用户名登陆 RabbitMQ服务启动、关闭、重启 # service rabbitmq-server start //开启 # service rabbitmq-server stop //关闭 #service rabbitmq-server restart //重启]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http-头部属性]]></title>
    <url>%2F2016%2F07%2F23%2Fhttp%E5%A4%B4%E9%83%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives... TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http-状态码]]></title>
    <url>%2F2016%2F07%2F14%2Fhttp%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[2开头 （请求成功）表示成功处理了请求的状态代码。200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务-记在Linux中搭建nfs文件共享的一次经历]]></title>
    <url>%2F2016%2F04%2F19%2Fnfs-file-sharing%2F</url>
    <content type="text"><![CDATA[1.服务器节点介绍1.1 服务节点主机名: server.hui.local IP地址: 192.168.1.101/24 1.2 客户端节点主机名: client.hui.local IP地址: 192.168.1.102/24 2. 服务节点部署2.1 安装NFS相关软件包# yum install nfs-utils nfs-utils-lib # systemctl enable rpcbind # systemctl enable nfs-server # systemctl enable nfs-lock # ystemctl enable nfs-idmap # systemctl start rpcbind # systemctl start nfs-server # systemctl start nfs-lock # systemctl start nfs-idmap 2.2. 创建共享目录在服务器中创建名为/var/share的共享目录，让客户端用户读取和写入该目录中的文件 # mkdir /var/share # chmod 777 /var/share 2.3 导出共享目录在NFS服务器上导出共享目录：编辑文件/etc/exports，修改如下: # /var/share/ 192.168.1.0/24(rw,sync,no_root_squash,no_all_squash） 代码说明: /var/share - 共享目录 192.168.1.0/24 - 客户端的IP地址范围 rw - 共享文件夹同步的可写权限 sync - 同步共享目录 no_root_squash - 启用root权限 no_all_squash - 启用用户权限 2.4 重启NFS服务# systemctl restart nfs-server 3.客户端节点部署3.1 安装NFS相关软件包# yum install nfs-utils nfs-utils-lib 3.2 启用并启动NFS服务# systemctl enable rpcbind # systemctl enable nfs-server # systemctl enable nfs-lock # systemctl enable nfs-idmap # systemctl start rpcbind # systemctl start nfs-server # systemctl start nfs-lock # systemctl start nfs-idmap 3.3 挂载NFS共享创建一个挂载点以挂载我们之前在服务节点中创建的共享文件夹 ‘/var/share’ # mkdir /var/nfs_share # mount -t nfs 192.168.1.101：/var/share /var/nfs_share 3.4 卸载NFS共享卸载: # umount /var/nfs_share 强制卸载: # umount -lf /var/nfs_share 4. 注意事项 服务端节点应做文件备份，如果客户端把文件误删除，则服务端对应的文件也会丢失。]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务-定时任务(crontab)使用总结]]></title>
    <url>%2F2015%2F10%2F03%2Fcrontab-run-error-time%2F</url>
    <content type="text"><![CDATA[1.crontab格式 1.1 示例# 每10分钟,运行一次命令 */10 * * * * command # 每一小时,运行一次命令 * */1 * * * command # 每天晚上的21:30,运行一次命令 30 21 * * * command # 每天18:00至22:00之间每隔30分钟,运行一次命令 0,30 18-22 * * * command # 在23:00~07:00之间,运行一次命令 * 23-7/1 * * * command # 每个工作日(周一 ~ 周五)晚上21:30,运行一次命令 30 21 * * 1-5 command # 每星期六的23:00,运行一次命令 0 23 * * 6 command # 每周六、周日的 2:30,运行一次命令 30 2 * * 6,0 /usr/local/etc/rc.d/lighttpd restart # 每个月的第一天早上08:10,运行一次命令 10 8 1 * * command # 每个月1、10、22日的5:00,运行一次命令 0 5 1,10,22 * * command 2.踩坑点2.1 在/var/log/ 没有cron日志文件处理方法: # yum install rsyslog 2.2 没有按时执行处理方法: 修改时区 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 重启服务 # service crond restart # service rsyslog restart 3.在线生成定时任务点击,去生成]]></content>
      <categories>
        <category>入坑历史</category>
      </categories>
      <tags>
        <tag>crond</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos-在Centos7中使用防火墙]]></title>
    <url>%2F2015%2F08%2F17%2Fclose-firewalld%2F</url>
    <content type="text"><![CDATA[1.查看火墙1.1 使用:firewall-cmdfirewall-cmd --state 1.2 使用:systemctl[root@vpn01 ~]# systemctl status firewalld.service ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) 2.关闭火墙2.1 第一步:关闭firewalldsystemctl stop firewalld.service 2.2 第二步:禁止firewalld开机启动systemctl disable firewalld.service 2.3 第三步:禁用selinux什么是SELinux? 1.临时禁用 [root@vpn02 ~]# setenforce 0 2.永久关闭:修改/etc/selinux/config文件中设置SELINUX=disabled [root@vpn02 ~]# cat /etc/selinux/config # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=disabled # 此处设置 # SELINUXTYPE= can take one of three values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted 3.查看selinux状态 [root@vpn02 ~]# sestatus SELinux status: disabled]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令-ls]]></title>
    <url>%2F2015%2F08%2F13%2Fls%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.使用语法ls（选项）（参数） 2.参数说明-a 列出目录下的所有文件，包括以 . 开头的隐含文件。 -A 显示除 “.”和“..”外的所有文件 -b 把文件名中不可输出的字符用反斜杠加字符编号的形式列出。 -B 不输出以 “~”结尾的备份文件。 -c 输出文件的 i 节点的修改时间，并以此排序。 -C 按列输出，纵向排序。 -d 将目录象文件一样显示，而不是显示其下的文件。 -e 该ls命令选项可以输出时间的全部信息，而不是输出简略信息。 -f -U 该ls命令选项可以对输出的文件不排序。 -i 该ls命令选项可以输出文件的 i 节点的索引信息。 -k 该ls命令选项可以以 k 字节的形式表示文件的大小。 -l 该ls命令选项可以列出文件的详细信息。 -m 该ls命令选项可以横向输出文件名，并以“，”作分格符。 -n 该ls命令选项可以用数字的GUID代替名称。 -o 该ls命令选项可以显示文件的除组信息外的详细信息。 -p -F 该ls命令选项可以在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。 -q 该ls命令选项可以用?代替不可输出的字符。 -r 该ls命令选项可以对目录反向排序。 -s 该ls命令选项可以在每个文件名后输出该文件的大小。 -t 该ls命令选项可以以时间排序。 -u 该ls命令选项可以以文件上次被访问的时间排序。 -x 该ls命令选项可以按列输出，横向排序。 -G 该ls命令选项可以输出文件的组的信息。 -L 该ls命令选项可以列出链接文件名而不是链接到的文件。 -N 该ls命令选项将不限制文件长度。 -Q 该ls命令选项可以把输出的文件名用双引号括起来。 -R 该ls命令选项可以列出所有子目录下的文件。 -S 该ls命令选项可以以文件大小排序。 -X 该ls命令选项可以以文件的扩展名(最后一个 . 后的字符)排序。 -1 该ls命令选项可以一行只输出一个文件。 3.使用示例3.1 排序 按照大小排序显示文件 ➜ ls -Slh total 4040 -rw-r--r-- 1 liuqh staff 596K 6 1 11:04 inviteheader.png -rw-r--r-- 1 liuqh staff 458K 6 1 11:04 rice_center.png -rw-r--r-- 1 liuqh staff 103K 5 21 21:53 pk-share.png -rw-rw-rw-@ 1 liuqh staff 97K 6 2 05:41 background_morning.png -rw-rw-rw-@ 1 liuqh staff 92K 6 2 05:41 background_night.png -rw-r--r-- 1 liuqh staff 91K 6 2 14:23 find_invite.png -rw-r--r-- 1 liuqh staff 85K 6 1 11:04 pk.png -rw-r--r-- 1 liuqh staff 83K 6 1 11:04 exchange.png -rwxr-xr-x 1 liuqh staff 72K 6 1 11:04 runner.png -rw-r--r-- 1 liuqh staff 67K 6 2 12:13 bottomBG.png -rw-r--r-- 1 liuqh staff 44K 6 1 11:04 fuceng.png -rw-r--r-- 1 liuqh staff 41K 4 23 19:49 title@2x.png -rw-r--r--@ 1 liuqh staff 38K 6 3 17:18 win-jifen.png -rw-r--r--@ 1 liuqh staff 37K 6 3 17:18 win-rice.png -rwxr-xr-x 1 liuqh staff 13K 4 9 11:00 Badge@2x.png -rwxr-xr-x 1 liuqh staff 8.0K 4 9 11:00 bg@2x.png ...]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令-scp]]></title>
    <url>%2F2015%2F07%2F26%2Fscp%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 简介scp是用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。 2. 使用2.1 命令格式scp [参数] [原路径] [目标路径] 2.2 参数说明-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 3. 使用示例3.1 下载目录scp -r username@servername:remote_dir/ /tmp/local_dir # 例如把服务器上/home/kimi/test，下载到本地 scp -r codinglog@192.168.0.101 /home/kimi/test /tmp/local_dir 3.2 上传目录scp -r /tmp/local_dir username@servername:remote_dir # 例如把当前目录下的test目录上传到服务器 scp -r test codinglog@192.168.0.101:/var/www/]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令-curl]]></title>
    <url>%2F2015%2F07%2F12%2Fcommand-curl%2F</url>
    <content type="text"><![CDATA[1. 表单提交1.1 GET数据提交$ curl https://cn.bing.com/search?q=go 1.2 POST数据提交 不设置header提交 curl -d &quot;user=admin&amp;passwd=12345678&quot; http://127.0.0.1:8080/login 设置header提交 curl -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;user&quot;: &quot;admin&quot;, &quot;passwd&quot;:&quot;12345678&quot;}&#39; http://127.0.0.1:8000/login 2.使用代理请求 linux curl命令可以使用下面参数设置http(s)代理、socks代理，已经设置它们的用户名、密码以及认证方式 参数 用法 -x host:port -x [protocol://[user:pwd@]host[:port]–proxy [protocol://[user:pwd@]host[:port] 使用HTTP代理访问；如果未指定端口，默认使用8080端口;protocol默认为http_proxy，其他可能的值包括：http_proxy、HTTPS_PROXY、socks4、socks4a、socks5；如：–proxy 8.8.8.8:8080；-x “http_proxy://aiezu:123@aiezu.com:80” –socks4 &lt;host[:port]&gt;–socks4a &lt;host[:port]&gt;–socks5 &lt;host[:port]&gt; 使用SOCKS4代理；使用SOCKS4A代理；使用SOCKS5代理；此参数会覆盖“-x”参数； –proxy-anyauth–proxy-basic–proxy-diges–proxy-negotiate–proxy-ntlm 代理认证方式，参考： –anyauth –basic –diges –negotiate –ntlm -U user:password –proxy-user user:password 设置代理的用户名和密码； 2.1 http/https代理1. 指定http代理IP和端口# 指定http代理IP和端口 curl -x 113.185.19.192:80 http://aiezu.com/test.php curl --proxy 113.185.19.192:80 http://aiezu.com/test.php 2.指定为http代理#指定为http代理 curl -x http_proxy://113.185.19.192:80 http://aiezu.com/test.php 3.指定为https代理curl -x HTTPS_PROXY://113.185.19.192:80 http://aiezu.com/test.php 4.指定代理用户名和密码，basic认证方式curl -x aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php curl -x 113.185.19.192:80 -U aiezu:123456 http://aiezu.com/test.php curl -x 113.185.19.192:80 --proxy-user aiezu:123456 http://aiezu.com/test.php 5.指定代理用户名和密码，ntlm认证方式#指定代理用户名和密码，ntlm认证方式 curl -x 113.185.19.192:80 -U aiezu:123456 --proxy-ntlm http://aiezu.com/test.php 6.指定代理协议、用户名和密码，basic认证方式curl -x http_proxy://aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php 2.2.socks代理：1. 使用socks4代理，无需认证方式curl --socks4 122.192.32.76:7280 http://aiezu.com/test.php curl -x socks4://122.192.32.76:7280 http://aiezu.com/test.php 2.使用socks4代理，无需认证方式curl --socks4a 122.192.32.76:7280 http://aiezu.com/test.php curl -x socks4a://122.192.32.76:7280 http://aiezu.com/test.php 3.使用socks5代理，basic认证方式curl --socks5 122.192.32.76:7280 -U aiezu:123456 http://aiezu.com/test.php curl -x socks5://aiezu:123456@122.192.32.76:7280 http://aiezu.com/test.php 4.使用socks5代理，basic认证方式，ntlm认证方式curl -x socks5://aiezu:123456@122.192.32.76:7280 --proxy-ntlm http://aiezu.com/test.php]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-正则去掉字符串中非汉字字符串]]></title>
    <url>%2F2015%2F03%2F09%2Fphp-preg_match_all%2F</url>
    <content type="text"><![CDATA[直接上代码示例： $str=&#39;2016，北京欢迎您 from around you..&#39;; preg_match_all(&#39;/[\x{4e00}-\x{9fff}]+/u&#39;, $str, $matches); $str = join(&#39;&#39;, $matches[0]); 输出 北京欢迎您]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
</search>
