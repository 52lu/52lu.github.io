---
title: RabbitMQ之消息类型
date: 2018-09-15 11:16:08
tags:
 - MQ
categories:
 - 消息队列
---


#### 1.简单队列

##### 1.模型图片
![](https://52lu.github.io/images/mq/simple-queue.jpg)

- P:消息的生产者 
- C:消息的消费者 
- 红色:队列


生产者将消息发送到队列，消费者从队列中获取消息。

##### 2.不足

<font color=red>耦合性高 生产消费一一对应(如果有多个消费者想都消费这个消息,就不行了) 队列名称变更时需要同时更改</font>

#### 2.工作队列(又称任务队列)

##### 1.模型图片
![](https://52lu.github.io/images/mq/work-queue.png)


##### 2.为什么会出现 work queues?

使用 simple队列(简单) 的时候
我们应用程序在是使用消息系统的时候,一般生产者P 生产消息是毫不费力的(发送消息即可),<font color=blue>而消费者接收完消息 后的需要处理,会耗费一定的时间,这时候,就有可能导致很多消息堆积在队列里面,一个消费者有可能不够用。</font>

##### 3.那么怎么让消费者同事处理多个消息呢?

在同一个队列上创建多个消费者,让他们相互竞争,这样消费者就可以同时处理多条消息了

##### 4.两种消息发送机制

###### 1.Round-robin(轮询分发)

轮询分发: 生产者会将消息通过轮询的方式，将消息发送给消费者。结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个分。

###### 2.Fair dispatch(公平分发)
![](https://52lu.github.io/images/mq/fair-dispatch.png)

虽然Round-robin(轮询分发)方式也还行，但是有个问题就是:比如:现在有 2 个消费者，所有的偶数的消息都是繁忙的，而 奇数则是轻松的。按照轮询的方式，偶数的任务交给了第一个消费者，所以一直在忙个不停。奇数的任务交给另一 个消费者，则立即完成任务，然后闲得不行。

而 RabbitMQ 则是不了解这些的。他是不知道你消费者的消费能力的,这是因为当消息进入队列，RabbitMQ 就会分派 消息。而 rabbitmq 只是盲目的将消息轮询的发给消费者。你一个我一个的这样发送.

 <font color=green>为了解决这个问题，我们使用 basicQos( prefetchCount = 1)方法，来限制 RabbitMQ 只发不超过 1 条的消息给同 一个消费者。当消息处理完毕后，有了反馈 ack，才会进行第二次发送。(也就是说需要手动反馈给 Rabbitmq ) </font>
 
 
 > **<font color=red>还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。**
 
#### 3.订阅模式(Publish/Subscribe)
 
##### 1.模型图片
 
 ![](https://52lu.github.io/images/mq/dingyue.png)
 
 之前学习的都是一个消息只能被一个消费者消费,那么如果我想发一个消息 能被多个消费者消费,这时候怎么
 办? 这时候我们就得用到了消息中的发布订阅模型。
 
##### 解读
1. 1 个生产者，多个消费者
2. 每一个消费者都有自己的一个队列 
3. 生产者没有将消息直接发送到队列，而是发送到了交换机(转发器)
4. 每个队列都要绑定到交换机
5. 生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的


#### 4.路由模式(Routing)
 
##### 1.模型图片
 
![](https://52lu.github.io/images/mq/routing.png)


生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。也就是让消费者有选择性的接收消息。


#### 5.主题模式(Topics)
 
##### 1.模型图片
![](https://52lu.github.io/images/mq/topics.png)

上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。

<font color=red>符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。